<html>
<head>
  <title>Clojure from the ground up</title>
  <link rel="stylesheet" type="text/css" href="/css" />
    <link type="application/atom+xml" rel="alternate" href="/tags/Clojure-from-the-ground-up.atom" />
  <script src="/js"></script>
</head>
<body>
  <div id="adminbar">
    <form id="login" action="/login" method="post">
      <label for="admin_login">Login</label>
      <input type="text" name="login" id="admin_login" />
      
      <label for="admin_password">Password</label>
      <input type="password" name="password" id="admin_password" />
      <input type="submit" name="action" value="Log in" />
    </form>
  <div class="clear"></div>
</div>


  <header>
    <nav>
      <h1><a href="/">Aphyr</a></h1>
      <ul>
        <li><a href="/posts">Blog</a></li>
        <li><a href="/photos">Photography</a></li>
        <li><a href="http://github.com/aphyr">Code</a></li>
      </ul>
    </nav>
  </header>

  <div id="content">
    

    <div class="short">
      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/319-clojure-from-the-ground-up-debugging">Clojure from the ground up: debugging</a></h1>
    </div>
    <div class="body">
      <p>Writing software can be an exercise in frustration. Useless error messages, difficult-to-reproduce bugs, missing stacktrace information, obscure functions without documentation, and unmaintained libraries all stand in our way. As software engineers, our most useful skill isn&rsquo;t so much <em>knowing how to solve a problem</em> as <em>knowing how to explore a problem that we haven&rsquo;t seen before</em>. Experience is important, but even experienced engineers face unfamiliar bugs every day. When a problem doesn&rsquo;t bear a resemblance to anything we&rsquo;ve seen before, we fall back on <em>general cognitive strategies</em> to explore&ndash;and ultimately solve&ndash;the problem.</p>

<p>There&rsquo;s an excellent book by the mathematician George Polya: <a href="http://www.amazon.com/How-Solve-It-Mathematical-Princeton/dp/069111966X">How to Solve It</a>, which tries to catalogue how successful mathematicians approach unfamiliar problems. When I catch myself banging my head against a problem for more than a few minutes, I try to back up and consider his <a href="http://math.berkeley.edu/%7Egmelvin/polya.pdf">principles</a>. Sometimes, just taking the time to slow down and reflect can get me out of a rut.</p>

<ol>
<li>Understand the problem.</li>
<li>Devise a plan.</li>
<li>Carry out the plan</li>
<li>Look back</li>
</ol>

<p>Seems easy enough, right? Let&rsquo;s go a little deeper.</p>

<h2>Understanding the problem</h2>

<p>Well <em>obviously</em> there&rsquo;s a problem, right? The program failed to compile, or a test spat out bizarre numbers, or you hit an unexpected exception. But try to dig a little deeper than that. Just having a careful description of the problem can make the solution obvious.</p>

<blockquote>
<p>Our audit program detected that users can double-withdraw cash from their accounts.</p>
</blockquote>

<p>What does your program do? Chances are your program is large and complex, so try to <em>isolate</em> the problem as much as possible. Find <em>preconditions</em> where the error holds.</p>

<blockquote>
<p>The problem occurs after multiple transfers between accounts.</p>
</blockquote>

<p>Identify specific lines of code from the stacktrace that are involved, specific data that&rsquo;s being passed around. Can you find a particular function that&rsquo;s misbehaving?</p>

<blockquote>
<p>The balance transfer function sometimes doesn&rsquo;t increase or decrease the account values correctly.</p>
</blockquote>

<p>What are that function&rsquo;s inputs and outputs? Are the inputs what you expected? What did you expect the result to be, given those arguments? It&rsquo;s not enough to know &ldquo;it doesn&rsquo;t work&rdquo;&ndash;you need to know exactly what <em>should</em> have happened. Try to find conditions where the function works correctly, so you can map out the boundaries of the problem.</p>

<blockquote>
<p>Trying to transfer $100 from A to B works as expected, as does a transfer of $50 from B to A. Running a million random transfers between accounts, sequentially, results in correct balances. The problem only seems to happen in production.</p>
</blockquote>

<p>If your function&ndash;or functions it calls&ndash;uses mutable state, like an agent, atom, or ref, the value of those references matters too. This is why you should avoid mutable state wherever possible: each mutable variable introduces another dimension of possible behaviors for your program. Print out those values when they&rsquo;re read, and after they&rsquo;re written, to get a description of what the function is actually doing. I am a huge believer in sprinkling <code>(prn x)</code> throughout one&rsquo;s code to print how state evolves when the program runs.</p>

<blockquote>
<p>Each balance is stored in a separate atom. When two transfers happen at the same time involving the same accounts, the new value of one or both atoms may not reflect the transfer correctly.</p>
</blockquote>

<p>Look for <em>invariants</em>: properties that should always be true of a program. Devise a test to look for where those invariants are broken. Consider each individual step of the program: does it preserve all the invariants you need? If it doesn&rsquo;t, what ensures those invariants are restored correctly?</p>

<blockquote>
<p>The total amount of money in the system should be constant&ndash;but sometimes changes!</p>
</blockquote>

<p>Draw diagrams, and invent a notation to talk about the problem. If you&rsquo;re accessing fields in a vector, try drawing the vector as a set of boxes, and drawing the fields it accesses, step by step on paper. If you&rsquo;re manipulating a tree, draw one! Figure out a way to write down the state of the system: in letters, numbers, arrows, graphs, whatever you can dream up.</p>
<code class="block">Transferring $5 from A to B in transaction 1, and $5 from B to A in transaction 2:

Transaction  |  A  |  B
-------------+-----+-----
txn1 read    |  10 |  10   ; Transaction 1 sees 10, 10
txn1 write A |   5 |  10   ; A and B now out-of-sync
txn2 read    |   5 |  10   ; Transaction 2 sees 5, 10
txn1 write B |   5 |  15   ; Transaction 1 completes
txn2 write A |  10 |  15   ; Transaction 2 writes based on out-of-sync read
txn2 write B |   5 |  5    ; Should have been 10, 10!</code>
<p>This doesn&rsquo;t <em>solve</em> the problem, but helps us <em>explore</em> the problem in depth. Sometimes this makes the solution obvious&ndash;other times, we&rsquo;re just left with a pile of disjoint facts. Even if things <em>look</em> jumbled-up and confusing, don&rsquo;t despair! Exploring gives the brain the pieces; it&rsquo;ll link them together over time.</p>

<p>Armed with a detailed <em>description</em> of the problem, we&rsquo;re much better equipped to solve it.</p>

<h2>Devise a plan</h2>

<p>Our brains are excellent pattern-matchers, but not that great at tracking abstract logical operations. Try changing your viewpoint: rotating the problem into a representation that&rsquo;s a little more tractable for your mind. Is there a similar problem you&rsquo;ve seen in the past? Is this a well-known problem?</p>

<p>Make sure you know how to <em>check</em> the solution. With the problem isolated to a single function, we can write a test case that verifies the account balances are correct. Then we can experiment freely, and have some confidence that we&rsquo;ve actually found a solution.</p>

<p>Can you solve a <em>related</em> problem? If only concurrent transfers trigger the problem, could we solve the issue by ensuring transactions never take place concurrently&ndash;e.g. by wrapping the operation in a lock? Could we solve it by <em>logging</em> all transactions, and replaying the log? Is there a simpler variant of the problem that might be tractable&ndash;maybe one that always <em>overcounts</em>, but never <em>undercounts</em>?</p>

<p>Consider your assumptions. We rely on layers of abstraction in writing software&ndash;that changing a variable is atomic, that lexical variables don&rsquo;t change, that adding 1 and 1 always gives 2. Sometimes, parts of the computer <em>fail</em> to guarantee those abstractions hold. The CPU might&ndash;very rarely&ndash;fail to divide numbers correctly. A library might, for supposedly valid input, spit out a bad result. A numeric algorithm might fail to converge, and spit out wrong numbers. To avoid questioning <em>everything</em>, start in your own code, and work your way down to the assumptions themselves. See if you can devise tests that check the language or library is behaving as you expect.</p>

<p>Can you avoid solving the problem altogether? Is there a library, database, or language feature that does transaction management for us? Is integrating that library worth the reduced complexity in our application?</p>

<p>We&rsquo;re not mathematicians; we&rsquo;re engineers. Part theorist, yes, but also part mechanic. Some problems take a more abstract approach, and others are better approached by tapping it with a wrench and checking the service manual. If other people have solved your problem already, using their solution can be much simpler than devising your own.</p>

<p>Can you think of a way to get more diagnostic information? Perhaps we could log more data from the functions that are misbehaving, or find a way to dump and replay transactions from the live program. Some problems <em>disappear</em> when instrumented; these are the hardest to solve, but also the most rewarding.</p>

<p>Combine key phrases in a Google search: the name of the library you&rsquo;re using, the type of exception thrown, any error codes or log messages. Often you&rsquo;ll find a StackOverflow result, a mailing list post, or a Github issue that describes your problem. This works well when you know the technical terms for your problem&ndash;in our case, that we&rsquo;re performing a <em>atomic</em>, <em>transactional</em> transfer between two variables. Sometimes, though, you don&rsquo;t <em>know</em> the established names for your problem, and have to resort to blind queries like &ldquo;variables out of sync&rdquo; or &ldquo;overwritten data&rdquo;&ndash;which are much more difficult.</p>

<p>When you get stuck exploring on your own, try asking for help. Collect your description of the problem, the steps you took, and what you expected the program to do. Include any stacktraces or error messages, log files, and the smallest section of source code required to reproduce the problem. Also include the versions of software used&ndash;in Clojure, typically the JVM version (<code>java -version</code>), Clojure version (<code>project.clj</code>), and any other relevant library versions.</p>

<p>If the project has a Github page or public issue tracker, like Jira, you can try filing an issue there. Here&rsquo;s a <a href="https://github.com/aphyr/riemann-dash/issues/66">particularly well-written issue</a> filed by a user on one of my projects. Note that this user included installation instructions, the command they ran, and the stacktrace it printed. The more specific a description you provide, the easier it is for someone else to understand your problem and help!</p>

<p>Sometimes you need to talk through a problem interactively. For that, I prefer IRC&ndash;many projects have a channel on <a href="http://freenode.net/">the Freenode IRC network</a> where you can ask basic questions. Remember to be respectful of the channel&rsquo;s time; there may be hundreds of users present, and they have to sort through everything you write. Paste your problem description into a <em>pastebin</em> like <a href="https://gist.github.com/">Gist</a>, then mention the link in IRC with a short&ndash;say a few sentences&ndash;description of the problem. I try asking in a channel devoted to a specific library or program first, then back off to a more general channel, like #clojure. There&rsquo;s no need to ask &ldquo;Can I ask a question&rdquo; first&ndash;just jump in.</p>

<p>Since the transactional problem we&rsquo;ve been exploring seems like a general issue with atoms, I might ask in #clojure</p>
<code class="block">aphyr &gt; Hi! Does anyone know the right way to change multiple atoms at the same time?
aphyr &gt; This function and test case (http:&#x2F;&#x2F;gist.github.com&#x2F;...) seems to double-
        or under-count when invoked concurrently.</code>
<p>Finally, you can join the project&rsquo;s email list, and ask your question there. Turnaround times are longer, but you&rsquo;ll often find a more in-depth response to your question via email. This applies especially if you and the maintainer are in different time zones, or if they&rsquo;re busy with life. You can also ask specific problems on StackOverflow or other message boards; users there can be incredibly helpful.</p>

<p>Remember, other engineers are taking time away from their work, family, friends, and hobbies to help you. It&rsquo;s always polite to give them time to answer first&ndash;they may have other priorities. A sincere thank-you is always appreciated&ndash;as is paying it forward by answering other users&#39; questions on the list or channel!</p>

<h3>Dealing with abuse</h3>

<p>Sadly, some women, LGBT people, and so on experience harassment on IRC or in other discussion circles. They may be asked inappropriate personal questions, insulted, threatened, assumed to be straight, to be a man, and so on. Sometimes other users will attack questioners for inexperience. Exclusion can be overt (&ldquo;Read the fucking docs, faggot!&rdquo;) or more subtle (&ldquo;Hey dudes, what&rsquo;s up?&rdquo;). It only takes one hurtful experience this to sour someone on an entire community.</p>

<p>If this happens to you, <b>place your own well-being first</b>. You are <em>not</em> obligated to fix anyone else&rsquo;s problems, or to remain in a social context that makes you uncomfortable.</p>

<p>That said, be aware the other people in a channel may not share your culture. English may not be their main language, or they may have said something hurtful without realizing its impact. Explaining how the comment made you feel can jar a well-meaning but unaware person into reconsidering their actions.</p>

<p>Other times, people are just <em>mean</em>&ndash;and it only takes one to ruin everybody&rsquo;s day. When this happens, you can appeal to a moderator. On IRC, moderators are sometimes identified by an <code>@</code> sign in front of their name; on forums, they may have a special mark on their username or profile. Large projects may have an official policy for reporting abuse on their website or in the channel topic. If there&rsquo;s no policy, try asking whoever seems in charge for help. Most projects have a primary maintainer or community manager with the power to mute or ban malicious users.</p>

<p>Again, these ways of dealing with abuse are <em>optional</em>. You have no responsibility to provide others with endless patience, and it is not your responsibility to fix a toxic culture. You can always log off and try something else. There are many communities which will welcome and support you&ndash;it may just take a few tries to find the right fit.</p>

<p>If you don&rsquo;t find community, you can <em>build</em> it. Starting your own IRC channel, mailing list, or discussion group with a few friends can be a great way to help each other learn in a supportive environment. And if trolls ever come calling, you&rsquo;ll be able to ban them personally.</p>

<p>Now, back to problem-solving.</p>

<h2>Execute the plan</h2>

<p>Sometimes we can make a quick fix in the codebase, test it by hand, and move on. But for more serious problems, we&rsquo;ll need a more involved process. I always try to get a reproducible test suite&ndash;one that runs in a matter of seconds&ndash;so that I can continually check my work.</p>

<p>Persist. Many problems require grinding away for some time. Mix blind experimentation with sitting back and planning. Periodically re-evaluate your work&ndash;have you made progress? Identified a sub-problem that can be solved independently? Developed a new notation?</p>

<p>If you get stuck, try a new tack. Save your approach as a comment or using <code>git stash</code>, and start fresh. Maybe using a different concurrency primitive is in order, or rephrasing the data structure entirely. Take a reading break and review the documentation for the library you&rsquo;re trying to use. Read the <em>source code</em> for the functions you&rsquo;re calling&ndash;even if you don&rsquo;t understand exactly what it does, it might give you clues to how things work under the hood.</p>

<p>Bounce your problem off a friend. Grab a sheet of paper or whiteboard, describe the problem, and work through your thinking with that person. Their understanding of the problem might be totally off-base, but can still give you valuable insight. Maybe they know exactly what the problem is, and can point you to a solution in thirty seconds!</p>

<p>Finally, take a break. Go home. Go for a walk. Lift heavy, run hard, space out, drink with your friends, practice music, read a book. Just before sleep, go over the problem once more in your head; I often wake up with a new algorithm or new questions burning to get out. Your unconscious mind can come up with unexpected insights if given time <em>away</em> from the problem!</p>

<p>Some folks swear by time in the shower, others by  hiking, or with pen and paper in a hammock. Find what works for you! The important thing seems to be giving yourself <em>away</em> from struggling with the problem.</p>

<h2>Look back</h2>

<p>Chances are you&rsquo;ll know as soon as your solution works. The program compiles, transactions generate the correct amounts, etc. Now&rsquo;s an important time to <em>solidify</em> your work.</p>

<p>Bolster your tests. You may have made the problem <em>less likely</em>, but not actually solved it. Try a more aggressive, randomized test; one that runs for longer, that generates a broader class of input. Try it on a copy of the production workload before deploying your change.</p>

<p>Identify <em>why</em> the new system works. Pasting something in from StackOverflow may get you through the day, but won&rsquo;t help you solve similar problems in the future. Try to really understand <em>why</em> the program went wrong, and how the new pieces work together to prevent the problem. Is there a more general underlying problem? Could you generalize your technique to solve a related problem? If you&rsquo;ll encounter this type of issue frequently, could you build a function or library to help build other solutions?</p>

<p>Document the solution. Write down your description of the problem, and why your changes fix it, as comments in the source code. Use that same description of the solution in your commit message, or attach it as a comment to the resources you used online, so that other people can come to the same understanding.</p>

<h2>Debugging Clojure</h2>

<p>With these general strategies in mind, I&rsquo;d like to talk specifically about the debugging <em>Clojure</em> code&ndash;especially understanding its <em>stacktraces</em>. Consider this simple program for baking cakes:</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.debugging</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">bake</span>
  <span class="s">&quot;Bakes a cake for a certain amount of time, returning a cake with a new</span>
<span class="s">  :tastiness level.&quot;</span>
  <span class="p">[</span><span class="nv">pie</span> <span class="nv">temp</span> <span class="nv">time</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">pie</span> <span class="ss">:tastiness</span>
         <span class="p">(</span><span class="nf">condp</span> <span class="p">(</span><span class="nb">* </span><span class="nv">temp</span> <span class="nv">time</span><span class="p">)</span> <span class="nv">&lt;</span>
           <span class="mi">400</span> <span class="ss">:burned</span>
           <span class="mi">350</span> <span class="ss">:perfect</span>
           <span class="mi">300</span> <span class="ss">:soggy</span><span class="p">)))</span>
</code>
<p>And in the REPL</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bake</span> <span class="p">{</span><span class="ss">:flavor</span> <span class="ss">:blackberry</span><span class="p">}</span> <span class="mi">375</span> <span class="mf">10.25</span><span class="p">)</span>

<span class="nv">ClassCastException</span> <span class="nv">java.lang.Double</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nb">cast </span><span class="nv">to</span> <span class="nv">clojure.lang.IFn</span>  <span class="nv">scratch.debugging/bake</span> <span class="p">(</span><span class="nf">debugging.clj</span><span class="ss">:8</span><span class="p">)</span>
</code>
<p>This is not particularly helpful. Let&rsquo;s print a full stacktrace using <code>pst</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pst</span><span class="p">)</span>
<span class="nv">ClassCastException</span> <span class="nv">java.lang.Double</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nb">cast </span><span class="nv">to</span> <span class="nv">clojure.lang.IFn</span>
    <span class="nv">scratch.debugging/bake</span> <span class="p">(</span><span class="nf">debugging.clj</span><span class="ss">:8</span><span class="p">)</span>
    <span class="nv">user/eval1223</span> <span class="p">(</span><span class="nf">form-init4495957503656407289.clj</span><span class="ss">:1</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.eval</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:6619</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.eval</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:6582</span><span class="p">)</span>
    <span class="nv">clojure.core/eval</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:2852</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/read-eval-print--6588/fn--6591</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:259</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/read-eval-print--6588</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:259</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/fn--6597</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:277</span><span class="p">)</span>
    <span class="nv">clojure.main/repl</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:277</span><span class="p">)</span>
    <span class="nv">clojure.tools.nrepl.middleware.interruptible-eval/evaluate/fn--591</span> <span class="p">(</span><span class="nf">interruptible_eval.clj</span><span class="ss">:56</span><span class="p">)</span>
    <span class="nv">clojure.core/apply</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:617</span><span class="p">)</span>
    <span class="nv">clojure.core/with-bindings*</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:1788</span><span class="p">)</span>
</code>
<p>The first line tells us the <em>type</em> of the error: a <code>ClassCastException</code>. Then there&rsquo;s some explanatory text: we can&rsquo;t cast a <code>java.lang.Double</code> to a <code>clojure.lang.IFn</code>. The indented lines show the functions that led to the error. The first line is the deepest function, where the error actually occurred: the <code>bake</code> function in the <code>scratch.debugging</code> namespace. In parentheses is the file name (<code>debugging.clj</code>) and line number (<code>8</code>) from the code that caused the error. Each following line shows the function that <em>called</em> the previous line. In the REPL, our code is invoked from a special function compiled by the REPL itself&ndash;with an automatically generated name like <code>user/eval1223</code>, and that function is invoked by the Clojure compiler, and the REPL tooling. Once we see something like <code>Compiler.eval</code> at the repl, we can generally skip the rest.</p>

<p>As a general rule, we want to look at the <em>deepest</em> (earliest) point in the stacktrace <em>that we wrote</em>. Sometimes an error will arise from deep within a library or Clojure itself&ndash;but it was probably <em>invoked</em> by our code somewhere. We&rsquo;ll skim down the lines until we find our namespace, and start our investigation at that point.</p>

<p>Our case is simple: <code>bake.clj</code>, on line 8, seems to be the culprit.</p>
<code class="block">         <span class="p">(</span><span class="nf">condp</span> <span class="p">(</span><span class="nb">* </span><span class="nv">temp</span> <span class="nv">time</span><span class="p">)</span> <span class="nv">&lt;</span>
</code>
<p>Now let&rsquo;s consider the error itself: <code>ClassCastException: java.lang.Double cannot be cast to clojure.lang.IFn</code>. This implies we had a <code>Double</code> and tried to cast it to an <code>IFn</code>&ndash;but what does &ldquo;cast&rdquo; mean? For that matter, what&rsquo;s a <code>Double</code>, or an <code>IFn</code>?</p>

<p>A quick google search for <a href="https://www.google.com/search?q=java.lang.double">java.lang.Double</a> reveals that it&rsquo;s a <em>class</em> (a Java type) with some <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Double.html">basic documentation</a>. &ldquo;The Double class wraps a value of the primitive type <code>double</code> in an object&rdquo; is not particularly informative&ndash;but the &ldquo;class hierarchy&rdquo; at the top of the page shows that a <code>Double</code> is a kind of <code>java.lang.Number</code>. Let&rsquo;s experiment at the REPL:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">java.lang.Long</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mf">4.5</span><span class="p">)</span>
<span class="nv">java.lang.Double</span>
</code>
<p>Indeed: decimal numbers in Clojure appear to be doubles. One of the expressions in that <code>condp</code> call was probably a decimal. At first we might suspect the literal values <code>300</code>, <code>350</code>, or <code>400</code>&ndash;but those are <code>Long</code>s, not <code>Doubles</code>. The only <code>Double</code> we passed in was the time duration <code>10.25</code>&ndash;which appears in <code>condp</code> as <code>(* temp time)</code>. That first argument was a <code>Double</code>, but <em>should</em> have been an IFn.</p>

<p><a href="https://www.google.com/search?q=clojure.lang.IFn">What the heck is an IFn?</a> Its <a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/IFn.java">source code</a> has a comment:</p>

<blockquote>
<p>IFn provides complete access to invoking any of Clojure&rsquo;s API&rsquo;s. You can also access any other library written in Clojure, after adding
either its source or compiled form to the classpath.</p>
</blockquote>

<p>So IFn has to do with <em>invoking</em> Clojure&rsquo;s API. Ah&ndash;<code>Fn</code> probably stands for <em>function</em>&ndash;and this class is chock full of things like <code>invoke(Object arg1, Object arg2)</code>. That suggests that IFn is about <em>calling functions</em>. And the <code>I</code>? Google <a href="https://www.google.com/search?q=java+interface+starts+with+i">suggests</a> it&rsquo;s a Java convention for an <em>interface</em>&ndash;whatever that is. Remember, we don&rsquo;t have to understand <em>everything</em>&ndash;just enough to get by. There&rsquo;s plenty to explore later.</p>

<p>Let&rsquo;s check our hypothesis in the repl:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">instance? </span><span class="nv">clojure.lang.IFn</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="nv">false</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">instance? </span><span class="nv">clojure.lang.IFn</span> <span class="nv">conj</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">instance? </span><span class="nv">clojure.lang.IFn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)))</span>
<span class="nv">true</span>
</code>
<p>So <code>Doubles</code> aren&rsquo;t IFns&ndash;but Clojure built-in functions, and anonymous functions, both are. Let&rsquo;s double-check the docs for <code>condp</code> again:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">doc </span><span class="nv">condp</span><span class="p">)</span>
<span class="nv">-------------------------</span>
<span class="nv">clojure.core/condp</span>
<span class="p">([</span><span class="nv">pred</span> <span class="nv">expr</span> <span class="o">&amp;</span> <span class="nv">clauses</span><span class="p">])</span>
<span class="nv">Macro</span>
  <span class="nv">Takes</span> <span class="nv">a</span> <span class="nv">binary</span> <span class="nv">predicate</span>, <span class="nv">an</span> <span class="nv">expression</span>, <span class="nb">and </span><span class="nv">a</span> <span class="nb">set </span><span class="nv">of</span> <span class="nv">clauses.</span>
  <span class="nv">Each</span> <span class="nv">clause</span> <span class="nv">can</span> <span class="nb">take </span><span class="nv">the</span> <span class="nv">form</span> <span class="nv">of</span> <span class="nv">either</span><span class="err">:</span>

  <span class="nv">test-expr</span> <span class="nv">result-expr</span>

  <span class="nv">test-expr</span> <span class="ss">:&gt;&gt;</span> <span class="nv">result-fn</span>

  <span class="nv">Note</span> <span class="ss">:&gt;&gt;</span> <span class="nv">is</span> <span class="nv">an</span> <span class="nv">ordinary</span> <span class="nv">keyword.</span>

  <span class="nv">For</span> <span class="nv">each</span> <span class="nv">clause</span>, <span class="p">(</span><span class="nf">pred</span> <span class="nv">test-expr</span> <span class="nv">expr</span><span class="p">)</span> <span class="nv">is</span> <span class="nv">evaluated.</span> <span class="nv">If</span> <span class="nv">it</span> <span class="nv">returns</span>
  <span class="nv">logical</span> <span class="nv">true</span>, <span class="nv">the</span> <span class="nv">clause</span> <span class="nv">is</span> <span class="nv">a</span> <span class="nv">match.</span> <span class="nv">If</span> <span class="nv">a</span> <span class="nv">binary</span> <span class="nv">clause</span> <span class="nv">matches</span>, <span class="nv">the</span>
  <span class="nv">result-expr</span> <span class="nv">is</span> <span class="nv">returned</span>, <span class="k">if </span><span class="nv">a</span> <span class="nv">ternary</span> <span class="nv">clause</span> <span class="nv">matches</span>, <span class="nv">its</span> <span class="nv">result-fn</span>,
  <span class="nv">which</span> <span class="nv">must</span> <span class="nv">be</span> <span class="nv">a</span> <span class="nv">unary</span> <span class="nv">function</span>, <span class="nv">is</span> <span class="nv">called</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">result</span> <span class="nv">of</span> <span class="nv">the</span>
  <span class="nv">predicate</span> <span class="nv">as</span> <span class="nv">its</span> <span class="nv">argument</span>, <span class="nv">the</span> <span class="nv">result</span> <span class="nv">of</span> <span class="nv">that</span> <span class="nv">call</span> <span class="nv">being</span> <span class="nv">the</span> <span class="nv">return</span>
  <span class="nv">value</span> <span class="nv">of</span> <span class="nv">condp.</span> <span class="nv">A</span> <span class="nv">single</span> <span class="nv">default</span> <span class="nv">expression</span> <span class="nv">can</span> <span class="nv">follow</span> <span class="nv">the</span> <span class="nv">clauses</span>,
  <span class="nb">and </span><span class="nv">its</span> <span class="nv">value</span> <span class="nv">will</span> <span class="nv">be</span> <span class="nv">returned</span> <span class="k">if </span><span class="nv">no</span> <span class="nv">clause</span> <span class="nv">matches.</span> <span class="nv">If</span> <span class="nv">no</span> <span class="nv">default</span>
  <span class="nv">expression</span> <span class="nv">is</span> <span class="nv">provided</span> <span class="nb">and </span><span class="nv">no</span> <span class="nv">clause</span> <span class="nv">matches</span>, <span class="nv">an</span>
  <span class="nv">IllegalArgumentException</span> <span class="nv">is</span> <span class="nv">thrown.clj</span>
</code>
<p>That&rsquo;s a lot to take in! No wonder we got it wrong! We&rsquo;ll take it slow, and look at the arguments.</p>
<code class="block"><span class="p">(</span><span class="nf">condp</span> <span class="p">(</span><span class="nb">* </span><span class="nv">temp</span> <span class="nv">time</span><span class="p">)</span> <span class="nv">&lt;</span>
</code>
<p>Our <code>pred</code> was <code>(* temp time)</code> (a <code>Double</code>), and our <code>expr</code> was the comparison function <code>&lt;</code>. For each clause, <code>(pred test-expr expr)</code> is evaluated, so that would expand to something like</p>
<code class="block"><span class="p">((</span><span class="nb">* </span><span class="nv">temp</span> <span class="nv">time</span><span class="p">)</span> <span class="mi">400</span> <span class="nv">&lt;</span><span class="p">)</span>
</code>
<p>Which evaluates to something like</p>
<code class="block"><span class="p">(</span><span class="mf">123.45</span> <span class="mi">400</span> <span class="nv">&lt;</span><span class="p">)</span>
</code>
<p>But this isn&rsquo;t a valid Lisp program! It starts with a number, not a function. We should have written <code>(&lt; 123.45 400)</code>. Our arguments are backwards!</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">bake</span>
  <span class="s">&quot;Bakes a cake for a certain amount of time, returning a cake with a new</span>
<span class="s">  :tastiness level.&quot;</span>
  <span class="p">[</span><span class="nv">pie</span> <span class="nv">temp</span> <span class="nv">time</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">pie</span> <span class="ss">:tastiness</span>
         <span class="p">(</span><span class="nf">condp</span> <span class="nb">&lt; </span><span class="p">(</span><span class="nb">* </span><span class="nv">temp</span> <span class="nv">time</span><span class="p">)</span>
           <span class="mi">400</span> <span class="ss">:burned</span>
           <span class="mi">350</span> <span class="ss">:perfect</span>
           <span class="mi">300</span> <span class="ss">:soggy</span><span class="p">)))</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bake</span> <span class="p">{</span><span class="ss">:flavor</span> <span class="ss">:chocolate</span><span class="p">}</span> <span class="mi">375</span> <span class="mf">10.25</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:tastiness</span> <span class="ss">:burned</span>, <span class="ss">:flavor</span> <span class="ss">:chocolate</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bake</span> <span class="p">{</span><span class="ss">:flavor</span> <span class="ss">:chocolate</span><span class="p">}</span> <span class="mi">450</span> <span class="mf">0.8</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:tastiness</span> <span class="ss">:perfect</span>, <span class="ss">:flavor</span> <span class="ss">:chocolate</span><span class="p">}</span>
</code>
<p>Mission accomplished! We read the stacktrace as a <em>path</em> to a part of the program where things went wrong. We identified the deepest part of that path in <em>our</em> code, and looked for a problem there. We discovered that we had reversed the arguments to a function, and after some research and experimentation in the REPL, figured out the right order.</p>

<p>An aside on types: some languages have a <em>stricter</em> type system than Clojure&rsquo;s, in which the types of variables are explicitly declared in the program&rsquo;s source code. Those languages can detect type errors&ndash;when a variable of one type is used in place of another, incompatible, type&ndash;and offer more precise feedback. In Clojure, the compiler does not generally enforce types at compile time, which allows for significant flexibility&ndash;but requires more rigorous testing to expose these errors.</p>

<h2>Higher order stacktraces</h2>

<p>The stacktrace shows us a <em>path</em> through the program, moving downwards through functions. However, that path may not be straightforward. When data is handed off from one part of the program to another, the stacktrace may not show the <em>origin</em> of an error. When <em>functions</em> are handed off from one part of the program to another, the resulting traces can be tricky to interpret indeed.</p>

<p>For instance, say we wanted to make some picture frames out of wood, but didn&rsquo;t know how much wood to buy. We might sketch out a program like this:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">perimeter</span>
  <span class="s">&quot;Given a rectangle, returns a vector of its edge lengths.&quot;</span>
  <span class="p">[</span><span class="nv">rect</span><span class="p">]</span>
  <span class="p">[(</span><span class="ss">:x</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:z</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">)])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">frame</span>
  <span class="s">&quot;Given a mat width, and a photo rectangle, figure out the size of the frame</span>
<span class="s">  required by adding the mat width around all edges of the photo.&quot;</span>
  <span class="p">[</span><span class="nv">mat-width</span> <span class="nv">rect</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">margin</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">rect</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">margin</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">rect</span><span class="p">))</span>
     <span class="ss">:y</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">margin</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">))}))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">failure-rate</span>
  <span class="s">&quot;Sometimes the wood is knotty or we screw up a cut. We&#39;ll assume we need a</span>
<span class="s">  spare segment once every 8.&quot;</span>
  <span class="mi">1</span><span class="nv">/8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">spares</span>
  <span class="s">&quot;Given a list of segments, figure out roughly how many of each distinct size</span>
<span class="s">  will go bad, and emit a sequence of spare segments, assuming we screw up</span>
<span class="s">  `failure-rate` of them.&quot;</span>
  <span class="p">[</span><span class="nv">segments</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">segments</span>
       <span class="c1">; Compute a map of each segment length to the number of</span>
       <span class="c1">; segments we&#39;ll need of that size.</span>
       <span class="nv">frequencies</span>
       <span class="c1">; Make a list of spares for each segment length,</span>
       <span class="c1">; based on how often we think we&#39;ll screw up.</span>
       <span class="p">(</span><span class="nb">mapcat </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span> <span class="p">[</span><span class="nv">segment</span> <span class="nv">n</span><span class="p">]]</span>
                 <span class="p">(</span><span class="nb">repeat </span><span class="p">(</span><span class="nb">* </span><span class="nv">failure-rate</span> <span class="nv">n</span><span class="p">)</span>
                         <span class="nv">segment</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">cut-size</span>
  <span class="s">&quot;How much extra wood do we need for each cut? Let&#39;s say a mitred cut for a</span>
<span class="s">  1-inch frame needs a full inch.&quot;</span>
  <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">total-wood</span>
  <span class="p">[</span><span class="nv">mat-width</span> <span class="nv">photos</span><span class="p">]</span>
  <span class="s">&quot;Given a mat width and a collection of photos, compute the total linear</span>
<span class="s">  amount of wood we need to buy in order to make frames for each, given a</span>
<span class="s">  2-inch mat.&quot;</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">segments</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">photos</span>
                      <span class="c1">; Convert photos to frame dimensions</span>
                      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">))</span>
                      <span class="c1">; Convert frames to segments</span>
                      <span class="p">(</span><span class="nb">mapcat </span><span class="nv">perimeter</span><span class="p">))]</span>

    <span class="c1">; Now, take segments</span>
    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">segments</span>
         <span class="c1">; Add the spares</span>
         <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">spares</span> <span class="nv">segments</span><span class="p">))</span>
         <span class="c1">; Include a cut between each segment</span>
         <span class="p">(</span><span class="nf">interpose</span> <span class="nv">cut-size</span><span class="p">)</span>
         <span class="c1">; And sum the whole shebang.</span>
         <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">[{</span><span class="ss">:x</span> <span class="mi">8</span>
       <span class="ss">:y</span> <span class="mi">10</span><span class="p">}</span>
      <span class="p">{</span><span class="ss">:x</span> <span class="mi">10</span>
       <span class="ss">:y</span> <span class="mi">8</span><span class="p">}</span>
      <span class="p">{</span><span class="ss">:x</span> <span class="mi">20</span>
       <span class="ss">:y</span> <span class="mi">30</span><span class="p">}]</span>
     <span class="p">(</span><span class="nf">total-wood</span> <span class="mi">2</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">println </span><span class="s">&quot;total inches:&quot;</span><span class="p">))</span>
</code>
<p>Running this program yields a curious stacktrace. We&rsquo;ll print the <em>full</em> trace (not the shortened one that comes with <code>pst</code>) for the last exception <code>*e</code> with the <code>.printStackTrace</code> function.</p>
<code class="block">user=&gt; (.printStackTrace *e)
java.lang.ClassCastException: clojure.lang.PersistentArrayMap cannot be cast to java.lang.Number, compiling:(scratch&#x2F;debugging.clj:73:23)
    at clojure.lang.Compiler.load(Compiler.java:7142)
    at clojure.lang.RT.loadResourceScript(RT.java:370)
    at clojure.lang.RT.loadResourceScript(RT.java:361)
    at clojure.lang.RT.load(RT.java:440)
    at clojure.lang.RT.load(RT.java:411)
        ...
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.ClassCastException: clojure.lang.PersistentArrayMap cannot be cast to java.lang.Number
    at clojure.lang.Numbers.multiply(Numbers.java:146)
    at clojure.lang.Numbers.multiply(Numbers.java:3659)
    at scratch.debugging$frame.invoke(debugging.clj:26)
    at clojure.lang.AFn.applyToHelper(AFn.java:156)
    at clojure.lang.AFn.applyTo(AFn.java:144)
    at clojure.core$apply.invoke(core.clj:626)
    at clojure.core$partial$fn__4228.doInvoke(core.clj:2468)
    at clojure.lang.RestFn.invoke(RestFn.java:408)
    at clojure.core$map$fn__4245.invoke(core.clj:2557)
    at clojure.lang.LazySeq.sval(LazySeq.java:40)
    at clojure.lang.LazySeq.seq(LazySeq.java:49)
    at clojure.lang.RT.seq(RT.java:484)
    at clojure.core$seq.invoke(core.clj:133)
    at clojure.core$map$fn__4245.invoke(core.clj:2551)
    at clojure.lang.LazySeq.sval(LazySeq.java:40)
    at clojure.lang.LazySeq.seq(LazySeq.java:49)
    at clojure.lang.RT.seq(RT.java:484)
    at clojure.core$seq.invoke(core.clj:133)
    at clojure.core$apply.invoke(core.clj:624)
    at clojure.core$mapcat.doInvoke(core.clj:2586)
    at clojure.lang.RestFn.invoke(RestFn.java:423)
    at scratch.debugging$total_wood.invoke(debugging.clj:62)
        ...</code>
<p>First: this trace has <em>two parts</em>. The top-level error (a <code>CompilerException</code>) appears first, and is followed by the exception that <em>caused</em> the <code>CompilerException</code>: a <code>ClassCastException</code>. This makes the stacktrace read somewhat out of order, since the deepest part of the trace occurs in the <em>first</em> line of the <em>last</em> exception. We read <code>C B A</code> then <code>F E D</code>. This is an old convention in the Java language, and the cause of no end of frustration.</p>

<p>Notice that this representation of the stacktrace is less friendly than <code>(pst)</code>. We&rsquo;re seeing the Java Virtual Machine (JVM)&rsquo;s internal representation of Clojure functions, which look like <code>clojure.core$partial$fn__4228.doInvoke</code>. This corresponds to the namespace <code>clojure.core</code>, in which there is a function called <code>partial</code>, inside of which is an <em>anonymous</em> function, here named <code>fn__4228</code>. Calling a Clojure function is written, in the JVM, as <code>.invoke</code> or <code>.doInvoke</code>.</p>

<p>So: the root cause was a <code>ClassCastException</code>, and it tells us that Clojure expected a <code>java.lang.Number</code>, but found a <code>PersistentArrayMap</code>. We might guess that <code>PersistentArrayMap</code> is something to do with the map data structure, which we used in this program:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span><span class="p">})</span>
<span class="nv">clojure.lang.PersistentArrayMap</span>
</code>
<p>And we&rsquo;d be right. We can also tell, by reading down the stacktrace looking for our <code>scratch.debugging</code> namespace, where the error took place: <code>scratch.debugging$frame</code>, on line <code>26</code>.</p>
<code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">margin</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">rect</span><span class="p">)]</span>
</code>
<p>There&rsquo;s our multiplication operation <code>*</code>, which we might assume expands to <code>clojure.lang.Numbers.multiply</code>. But the <em>path</em> to the error is odd.</p>
<code class="block">                 <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">photos</span>
                      <span class="c1">; Convert photos to frame dimensions</span>
                      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">))</span>
</code>
<p>In <code>total-wood</code>, we call <code>(map (partial frame mat-width) photos)</code> right away, so we&rsquo;d expect the stacktrace to go from <code>total-wood</code> to <code>map</code> to <code>frame</code>. But this is <em>not</em> what happens. Instead, <code>total-wood</code> invokes something called <code>RestFn</code>&ndash;a piece of Clojure plumbing&ndash;which in turn calls <code>mapcat</code>.</p>
<code class="block">at clojure.core$mapcat.doInvoke(core.clj:2586)
    at clojure.lang.RestFn.invoke(RestFn.java:423)
    at scratch.debugging$total_wood.invoke(debugging.clj:62)</code>
<p>Why doesn&rsquo;t <code>total-wood</code> call <code>map</code> first? Well it <em>did</em>&ndash;but <code>map</code> doesn&rsquo;t actually apply its function to anything in the <code>photos</code> vector when invoked. Instead, it returns a <em>lazy</em> sequence&ndash;one which applies <code>frame</code> only when elements are asked for.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="nv">clojure.lang.LazySeq</span>
</code>
<p>Inside each <code>LazySeq</code> is a box containing a function. When you ask a <code>LazySeq</code> for its first value, it calls that function to return a new sequence&ndash;and <em>that&rsquo;s</em> when <code>frame</code> gets invoked. What we&rsquo;re seeing in this stacktrace is the <code>LazySeq</code> internal machinery at work&ndash;<code>mapcat</code> asks it for a value, and the LazySeq asks <code>map</code> to generate that value.</p>
<code class="block">at clojure.core$partial$fn__4228.doInvoke(core.clj:2468)
    at clojure.lang.RestFn.invoke(RestFn.java:408)
    at clojure.core$map$fn__4245.invoke(core.clj:2557)
    at clojure.lang.LazySeq.sval(LazySeq.java:40)
    at clojure.lang.LazySeq.seq(LazySeq.java:49)
    at clojure.lang.RT.seq(RT.java:484)
    at clojure.core$seq.invoke(core.clj:133)
    at clojure.core$map$fn__4245.invoke(core.clj:2551)
    at clojure.lang.LazySeq.sval(LazySeq.java:40)
    at clojure.lang.LazySeq.seq(LazySeq.java:49)
    at clojure.lang.RT.seq(RT.java:484)
    at clojure.core$seq.invoke(core.clj:133)
    at clojure.core$apply.invoke(core.clj:624)
    at clojure.core$mapcat.doInvoke(core.clj:2586)
    at clojure.lang.RestFn.invoke(RestFn.java:423)
    at scratch.debugging$total_wood.invoke(debugging.clj:62)</code>
<p>In fact we pass through <code>map</code>&rsquo;s laziness <em>twice</em> here: a quick peek at <code>(source mapcat)</code> shows that it expands into a <code>map</code> call itself, and then there&rsquo;s a <em>second</em> map: the one we created in in <code>total-wood</code>. Then an odd thing happens&ndash;we hit something called <code>clojure.core$partial$fn__4228</code>.</p>
<code class="block">  <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">)</span> <span class="nv">photos</span><span class="p">)</span>
</code>
<p>The <code>frame</code> function takes two arguments: a mat width and a photo. We wanted a function that takes just <em>one</em> argument: a photo. <code>(partial frame mat-width)</code> took <code>mat-width</code> and generated a <em>new function</em> which takes one arg&ndash;call it <code>photo</code>&ndash;and calls <code>(frame mad-width photo)</code>. That automatically generated function, returned by <code>partial</code>, is what <code>map</code> uses to generate new elements of its sequence on demand.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">partial + </span><span class="mi">1</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;core$partial$fn__4228</span> <span class="nv">clojure.core$partial$fn__4228</span><span class="o">@</span><span class="mi">243634</span><span class="nv">f2&gt;</span>
<span class="nv">user=&gt;</span> <span class="p">((</span><span class="nb">partial + </span><span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">5</span>
</code>
<p>That&rsquo;s why we see control flow through <code>clojure.core$partial$fn__4228</code> (an anonymous function defined inside <code>clojure.core/partial</code>) on the way to <code>frame</code>.</p>
<code class="block">Caused by: java.lang.ClassCastException: clojure.lang.PersistentArrayMap cannot be cast to java.lang.Number
    at clojure.lang.Numbers.multiply(Numbers.java:146)
    at clojure.lang.Numbers.multiply(Numbers.java:3659)
    at scratch.debugging$frame.invoke(debugging.clj:26)
    at clojure.lang.AFn.applyToHelper(AFn.java:156)
    at clojure.lang.AFn.applyTo(AFn.java:144)
    at clojure.core$apply.invoke(core.clj:626)
    at clojure.core$partial$fn__4228.doInvoke(core.clj:2468)</code>
<p>And there&rsquo;s our suspect! <code>scratch.debugging/frame</code>, at line <code>26</code>. To return to that line again:</p>
<code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">margin</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">rect</span><span class="p">)]</span>
</code>
<p><code>*</code> is a multiplication, and <code>2</code> is obviously a number, but <code>rect</code>&hellip; <code>rect</code> is a map here. Aha! We meant to multiply the <code>mat-width</code> by two, not the rectangle.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">frame</span>
  <span class="s">&quot;Given a mat width, and a photo rectangle, figure out the size of the frame</span>
<span class="s">  required by adding the mat width around all edges of the photo.&quot;</span>
  <span class="p">[</span><span class="nv">mat-width</span> <span class="nv">rect</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">margin</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">mat-width</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">margin</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">rect</span><span class="p">))</span>
     <span class="ss">:y</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">margin</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">))}))</span>
</code>
<p>I believe we&rsquo;ve fixed the bug, then. Let&rsquo;s give it a shot!</p>

<h2>The unbearable lightness of nil</h2>

<p>There&rsquo;s one more bug lurking in this program. This one&rsquo;s stacktrace is short.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>

<span class="nv">CompilerException</span> <span class="nv">java.lang.NullPointerException</span>, <span class="nv">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">scratch/debugging.clj</span><span class="ss">:73:23</span><span class="p">)</span> 
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pst</span><span class="p">)</span>
<span class="nv">CompilerException</span> <span class="nv">java.lang.NullPointerException</span>, <span class="nv">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">scratch/debugging.clj</span><span class="ss">:73:23</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.load</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:7142</span><span class="p">)</span>
    <span class="nv">clojure.lang.RT.loadResourceScript</span> <span class="p">(</span><span class="nf">RT.java</span><span class="ss">:370</span><span class="p">)</span>
    <span class="nv">clojure.lang.RT.loadResourceScript</span> <span class="p">(</span><span class="nf">RT.java</span><span class="ss">:361</span><span class="p">)</span>
    <span class="nv">clojure.lang.RT.load</span> <span class="p">(</span><span class="nf">RT.java</span><span class="ss">:440</span><span class="p">)</span>
    <span class="nv">clojure.lang.RT.load</span> <span class="p">(</span><span class="nf">RT.java</span><span class="ss">:411</span><span class="p">)</span>
    <span class="nv">clojure.core/load/fn--5066</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5641</span><span class="p">)</span>
    <span class="nv">clojure.core/load</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5640</span><span class="p">)</span>
    <span class="nv">clojure.core/load-one</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5446</span><span class="p">)</span>
    <span class="nv">clojure.core/load-lib/fn--5015</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5486</span><span class="p">)</span>
    <span class="nv">clojure.core/load-lib</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5485</span><span class="p">)</span>
    <span class="nv">clojure.core/apply</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:626</span><span class="p">)</span>
    <span class="nv">clojure.core/load-libs</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:5524</span><span class="p">)</span>
<span class="nv">Caused</span> <span class="nv">by</span><span class="err">:</span>
<span class="nv">NullPointerException</span> 
    <span class="nv">clojure.lang.Numbers.ops</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:961</span><span class="p">)</span>
    <span class="nv">clojure.lang.Numbers.add</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:126</span><span class="p">)</span>
    <span class="nv">clojure.core/+</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:951</span><span class="p">)</span>
    <span class="nv">clojure.core.protocols/fn--6086</span> <span class="p">(</span><span class="nf">protocols.clj</span><span class="ss">:143</span><span class="p">)</span>
    <span class="nv">clojure.core.protocols/fn--6057/G--6052--6066</span> <span class="p">(</span><span class="nf">protocols.clj</span><span class="ss">:19</span><span class="p">)</span>
    <span class="nv">clojure.core.protocols/seq-reduce</span> <span class="p">(</span><span class="nf">protocols.clj</span><span class="ss">:27</span><span class="p">)</span>
    <span class="nv">clojure.core.protocols/fn--6078</span> <span class="p">(</span><span class="nf">protocols.clj</span><span class="ss">:53</span><span class="p">)</span>
    <span class="nv">clojure.core.protocols/fn--6031/G--6026--6044</span> <span class="p">(</span><span class="nf">protocols.clj</span><span class="ss">:13</span><span class="p">)</span>
    <span class="nv">clojure.core/reduce</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:6287</span><span class="p">)</span>
    <span class="nv">scratch.debugging/total-wood</span> <span class="p">(</span><span class="nf">debugging.clj</span><span class="ss">:69</span><span class="p">)</span>
    <span class="nv">scratch.debugging/eval1560</span> <span class="p">(</span><span class="nf">debugging.clj</span><span class="ss">:81</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.eval</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:6703</span><span class="p">)</span>
</code>
<p>On line 69, <code>total-wood</code> calls <code>reduce</code>, which dives through a series of functions from <code>clojure.core.protocols</code> before emerging in <code>+</code>: the function we passed to <code>reduce</code>. Reduce is trying to combine two elements from its collection of wood segments using <code>+</code>, but one of them was <code>nil</code>. Clojure calls this a <code>NullPointerException</code>. In <code>total-wood</code>, we constructed the sequence of segments this way:</p>
<code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">segments</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">photos</span>
                      <span class="c1">; Convert photos to frame dimensions</span>
                      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">))</span>
                      <span class="c1">; Convert frames to segments</span>
                      <span class="p">(</span><span class="nb">mapcat </span><span class="nv">perimeter</span><span class="p">))]</span>

    <span class="c1">; Now, take segments</span>
    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">segments</span>
         <span class="c1">; Add the spares</span>
         <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">spares</span> <span class="nv">segments</span><span class="p">))</span>
         <span class="c1">; Include a cut between each segment</span>
         <span class="p">(</span><span class="nf">interpose</span> <span class="nv">cut-size</span><span class="p">)</span>
         <span class="c1">; And sum the whole shebang.</span>
         <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))))</span>
</code>
<p>Where did the <code>nil</code> value come from? The stacktrace <em>doesn&rsquo;t say</em>, because the sequence <code>reduce</code> is traversing didn&rsquo;t have any problem <em>producing</em> the <code>nil</code>. <code>reduce</code> asked for a value and the sequence happily produced a <code>nil</code>. We only had a problem when it came time to <em>combine</em> the <code>nil</code> with the next value, using <code>+</code>.</p>

<p>A stacktrace like this is something like a murder mystery: we know the program died in the reducer, that it was shot with a <code>+</code>, and the bullet was a <code>nil</code>&ndash;but we don&rsquo;t know where the bullet came from. The trail runs cold. We need <em>more forensic information</em>&ndash;more hints about the <code>nil</code>&rsquo;s origin&ndash;to find the culprit.</p>

<p>Again, this is a class of error largely preventable with static type systems. If you have worked with a statically typed language in the past, it may be interesting to consider that almost every Clojure function takes <code>Option[A]</code> and does something more-or-less sensible, returning <code>Option[B]</code>. Whether the error propagates as a <code>nil</code> or an <code>Option</code>, there can be similar difficulties in localizing the cause of the problem.</p>

<p>Let&rsquo;s try printing out the state as <code>reduce</code> goes along:</p>
<code class="block">    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">segments</span>
         <span class="c1">; Add the spares</span>
         <span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nf">spares</span> <span class="nv">segments</span><span class="p">))</span>
         <span class="c1">; Include a cut between each segment</span>
         <span class="p">(</span><span class="nf">interpose</span> <span class="nv">cut-size</span><span class="p">)</span>
         <span class="c1">; And sum the whole shebang.</span>
         <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">acc</span> <span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">prn </span><span class="nv">acc</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">acc</span> <span class="nv">x</span><span class="p">))))))</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="mi">12</span> <span class="mi">1</span>
<span class="mi">13</span> <span class="mi">14</span>
<span class="mi">27</span> <span class="mi">1</span>
<span class="mi">28</span> <span class="nv">nil</span>

<span class="nv">CompilerException</span> <span class="nv">java.lang.NullPointerException</span>, <span class="nv">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">scratch/debugging.clj</span><span class="ss">:73:56</span><span class="p">)</span> 
</code>
<p>Not every value is nil! There&rsquo;s a <code>14</code> there which looks like a plausible segment for a frame, and two one-inch buffers from <code>cut-size</code>. We can rule out <code>interpose</code> because it inserts a <code>1</code> every time, and that <code>1</code> reduces correctly. But where&rsquo;s that <code>nil</code> coming from? Is from <code>segments</code> or <code>(spares segments)</code>?</p>
<code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">segments</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">photos</span>
                      <span class="c1">; Convert photos to frame dimensions</span>
                      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">))</span>
                      <span class="c1">; Convert frames to segments</span>
                      <span class="p">(</span><span class="nb">mapcat </span><span class="nv">perimeter</span><span class="p">))]</span>

    <span class="p">(</span><span class="nb">prn </span><span class="ss">:segments</span> <span class="nv">segments</span><span class="p">)</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="ss">:segments</span> <span class="p">(</span><span class="mi">12</span> <span class="mi">14</span> <span class="nv">nil</span> <span class="mi">14</span> <span class="mi">14</span> <span class="mi">12</span> <span class="nv">nil</span> <span class="mi">12</span> <span class="mi">24</span> <span class="mi">34</span> <span class="nv">nil</span> <span class="mi">34</span><span class="p">)</span>
</code>
<p>It is present in <code>segments</code>. Let&rsquo;s trace it backwards through the sequence&rsquo;s creation. It&rsquo;d be handy to have a function like <code>prn</code> that <em>returned</em> its input, so we could spy on values as they flowed through the <code>-&gt;&gt;</code> macro.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">spy</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply prn </span><span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">last </span><span class="nv">args</span><span class="p">))</span>
</code><code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">segments</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">photos</span>
                      <span class="c1">; Convert photos to frame dimensions</span>
                      <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">frame</span> <span class="nv">mat-width</span><span class="p">))</span>
                      <span class="p">(</span><span class="nf">spy</span> <span class="ss">:frames</span><span class="p">)</span>
                      <span class="c1">; Convert frames to segments</span>
                      <span class="p">(</span><span class="nb">mapcat </span><span class="nv">perimeter</span><span class="p">))]</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="ss">:frames</span> <span class="p">({</span><span class="ss">:x</span> <span class="mi">12</span>, <span class="ss">:y</span> <span class="mi">14</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">14</span>, <span class="ss">:y</span> <span class="mi">12</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">24</span>, <span class="ss">:y</span> <span class="mi">34</span><span class="p">})</span>
<span class="ss">:segments</span> <span class="p">(</span><span class="mi">12</span> <span class="mi">14</span> <span class="nv">nil</span> <span class="mi">14</span> <span class="mi">14</span> <span class="mi">12</span> <span class="nv">nil</span> <span class="mi">12</span> <span class="mi">24</span> <span class="mi">34</span> <span class="nv">nil</span> <span class="mi">34</span><span class="p">)</span>
</code>
<p>Ah! So the frames are intact, but the <em>perimeters</em> are bad. Let&rsquo;s check the <code>perimeter</code> function:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">perimeter</span>
  <span class="s">&quot;Given a rectangle, returns a vector of its edge lengths.&quot;</span>
  <span class="p">[</span><span class="nv">rect</span><span class="p">]</span>
  <span class="p">[(</span><span class="ss">:x</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:z</span> <span class="nv">rect</span><span class="p">)</span>
   <span class="p">(</span><span class="ss">:y</span> <span class="nv">rect</span><span class="p">)])</span>
</code>
<p>Spot the typo? We wrote <code>:z</code> instead of <code>:x</code>. Since the frame didn&rsquo;t have a <code>:z</code> field, it returned <code>nil</code>! That&rsquo;s the origin of our <code>NullPointerException</code>. With the bug fixed, we can re-run and find:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.debugging</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="nv">total</span> <span class="nv">inches</span><span class="err">:</span> <span class="mi">319</span>
</code>
<p>Whallah!</p>

<h2>Recap</h2>

<p>As we solve more and more problems, we get faster at debugging&ndash;at skipping over irrelevant log data, figuring out exactly what input was at fault, knowing what terms to search for, and developing a network of peers and mentors to ask for help. But when we encounter unexpected bugs, it can help to fall back on a family of problem-solving tactics.</p>

<p>We explore the problem thoroughly, localizing it to a particular function, variable, or set of inputs. We identify the boundaries of the problem, carving away parts of the system that work as expected. We develop new notation, maps, and diagrams of the problem space, precisely characterizing it in a variety of modes.</p>

<p>With the problem identified, we search for extant solutions&ndash;or related problems others have solved in the past. We trawl through issue trackers, mailing list posts, blogs, and forums like Stackoverflow, or, for more theoretical problems, academic papers, Mathworld, and Wikipedia, etc. If searching reveals nothing, we try rephrasing the problem, relaxing the constraints, adding debugging statements, and solving smaller subproblems. When all else fails, we ask for help from our peers, or from the community in IRC, mailing lists, and so on, or just take a break.</p>

<p>We learned to explore Clojure stacktraces as a trail into our programs, leading to the place where an error occurred. But not all paths are linear, and we saw how lazy operations and higher-order functions create inversions and intermediate layers in the stacktrace. Then we learned how to debug values that were <em>distant</em> from the trace, by adding logging statements and working our way closer to the origin.</p>

<p>Programming languages and us, their users, are engaged in a continual dialogue. We may speak more formally, verbosely, with many types and defensive assertions&ndash;or we may speak quickly, generally, in fuzzy terms. The more precise we are with the specifications of our program&rsquo;s types, the more the program can assist us when things go wrong. Conversely, those specifications <em>harden</em> our programs into strong but <em>rigid</em> forms, and rigid structures are harder to bend into new shapes.</p>

<p>In Clojure we strike a more dynamic balance: we speak in generalities, but we pay for that flexibility. Our errors are harder to trace to their origins. While the Clojure compiler can warn us of some errors, like mis-spelled variable names, it cannot (without a library like <a href="https://github.com/clojure/core.typed">core.typed</a>) tell us when we have incorrectly assumed an object will be of a certain type. Even very rigid languages, like Haskell, cannot identify some errors, like reversing the arguments to a subtraction function. <em>Some</em> tests are always necessary, though types are a huge boon.</p>

<p>No matter what language we write in, we use a balance of types and tests to <em>validate</em> our assumptions, both when the program is compiled and when it is run.</p>

<p>The errors that arise in compilation or runtime aren&rsquo;t <em>rebukes</em> so much as <em>hints</em>. Don&rsquo;t despair! They point the way towards understanding one&rsquo;s program in more detail&ndash;though the errors may be cryptic. Over time we get better at reading our language&rsquo;s errors and making our programs more robust.</p>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/318-clojure-from-the-ground-up-roadmap">Clojure from the ground up: roadmap</a></h1>
    </div>
    <div class="body">
      <p>With the language fundamentals in hand, here&rsquo;s my thinking for the remainder of the Clojure from the ground up book chapters. I&rsquo;m putting Jepsen on hold to work on this project for the rest of the year; hoping to get the source material complete by&hellip; January?</p>

<ul>
<li>Debugging and getting help</li>
<li>Polymorphism</li>
<li>Modularization and refactoring</li>
<li>It&rsquo;s not at all obvious what an object is</li>
<li>JVM interop</li>
<li>The Clojure type system</li>
<li>Compiler at runtime</li>
<li>Build your own language</li>
<li>Performance analysis</li>
<li>Parsers and protocols</li>
<li>Storage and persistence</li>
<li>Networks and messaging</li>
<li>Concurrency and queues</li>
</ul>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/312-clojure-from-the-ground-up-modeling">Clojure from the ground up: modeling</a></h1>
    </div>
    <div class="body">
      <p>Previously: <a href="http://aphyr.com/posts/311-clojure-from-the-ground-up-logistics">Logistics</a></p>

<p>Until this point in the book, we&rsquo;ve dealt primarily in specific details: what an expression is, how math works, which functions apply to different data structures, and where code lives. But programming, like speaking a language, painting landscapes, or designing turbines, is about more than the <em>nuts and bolts</em> of the trade. It&rsquo;s knowing how to <em>combine</em> those parts into a cohesive whole&ndash;and this is a skill which is difficult to describe formally. In this part of the book, I&rsquo;d like to work with you on an integrative tour of one particular problem: modeling a rocket in flight.</p>

<p>We&rsquo;re going to reinforce our concrete knowledge of the standard library by using maps, sequences, and math functions together. At the same time, we&rsquo;re going to practice how to represent a complex system; decomposing a problem into smaller parts, naming functions and variables, and writing tests.</p>

<h2>So you want to go to space</h2>

<p>First, we need a representation of a craft. The obvious properties for a rocket are its dry mass (how much it weighs without fuel), fuel mass, position, velocity, and time. We&rsquo;ll create a new file in our scratch project&ndash;<code>src/scratch/rocket.clj</code>&ndash;to talk about spacecraft.</p>

<p>For starters, let&rsquo;s pattern our craft after an <a href="http://en.wikipedia.org/wiki/Atlas_V">Atlas V</a> launch vehicle. We&rsquo;ll represent everything in SI units&ndash;kilograms, meters, newtons, etc. The Atlas V carries 627,105 lbs of LOX/RP-1 fuel, and a total mass of 334,500 kg gives only 50,050 kg of mass which <em>isn&rsquo;t</em> fuel. It develops 4152 kilonewtons of thrust and runs for 253 seconds, with a <a href="http://en.wikipedia.org/wiki/Specific_impulse">specific impulse</a> (effectively, exhaust velocity) of 3.05 kilometers/sec. Real rockets develop varying amounts of thrust depending on the atmosphere, but we&rsquo;ll pretend it&rsquo;s constant in our simulation.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">atlas-v</span>
 <span class="p">[]</span>
  <span class="p">{</span><span class="ss">:dry-mass</span>  <span class="mi">50050</span>
   <span class="ss">:fuel-mass</span> <span class="mi">284450</span>
   <span class="ss">:time</span> <span class="mi">0</span>
   <span class="ss">:isp</span> <span class="mi">3050</span>
   <span class="ss">:max-fuel-rate</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">284450</span> <span class="mi">253</span><span class="p">)</span>
   <span class="ss">:max-thrust</span> <span class="mf">4.152</span><span class="nv">e6</span><span class="p">})</span>
</code>
<p>How heavy is the craft?</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">mass</span>
  <span class="s">&quot;The total mass of a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="ss">:dry-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)))</span>
</code>
<p>What about the position and velocity? We could represent them in Cartesian coordinates&ndash;x, y, and z&ndash;or we could choose spherical coordinates: a radius from the planet and angle from the pole and 0 degrees longitude. I&rsquo;ve got a hunch that spherical coordinates will be easier for position, but accelerating the craft will be simplest in in x, y, and z terms. The center of the planet is a natural choice for the coordinate system&rsquo;s origin (0, 0, 0). We&rsquo;ll choose z along the north pole, and x and y in the plane of the equator.</p>

<p>Let&rsquo;s define a space center where we launch from&ndash;let&rsquo;s say it&rsquo;s initially on the equator at y=0. To figure out the x coordinate, we&rsquo;ll need to know how far the space center is from the center of the earth. The earth&rsquo;s <a href="http://en.wikipedia.org/wiki/Earth_radius#Equatorial_radius">equatorial radius</a> is ~6378 kilometers.</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">earth-equatorial-radius</span>
 <span class="s">&quot;Radius of the earth, in meters&quot;</span>
  <span class="mi">6378137</span><span class="p">)</span>
</code>
<p>How fast is the surface moving? Well the earth&rsquo;s day is 86,400 seconds long,</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">earth-day</span>
  <span class="s">&quot;Length of an earth day, in seconds.&quot;</span>
  <span class="mi">86400</span><span class="p">)</span>
</code>
<p>which means a given point on the equator has to go 2 * pi * equatorial radius meters in earth-day seconds:</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">earth-equatorial-speed</span>
  <span class="s">&quot;How fast points on the equator move, relative to the center of the earth,</span>
<span class="s">  in meters/sec.&quot;</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">Math/PI</span> <span class="nv">earth-equatorial-radius</span><span class="p">)</span>
     <span class="nv">earth-day</span><span class="p">))</span>
</code>
<p>So our space center is on the equator (z=0), at y=0 by choice, which means x is the equatorial radius. Since the earth is spinning, the space center is moving at earth-equatorial-speed in the y direction&ndash;and not changing at all in x or z.</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">initial-space-center</span>
  <span class="s">&quot;The initial position and velocity of the launch facility&quot;</span>
  <span class="p">{</span><span class="ss">:time</span>     <span class="mi">0</span>
   <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="nv">earth-equatorial-radius</span>
              <span class="ss">:y</span> <span class="mi">0</span>
              <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>
   <span class="ss">:velocity</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>
              <span class="ss">:y</span> <span class="nv">earth-equatorial-speed</span>
              <span class="ss">:z</span> <span class="mi">0</span><span class="p">}})</span>
</code>
<p><code>:position</code> and <code>:velocity</code> are both <a href="http://en.wikipedia.org/wiki/Euclidean_vector#Representations">vectors</a>, in the sense that they describe a position, or a direction, in terms of x, y, and z components. This is a <em>different</em> kind of vector than a Clojure vector, like <code>[1 2 3]</code>. We&rsquo;re actually representing these logical vectors as Clojure <em>maps</em>, with <code>:x</code>, <code>:y</code>, and <code>:z</code> keys, corresponding to the distance along the x, y, and z directions, from the center of the earth. Throughout this chapter, I&rsquo;ll mainly use the term <em>coordinates</em> to talk about these structures, to avoid confusion with Clojure vectors.</p>

<p>Now let&rsquo;s create a function which positions our craft on the launchpad at time 0. We&rsquo;ll just <em>merge</em> the spacecraft&rsquo;s with the initial space center, overwriting the craft&rsquo;s time and space coordinates.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">prepare</span>
  <span class="s">&quot;Prepares a craft for launch from an equatorial space center.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">merge </span><span class="nv">craft</span> <span class="nv">initial-space-center</span><span class="p">))</span>
</code>
<h2>Forces</h2>

<p>Gravity continually pulls the spacecraft towards the center of the Earth, accelerating it by 9.8 meters/second every second. To figure out what direction is towards the Earth, we&rsquo;ll need the angles of a <a href="http://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical coordinate system</a>. We&rsquo;ll use the trigonometric functions from <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html">java.lang.Math</a>.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">magnitude</span>
  <span class="s">&quot;What&#39;s the radius of a given set of cartesian coordinates?&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="c1">; By the Pythagorean theorem...</span>
  <span class="p">(</span><span class="nf">Math/sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">cartesian-&gt;spherical</span>
  <span class="s">&quot;Converts a map of Cartesian coordinates :x, :y, and :z to spherical coordinates :r, :theta, and :phi.&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">magnitude</span> <span class="nv">c</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:r</span> <span class="nv">r</span>
     <span class="ss">:theta</span> <span class="p">(</span><span class="nf">Math/acos</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">r</span><span class="p">))</span>
     <span class="ss">:phi</span>   <span class="p">(</span><span class="nf">Math/atan</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)))}))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">spherical-&gt;cartesian</span>
  <span class="s">&quot;Converts spherical to Cartesian coordinates.&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:theta</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))</span>
   <span class="ss">:y</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:theta</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))</span>
   <span class="ss">:z</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))})</span>
</code>
<p>With those angles in mind, computing the gravitational acceleration is easy. We just take the spherical coordinates of the spacecraft, and replace the radius with the total force due to gravity. Then we can transform that spherical force back into Cartesian coordinates.</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">g</span> <span class="s">&quot;Acceleration of gravity in meters/s^2&quot;</span> <span class="mf">-9.8</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">gravity-force</span>
  <span class="s">&quot;The force vector, each component in Newtons, due to gravity.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="c1">; Since force is mass times acceleration...</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">total-force</span> <span class="p">(</span><span class="nb">* </span><span class="nv">g</span> <span class="p">(</span><span class="nf">mass</span> <span class="nv">craft</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">craft</span>
        <span class="c1">; Now we&#39;ll take the craft&#39;s position</span>
        <span class="ss">:position</span>
        <span class="c1">; in spherical coordinates,</span>
        <span class="nv">cartesian-&gt;spherical</span>
        <span class="c1">; replace the radius with the gravitational force...</span>
        <span class="p">(</span><span class="nb">assoc </span><span class="ss">:r</span> <span class="nv">total-force</span><span class="p">)</span>
        <span class="c1">; and transform back to Cartesian-land</span>
        <span class="nv">spherical-&gt;cartesian</span><span class="p">)))</span>
</code>
<p>Rockets produce thrust by consuming fuel. Let&rsquo;s say the fuel consumption is always the maximum, until we run out:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">fuel-rate</span>
  <span class="s">&quot;How fast is fuel, in kilograms/second, consumed by the craft?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pos? </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:max-fuel-rate</span> <span class="nv">craft</span><span class="p">)</span>
    <span class="mi">0</span><span class="p">))</span>
</code>
<p>Now that we know how much fuel is being consumed, we can compute the force the rocket engine develops. That force is simply the mass consumed per second times the exhaust velocity&ndash;which is the specific impulse <code>:isp</code>. We&rsquo;ll ignore atmospheric effects.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">thrust</span>
  <span class="s">&quot;How much force, in newtons, does the craft&#39;s rocket engines exert?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">fuel-rate</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:isp</span> <span class="nv">craft</span><span class="p">)))</span>
</code>
<p>Cool. What about the direction of thrust? Just for grins, let&rsquo;s keep the rocket pointing entirely along the x axis.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">engine-force</span>
  <span class="s">&quot;The force vector, each component in Newtons, due to the rocket engine.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">t</span> <span class="p">(</span><span class="nf">thrust</span> <span class="nv">craft</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="nv">t</span>
     <span class="ss">:y</span> <span class="mi">0</span>
     <span class="ss">:z</span> <span class="mi">0</span><span class="p">}))</span>
</code>
<p>The total force on a craft is just the sum of gravity and thrust. To sum these maps together, we&rsquo;ll need a way to sum the x, y, and z components independently. Clojure&rsquo;s <code>merge-with</code> function combines common fields in maps using a function, so this is surprisingly straightforward.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">total-force</span>
  <span class="s">&quot;Total force on a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="nf">engine-force</span> <span class="nv">craft</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">gravity-force</span> <span class="nv">craft</span><span class="p">)))</span>
</code>
<p>The acceleration of a craft, by <a href="http://www.physicsclassroom.com/class/newtlaws/u2l3a.cfm">Newton&rsquo;s second law</a>, is force divided by mass. This one&rsquo;s a little trickier; given <code>{:x 1 :y 2 :z 4}</code> we want to apply a function&ndash;say, multiplication by a factor, to each number. Since maps are sequences of key/value pairs&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span> <span class="ss">:z</span> <span class="mi">3</span><span class="p">})</span>
<span class="p">([</span><span class="ss">:z</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="ss">:y</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="ss">:x</span> <span class="mi">1</span><span class="p">])</span>
</code>
<p>&hellip; and we can build up new maps out of key/value pairs using <code>into</code>&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">into </span><span class="p">{}</span> <span class="p">[[</span><span class="ss">:x</span> <span class="mi">4</span><span class="p">]</span> <span class="p">[</span><span class="ss">:y</span> <span class="mi">5</span><span class="p">]])</span>
<span class="p">{</span><span class="ss">:x</span> <span class="mi">4</span>, <span class="ss">:y</span> <span class="mi">5</span><span class="p">}</span>
</code>
<p>&hellip; we can write a function <code>map-values</code> which works like <code>map</code>, but affects the values of a map data structure.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">map-values</span>
  <span class="s">&quot;Applies f to every value in the map m.&quot;</span>
  <span class="p">[</span><span class="nv">f</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">into </span><span class="p">{}</span>
        <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pair</span><span class="p">]</span>
               <span class="p">[(</span><span class="nb">key </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">val </span><span class="nv">pair</span><span class="p">))])</span>
             <span class="nv">m</span><span class="p">)))</span>
</code>
<p>And that allows us to define a <code>scale</code> function which <em>scales</em> a set of coordinates by some factor:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">scale</span>
  <span class="s">&quot;Multiplies a map of x, y, and z coordinates by the given factor.&quot;</span>
  <span class="p">[</span><span class="nv">factor</span> <span class="nv">coordinates</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">map-values</span> <span class="p">(</span><span class="nb">partial * </span><span class="nv">factor</span><span class="p">)</span> <span class="nv">coordinates</span><span class="p">))</span>
</code>
<p>What&rsquo;s that <code>partial</code> thing? It&rsquo;s a function which <em>takes a function</em>, and some arguments, and <em>returns a new function</em>. What does the new function do? It calls the original function, with the arguments passed to <code>partial</code>, followed by any arguments passed to the new function. In short, <code>(partial * factor)</code> returns a function that takes any number, and multiplies it by <code>factor</code>.</p>

<p>So to divide each component of the force vector by the mass of the craft:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">acceleration</span>
  <span class="s">&quot;Total acceleration of a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nf">mass</span> <span class="nv">craft</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">total-force</span> <span class="nv">craft</span><span class="p">))))</span>
</code>
<p>Note that <code>(/ m)</code> returns 1/m. Our scale function can do double-duty as both multiplication and division.</p>

<p>With the acceleration and fuel consumption all figured out, we&rsquo;re ready to <em>apply those changes over time</em>. We&rsquo;ll write a function which takes the rocket at a particular time, and returns a version of it <code>dt</code> seconds later. </p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">step</span>
  <span class="p">[</span><span class="nv">craft</span> <span class="nv">dt</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">assoc </span><span class="nv">craft</span>
         <span class="c1">; Time advances by dt seconds</span>
         <span class="ss">:t</span>         <span class="p">(</span><span class="nb">+ </span><span class="nv">dt</span> <span class="p">(</span><span class="ss">:t</span> <span class="nv">craft</span><span class="p">))</span>
         <span class="c1">; We burn some fuel</span>
         <span class="ss">:fuel-mass</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">dt</span> <span class="p">(</span><span class="nf">fuel-rate</span> <span class="nv">craft</span><span class="p">)))</span>
         <span class="c1">; Our position changes based on our velocity</span>
         <span class="ss">:position</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)))</span>
         <span class="c1">; And our velocity changes based on our acceleration</span>
         <span class="ss">:velocity</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="nf">acceleration</span> <span class="nv">craft</span><span class="p">)))))</span>
</code>
<p>OK. Let&rsquo;s save the <code>rocket.clj</code> file, load that code into the REPL, and fire it up.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.rocket</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="nv">nil</span>
</code>
<p><code>use</code> is like a shorthand for <code>(:require ... :refer :all)</code>. We&rsquo;re passing <code>:reload</code> because we want the REPL to re-read the file. Notice that in <code>ns</code> declarations, the namespace name <code>scratch.rocket</code> is <em>unquoted</em>&ndash;but when we call <code>use</code> or <code>require</code> at the repl, we quote the namespace name.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:dry-mass</span> <span class="mi">50050</span>, <span class="ss">:fuel-mass</span> <span class="mi">284450</span>, <span class="ss">:time</span> <span class="mi">0</span>, <span class="ss">:isp</span> <span class="mi">3050</span>, <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>, <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
</code>
<h2>Launch</h2>

<p>Let&rsquo;s prepare the rocket. We&rsquo;ll use <code>pprint</code> to print it in a more readable form.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:velocity</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
 <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">6378137</span>, <span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
 <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
 <span class="ss">:fuel-mass</span> <span class="mi">284450</span>,
 <span class="ss">:time</span> <span class="mi">0</span>,
 <span class="ss">:isp</span> <span class="mi">3050</span>,
 <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
 <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
</code>
<p>Great; there it is on the launchpad. Wow, even &ldquo;standing still&rdquo;, it&rsquo;s moving at 463 meters/sec because of the earth&rsquo;s rotation! That means <em>you and I</em> are flying through space at almost half a kilometer every second! Let&rsquo;s step forward one second in time.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="p">(</span><span class="nf">step</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>

<span class="nv">NullPointerException</span>   <span class="nv">clojure.lang.Numbers.ops</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:942</span><span class="p">)</span>
</code>
<p>In evaluating this expression, Clojure reached a point where it could not continue, and aborted execution. We call this error an <em>exception</em>, and the process of aborting <em>throwing</em> the exception. Clojure backs up to the function which <em>called</em> the function that threw, then the function which called <em>that</em> function, and so on, all the way to the top-level expression. The REPL finally intercepts the exception, prints an error to the console, and stashes the exception object in a special variable <code>*e</code>.</p>

<p>In this case, we know that the exception in question was a <code>NullPointerException</code>, which occurs when a function received <code>nil</code> unexpectedly. This one came from <code>clojure.lang.Numbers.ops</code>, which suggests some sort of math was involved. Let&rsquo;s use <code>pst</code> to find out where it came from.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pst</span> <span class="nv">*e</span><span class="p">)</span>
<span class="nv">NullPointerException</span> 
    <span class="nv">clojure.lang.Numbers.ops</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:942</span><span class="p">)</span>
    <span class="nv">clojure.lang.Numbers.add</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:126</span><span class="p">)</span>
    <span class="nv">scratch.rocket/step</span> <span class="p">(</span><span class="nf">rocket.clj</span><span class="ss">:125</span><span class="p">)</span>
    <span class="nv">user/eval1478</span> <span class="p">(</span><span class="nf">NO_SOURCE_FILE</span><span class="ss">:1</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.eval</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:6619</span><span class="p">)</span>
    <span class="nv">clojure.lang.Compiler.eval</span> <span class="p">(</span><span class="nf">Compiler.java</span><span class="ss">:6582</span><span class="p">)</span>
    <span class="nv">clojure.core/eval</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:2852</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/read-eval-print--6588/fn--6591</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:259</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/read-eval-print--6588</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:259</span><span class="p">)</span>
    <span class="nv">clojure.main/repl/fn--6597</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:277</span><span class="p">)</span>
    <span class="nv">clojure.main/repl</span> <span class="p">(</span><span class="nf">main.clj</span><span class="ss">:277</span><span class="p">)</span>
    <span class="nv">clojure.tools.nrepl.middleware.interruptible-eval/evaluate/fn--589</span> <span class="p">(</span><span class="nf">interruptible_eval.clj</span><span class="ss">:56</span><span class="p">)</span>
</code>
<p>This is called a <em>stack trace</em>: the <em>stack</em> is the context of the program at each function call. It traces the path the computer took in evaluating the expression, from the bottom to the top. At the bottom is the REPL, and Clojure compiler. Our code begins at <code>user/eval1478</code>&ndash;that&rsquo;s the compiler&rsquo;s name for the expression we just typed. That function called <code>scratch.rocket/step</code>, which in turn called <code>Numbers.add</code>, and that called  <code>Numbers.ops</code>. Let&rsquo;s start by looking at the last function <em>we</em> wrote before calling into Clojure&rsquo;s standard library: the <code>step</code> function, in <code>rocket.clj</code>, on line <code>125</code>.</p>
<code class="block"><span class="mi">123</span>  <span class="p">(</span><span class="nb">assoc </span><span class="nv">craft</span>
<span class="mi">124</span>         <span class="c1">; Time advances by dt seconds</span>
<span class="mi">125</span>         <span class="ss">:t</span>         <span class="p">(</span><span class="nb">+ </span><span class="nv">dt</span> <span class="p">(</span><span class="ss">:t</span> <span class="nv">craft</span><span class="p">))</span>
</code>
<p>Ah; we named the time field <code>:time</code> earlier, not <code>:t</code>. Let&rsquo;s replace <code>:t</code> with <code>:time</code>, save the file, and reload.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.rocket</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="p">(</span><span class="nf">step</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:velocity</span> <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.45154055666826215</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mf">-9.8</span><span class="p">}</span>,
 <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">6378137</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
 <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
 <span class="ss">:fuel-mass</span> <span class="mi">71681400</span><span class="nv">/253</span>,
 <span class="ss">:time</span> <span class="mi">1</span>,
 <span class="ss">:isp</span> <span class="mi">3050</span>,
 <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
 <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
</code>
<p>Look at that! Our position is unchanged (because our velocity was zero), but our <em>velocity</em> has shifted. We&rsquo;re now moving&hellip; wait, -9.8 meters per second <em>south</em>? That can&rsquo;t be right. Gravity points <em>down</em>, not sideways. Something must be wrong with our spherical coordinate system. Let&rsquo;s write a test in <code>test/scratch/rocket_test.clj</code> to explore.</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.rocket-test</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.test</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">scratch.rocket</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">deftest</span> <span class="nv">spherical-coordinate-test</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pos</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span> <span class="ss">:z</span> <span class="mi">3</span><span class="p">}]</span>
    <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;roundtrip&quot;</span>
      <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">pos</span> <span class="nv">cartesian-&gt;spherical</span> <span class="nv">spherical-&gt;cartesian</span><span class="p">))))))</span>
</code><code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test

lein test scratch.core-test

lein test scratch.rocket-test

lein test :only scratch.rocket-test&#x2F;spherical-coordinate-test

FAIL in (spherical-coordinate-test) (rocket_test.clj:8)
roundtrip
expected: (= pos (-&gt; pos cartesian-&gt;spherical spherical-&gt;cartesian))
  actual: (not (= {:z 3, :y 2, :x 1} {:x 1.0, :y 1.9999999999999996, :z 1.6733200530681513}))

Ran 2 tests containing 4 assertions.
1 failures, 0 errors.
Tests failed.</code>
<p>Definitely wrong. Looks like something to do with the z coordinate, since x and y look OK. Let&rsquo;s try testing a point on the north pole:</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">spherical-coordinate-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;spherical-&gt;cartesian&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">spherical-&gt;cartesian</span> <span class="p">{</span><span class="ss">:r</span> <span class="mi">2</span>
                                  <span class="ss">:phi</span> <span class="mi">0</span>
                                  <span class="ss">:theta</span> <span class="mi">0</span><span class="p">})</span>
           <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.0</span> <span class="ss">:y</span> <span class="mf">0.0</span> <span class="ss">:z</span> <span class="mf">2.0</span><span class="p">})))</span>

  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;roundtrip&quot;</span>
    <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">pos</span> <span class="p">{</span><span class="ss">:x</span> <span class="mf">1.0</span> <span class="ss">:y</span> <span class="mf">2.0</span> <span class="ss">:z</span> <span class="mf">3.0</span><span class="p">}]</span>
      <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="nv">pos</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">pos</span> <span class="nv">cartesian-&gt;spherical</span> <span class="nv">spherical-&gt;cartesian</span><span class="p">))))))</span>
</code>
<p>That checks out OK. Let&rsquo;s try some values in the repl.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cartesian-&gt;spherical</span> <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.00001</span> <span class="ss">:y</span> <span class="mf">0.00001</span> <span class="ss">:z</span> <span class="mf">2.0</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:r</span> <span class="mf">2.00000000005</span>, <span class="ss">:theta</span> <span class="mf">7.071068104411588</span><span class="nv">E-6</span>, <span class="ss">:phi</span> <span class="mf">0.7853981633974483</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cartesian-&gt;spherical</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span> <span class="ss">:z</span> <span class="mi">3</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:r</span> <span class="mf">3.7416573867739413</span>, <span class="ss">:theta</span> <span class="mf">0.6405223126794245</span>, <span class="ss">:phi</span> <span class="mf">1.1071487177940904</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">spherical-&gt;cartesian</span> <span class="p">(</span><span class="nf">cartesian-&gt;spherical</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span> <span class="ss">:z</span> <span class="mi">3</span><span class="p">}))</span>
<span class="p">{</span><span class="ss">:x</span> <span class="mf">1.0</span>, <span class="ss">:y</span> <span class="mf">1.9999999999999996</span>, <span class="ss">:z</span> <span class="mf">1.6733200530681513</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cartesian-&gt;spherical</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">2</span> <span class="ss">:z</span> <span class="mi">0</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:r</span> <span class="mf">2.23606797749979</span>, <span class="ss">:theta</span> <span class="mf">1.5707963267948966</span>, <span class="ss">:phi</span> <span class="mf">1.1071487177940904</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cartesian-&gt;spherical</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">1</span> <span class="ss">:z</span> <span class="mi">0</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:r</span> <span class="mf">1.4142135623730951</span>, <span class="ss">:theta</span> <span class="mf">1.5707963267948966</span>, <span class="ss">:phi</span> <span class="mf">0.7853981633974483</span><span class="p">}</span>
</code>
<p>Oh, wait, that looks odd. <code>{:x 1 :y 1 :z 0}</code> is on the equator: phi&ndash;the angle from the pole&ndash;should be pi/2 or ~1.57, and theta&ndash;the angle around the equator&ndash;should be pi/4 or 0.78. Those coordinates are reversed! Double-checking our formulas with <a href="http://mathworld.wolfram.com/SphericalCoordinates.html">Wolfram MathWorld</a> shows that we mixed up phi and theta! Let&rsquo;s redefine <code>cartesian-&gt;polar</code> correctly.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">cartesian-&gt;spherical</span>
  <span class="s">&quot;Converts a map of Cartesian coordinates :x, :y, and :z to spherical</span>
<span class="s">  coordinates :r, :theta, and :phi.&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">Math/sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))]</span>
    <span class="p">{</span><span class="ss">:r</span>     <span class="nv">r</span>
     <span class="ss">:phi</span>   <span class="p">(</span><span class="nf">Math/acos</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">r</span><span class="p">))</span>
     <span class="ss">:theta</span> <span class="p">(</span><span class="nf">Math/atan</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)))}))</span>
</code><code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test

lein test scratch.core-test

lein test scratch.rocket-test

Ran 2 tests containing 5 assertions.
0 failures, 0 errors.</code>
<p>Great. Now let&rsquo;s check the rocket trajectory again.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="p">(</span><span class="nf">step</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:velocity</span>
 <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.45154055666826204</span>,
  <span class="ss">:y</span> <span class="mf">463.8312116386399</span>,
  <span class="ss">:z</span> <span class="mf">-6.000769315822031</span><span class="nv">E-16</span><span class="p">}</span>,
 <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">6378137</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
 <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
 <span class="ss">:fuel-mass</span> <span class="mi">71681400</span><span class="nv">/253</span>,
 <span class="ss">:time</span> <span class="mi">1</span>,
 <span class="ss">:isp</span> <span class="mi">3050</span>,
 <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
 <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
</code>
<p>This time, our velocity is increasing in the +x direction, at half a meter per second. We have liftoff!</p>

<h2>Flight</h2>

<p>We have a function that can move the rocket forward by one small step of time, but we&rsquo;d like to understand the rocket&rsquo;s trajectory as a <em>whole</em>; to see <em>all</em> positions it will take. We&rsquo;ll use <em>iterate</em> to construct a lazy, infinite sequence of rocket states, each one constructed by stepping forward from the last.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">trajectory</span>
  <span class="p">[</span><span class="nv">dt</span> <span class="nv">craft</span><span class="p">]</span>
  <span class="s">&quot;Returns all future states of the craft, at dt-second intervals.&quot;</span>
  <span class="p">(</span><span class="nb">iterate </span><span class="o">#</span><span class="p">(</span><span class="nf">step</span> <span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">craft</span><span class="p">))</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="p">(</span><span class="nf">trajectory</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">({</span><span class="ss">:velocity</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
  <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">6378137</span>, <span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
  <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
  <span class="ss">:fuel-mass</span> <span class="mi">284450</span>,
  <span class="ss">:time</span> <span class="mi">0</span>,
  <span class="ss">:isp</span> <span class="mi">3050</span>,
  <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
  <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:velocity</span>
  <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.45154055666826204</span>,
   <span class="ss">:y</span> <span class="mf">463.8312116386399</span>,
   <span class="ss">:z</span> <span class="mf">-6.000769315822031</span><span class="nv">E-16</span><span class="p">}</span>,
  <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">6378137</span>, <span class="ss">:y</span> <span class="mf">463.8312116386399</span>, <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>,
  <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
  <span class="ss">:fuel-mass</span> <span class="mi">71681400</span><span class="nv">/253</span>,
  <span class="ss">:time</span> <span class="mi">1</span>,
  <span class="ss">:isp</span> <span class="mi">3050</span>,
  <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
  <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:velocity</span>
  <span class="p">{</span><span class="ss">:x</span> <span class="mf">0.9376544222659078</span>,
   <span class="ss">:y</span> <span class="mf">463.83049896253056</span>,
   <span class="ss">:z</span> <span class="mf">-1.200153863164406</span><span class="nv">E-15</span><span class="p">}</span>,
  <span class="ss">:position</span>
  <span class="p">{</span><span class="ss">:x</span> <span class="mf">6378137.451540557</span>,
   <span class="ss">:y</span> <span class="mf">927.6624232772798</span>,
   <span class="ss">:z</span> <span class="mf">-6.000769315822031</span><span class="nv">E-16</span><span class="p">}</span>,
  <span class="ss">:dry-mass</span> <span class="mi">50050</span>,
  <span class="ss">:fuel-mass</span> <span class="mi">71396950</span><span class="nv">/253</span>,
  <span class="ss">:time</span> <span class="mi">2</span>,
  <span class="ss">:isp</span> <span class="mi">3050</span>,
  <span class="ss">:max-fuel-rate</span> <span class="mi">284450</span><span class="nv">/253</span>,
  <span class="ss">:max-thrust</span> <span class="mf">4152000.0</span><span class="p">})</span>
</code>
<p>Notice that each map is like a frame of a movie, playing at one frame per second. We can make the simulation more or less accurate by raising or lowering the framerate&ndash;adjusting the parameter fed to <code>trajectory</code>. For now, though, we&rsquo;ll stick with one-second intervals.</p>

<p>How high above the surface is the rocket?</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">altitude</span>
  <span class="s">&quot;The height above the surface of the equator, in meters.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">craft</span>
      <span class="ss">:position</span>
      <span class="nv">cartesian-&gt;spherical</span>
      <span class="ss">:r</span>
      <span class="p">(</span><span class="nb">- </span><span class="nv">earth-equatorial-radius</span><span class="p">)))</span>
</code>
<p>Now we can explore the rocket&rsquo;s path as a series of altitudes over time:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span> <span class="nv">prepare</span> <span class="p">(</span><span class="nf">trajectory</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="nv">altitude</span><span class="p">)</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">(</span><span class="mf">0.0</span>
 <span class="mf">0.016865378245711327</span>
 <span class="mf">0.519002066925168</span>
 <span class="mf">1.540983198210597</span>
 <span class="mf">3.117615718394518</span>
 <span class="mf">5.283942770212889</span>
 <span class="mf">8.075246102176607</span>
 <span class="mf">11.52704851794988</span>
 <span class="mf">15.675116359256208</span>
 <span class="mf">20.555462017655373</span><span class="p">)</span>
</code>
<p>The million dollar question, though, is whether the rocket breaks orbit.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">above-ground?</span>
  <span class="s">&quot;Is the craft at or above the surface?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">altitude</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">flight</span>
  <span class="s">&quot;The above-ground portion of a trajectory.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">take-while </span><span class="nv">above-ground?</span> <span class="nv">trajectory</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">crashed?</span>
  <span class="s">&quot;Does this trajectory crash into the surface before 100 hours are up?&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">time-limit</span> <span class="p">(</span><span class="nb">* </span><span class="mi">100</span> <span class="mi">3600</span><span class="p">)]</span> <span class="c1">; 1 hour</span>
    <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">every? </span><span class="nv">above-ground?</span>
                 <span class="p">(</span><span class="nb">take-while </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:time</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">time-limit</span><span class="p">)</span> <span class="nv">trajectory</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">crash-time</span>
  <span class="s">&quot;Given a trajectory, returns the time the rocket impacted the ground.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="ss">:time</span> <span class="p">(</span><span class="nb">last </span><span class="p">(</span><span class="nf">flight</span> <span class="nv">trajectory</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">apoapsis</span>
  <span class="s">&quot;The highest altitude achieved during a trajectory.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply max </span><span class="p">(</span><span class="nb">map </span><span class="nv">altitude</span> <span class="nv">trajectory</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">apoapsis-time</span>
  <span class="s">&quot;The time of apoapsis&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="ss">:time</span> <span class="p">(</span><span class="nb">apply max-key </span><span class="nv">altitude</span> <span class="p">(</span><span class="nf">flight</span> <span class="nv">trajectory</span><span class="p">))))</span>
</code>
<p>If the rocket goes below ground, we know it crashed. If the rocket stays in orbit, the trajectory will never end. That makes it a bit tricky to tell whether the rocket is in a stable orbit or not, because we can&rsquo;t ask about every element, or the last element, of an infinite sequence: it&rsquo;ll take infinite time to evaluate. Instead, we&rsquo;ll assume that the rocket <em>should</em> crash within the first, say, 100 hours; if it makes it past that point, we&rsquo;ll assume it made orbit successfully. With these functions in hand, we&rsquo;ll write a test in <code>test/scratch/rocket_test.clj</code> to see whether or not the launch is successful:</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">makes-orbit</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">trajectory</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">atlas-v</span><span class="p">)</span>
                        <span class="nv">prepare</span>
                        <span class="p">(</span><span class="nf">trajectory</span> <span class="mi">1</span><span class="p">))]</span>

    <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">crashed?</span> <span class="nv">trajectory</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Crashed at&quot;</span> <span class="p">(</span><span class="nf">crash-time</span> <span class="nv">trajectory</span><span class="p">)</span> <span class="s">&quot;seconds&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Maximum altitude&quot;</span> <span class="p">(</span><span class="nf">apoapsis</span> <span class="nv">trajectory</span><span class="p">)</span>
               <span class="s">&quot;meters at&quot;</span>        <span class="p">(</span><span class="nf">apoapsis-time</span> <span class="nv">trajectory</span><span class="p">)</span> <span class="s">&quot;seconds&quot;</span><span class="p">))</span>

    <span class="c1">; Assert that the rocket eventually made it to orbit.</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">crashed?</span> <span class="nv">trajectory</span><span class="p">)))))</span>
</code><code class="block"><span class="nv">aphyr</span><span class="o">@</span><span class="nv">waterhouse</span><span class="err">:</span><span class="o">~</span><span class="nv">/scratch$</span> <span class="nv">lein</span> <span class="nb">test </span><span class="nv">scratch.rocket-test</span>

<span class="nv">lein</span> <span class="nb">test </span><span class="nv">scratch.rocket-test</span>
<span class="nv">Crashed</span> <span class="nv">at</span> <span class="mi">982</span> <span class="nv">seconds</span>
<span class="nv">Maximum</span> <span class="nv">altitude</span> <span class="mf">753838.039645385</span> <span class="nv">meters</span> <span class="nv">at</span> <span class="mi">532</span> <span class="nv">seconds</span>

<span class="nv">lein</span> <span class="nb">test </span><span class="ss">:only</span> <span class="nv">scratch.rocket-test/makes-orbit</span>

<span class="nv">FAIL</span> <span class="nv">in</span> <span class="p">(</span><span class="nf">makes-orbit</span><span class="p">)</span> <span class="p">(</span><span class="nf">rocket_test.clj</span><span class="ss">:26</span><span class="p">)</span>
<span class="nv">expected</span><span class="err">:</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nf">crashed?</span> <span class="nv">trajectory</span><span class="p">))</span>
  <span class="nv">actual</span><span class="err">:</span> <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">not </span><span class="nv">true</span><span class="p">))</span>

<span class="nv">Ran</span> <span class="mi">2</span> <span class="nv">tests</span> <span class="nv">containing</span> <span class="mi">3</span> <span class="nv">assertions.</span>
<span class="mi">1</span> <span class="nv">failures</span>, <span class="mi">0</span> <span class="nv">errors.</span>
<span class="nv">Tests</span> <span class="nv">failed.</span>
</code>
<p>We made it to an altitude of 750 kilometers, and crashed 982 seconds after launch. We&rsquo;re gonna need a bigger boat.</p>

<h2>Stage II</h2>

<p>The Atlas V isn&rsquo;t big enough to make it into orbit on its own. It carries a second stage, the <a href="http://en.wikipedia.org/wiki/Centaur_(rocket_stage">Centaur</a>), which is much smaller and uses <a href="http://www.astronautix.com/stages/cenaurde.htm">more efficient engines</a>.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">centaur</span>
  <span class="s">&quot;The upper rocket stage.</span>
<span class="s">  http://en.wikipedia.org/wiki/Centaur_(rocket_stage)</span>
<span class="s">  http://www.astronautix.com/stages/cenaurde.htm&quot;</span>
  <span class="p">[]</span>
  <span class="p">{</span><span class="ss">:dry-mass</span>  <span class="mi">2361</span>
   <span class="ss">:fuel-mass</span> <span class="mi">13897</span>
   <span class="ss">:isp</span>       <span class="mi">4354</span>
   <span class="ss">:max-fuel-rate</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">13897</span> <span class="mi">470</span><span class="p">)})</span>
</code>
<p>The Centaur lives inside the Atlas V main stage. We&rsquo;ll re-write <code>atlas-v</code> to take an <em>argument</em>: its next stage.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">atlas-v</span>
  <span class="s">&quot;The full launch vehicle. http://en.wikipedia.org/wiki/Atlas_V&quot;</span>
  <span class="p">[</span><span class="nv">next-stage</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:dry-mass</span>  <span class="mi">50050</span>
   <span class="ss">:fuel-mass</span> <span class="mi">284450</span>
   <span class="ss">:isp</span> <span class="mi">3050</span>
   <span class="ss">:max-fuel-rate</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">284450</span> <span class="mi">253</span><span class="p">)</span>
   <span class="ss">:next-stage</span> <span class="nv">next-stage</span><span class="p">})</span>
</code>
<p>Now, in our tests, we&rsquo;ll construct the rocket like so:</p>
<code class="block">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">trajectory</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">atlas-v</span> <span class="p">(</span><span class="nf">centaur</span><span class="p">))</span>
                        <span class="nv">prepare</span>
                        <span class="p">(</span><span class="nf">trajectory</span> <span class="mi">1</span><span class="p">))]</span>
</code>
<p>When we exhaust the fuel reserves of the primary stage, we&rsquo;ll de-couple the main booster from the Centaur. In terms of our simulation, the Atlas V will be <em>replaced</em> by its next stage, the Centaur. We&rsquo;ll write a function <code>stage</code> which separates the vehicles when ready:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">stage</span>
  <span class="s">&quot;When fuel reserves are exhausted, separate stages. Otherwise, return craft</span>
<span class="s">  unchanged.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Still fuel left</span>
    <span class="p">(</span><span class="nb">pos? </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">))</span>
    <span class="nv">craft</span>

    <span class="c1">; No remaining stages</span>
    <span class="p">(</span><span class="nb">nil? </span><span class="p">(</span><span class="ss">:next-stage</span> <span class="nv">craft</span><span class="p">))</span>
    <span class="nv">craft</span>

    <span class="c1">; Stage!</span>
    <span class="ss">:else</span>
    <span class="p">(</span><span class="nb">merge </span><span class="p">(</span><span class="ss">:next-stage</span> <span class="nv">craft</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">select-keys </span><span class="nv">craft</span> <span class="p">[</span><span class="ss">:time</span> <span class="ss">:position</span> <span class="ss">:velocity</span><span class="p">]))))</span>
</code>
<p>We&rsquo;re using <code>cond</code> to handle three distinct cases: where there&rsquo;s fuel remaining in the craft, where there is no stage to separate, and when we&rsquo;re ready for stage separation. Separation is easy: we simply return the next stage of the current craft, with the current craft&rsquo;s time, position, and velocity merged in.</p>

<p>Finally, we&rsquo;ll have to update our <code>step</code> function to take into account the possibility of stage separation.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">step</span>
  <span class="p">[</span><span class="nv">craft</span> <span class="nv">dt</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">craft</span> <span class="p">(</span><span class="nf">stage</span> <span class="nv">craft</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">assoc </span><span class="nv">craft</span>
           <span class="c1">; Time advances by dt seconds</span>
           <span class="ss">:time</span>      <span class="p">(</span><span class="nb">+ </span><span class="nv">dt</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">))</span>
           <span class="c1">; We burn some fuel</span>
           <span class="ss">:fuel-mass</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">dt</span> <span class="p">(</span><span class="nf">fuel-rate</span> <span class="nv">craft</span><span class="p">)))</span>
           <span class="c1">; Our position changes based on our velocity</span>
           <span class="ss">:position</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)))</span>
           <span class="c1">; And our velocity changes based on our acceleration</span>
           <span class="ss">:velocity</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="nf">acceleration</span> <span class="nv">craft</span><span class="p">))))))</span>
</code>
<p>Same as before, only now we call <code>stage</code> prior to the physics simulation. Let&rsquo;s try a launch.</p>
<code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test scratch.rocket-test

lein test scratch.rocket-test
Crashed at 2415 seconds
Maximum altitude 4598444.289945109 meters at 1446 seconds

lein test :only scratch.rocket-test&#x2F;makes-orbit

FAIL in (makes-orbit) (rocket_test.clj:27)
expected: (not (crashed? trajectory))
  actual: (not (not true))

Ran 2 tests containing 3 assertions.
1 failures, 0 errors.
Tests failed.</code>
<p>Still crashed&ndash;but we increased our apoapsis from 750 kilometers to 4,598 kilometers. That&rsquo;s plenty high, but we&rsquo;re still not making orbit. Why? Because we&rsquo;re going straight up, then straight back down. To orbit, we need to move <em>sideways</em>, around the earth.</p>

<h2>Orbital insertion</h2>

<p>Our spacecraft is shooting upwards, but in order to remain in orbit around the earth, it has to execute a <em>second</em> burn: an orbital injection maneuver. That injection maneuver is also called a <em>circularization burn</em> because it turns the orbit from an ascending parabola into a circle (or something roughly like it). We don&rsquo;t need to be precise about circularization&ndash;any trajectory that doesn&rsquo;t hit the planet will suffice. All we have to do is burn towards the horizon, once we get high enough.</p>

<p>To do that, we&rsquo;ll need to enhance the rocket&rsquo;s control software. We assumed that the rocket would always thrust in the +x direction; but now we&rsquo;ll need to thrust in multiple directions. We&rsquo;ll break up the engine force into two parts: <code>thrust</code> (how hard the rocket motor pushes) and <code>orientation</code> (which determines the direction the rocket is pointing.)</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">unit-vector</span>
  <span class="s">&quot;Scales coordinates to magnitude 1.&quot;</span>
  <span class="p">[</span><span class="nv">coordinates</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">magnitude</span> <span class="nv">coordinates</span><span class="p">))</span> <span class="nv">coordinates</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">engine-force</span>
  <span class="s">&quot;The force vector, each component in Newtons, due to the rocket engine.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nf">thrust</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nf">unit-vector</span> <span class="p">(</span><span class="nf">orientation</span> <span class="nv">craft</span><span class="p">))))</span>
</code>
<p>We&rsquo;re taking the orientation of the craft&ndash;some coordinates&ndash;and scaling it to be of length one with <code>unit-vector</code>. Then we&rsquo;re scaling the orientation vector by the thrust, returning a <em>thrust vector</em>.</p>

<p>As we go back and redefine parts of the program, you might see an error like</p>
<code class="block">Exception in thread &quot;main&quot; java.lang.RuntimeException: Unable to resolve symbol: unit-vector in this context, compiling:(scratch&#x2F;rocket.clj:69:11)
    at clojure.lang.Compiler.analyze(Compiler.java:6380)
    at clojure.lang.Compiler.analyze(Compiler.java:6322)</code>
<p>This is a stack trace from the Clojure compiler. It indicates that in <code>scratch/rocket.clj</code>, on line <code>69</code>, column <code>11</code>, we used the symbol <code>unit-vector</code>&ndash;but it didn&rsquo;t have a meaning at that point in the program. Perhaps <code>unit-vector</code> is defined <em>below</em> that line. There are two ways to solve this.</p>

<ol>
<li><p>Organize your functions so that the simple ones come first, and those that depend on them come later. Read this way, namespaces tell a story, progressing from smaller to bigger, more complex problems.</p></li>
<li><p>Sometimes, ordering functions this way is impossible, or would put related ideas too far apart. In this case you can <code>(declare unit-vector)</code> near the top of the namespace. This tells Clojure that <code>unit-vector</code> isn&rsquo;t defined <em>yet</em>, but it&rsquo;ll come later.</p></li>
</ol>

<p>Now that we&rsquo;ve broken up <code>engine-force</code> into <code>thrust</code> and <code>orientation</code>, we have to control the thrust properly for our two burns. We&rsquo;ll start by defining the times for the initial ascent and circularization burn, expressed as vectors of start and end times, in seconds.</p>
<code class="block"><span class="p">(</span><span class="k">def </span><span class="nv">ascent</span>
  <span class="s">&quot;The start and end times for the ascent burn.&quot;</span>
  <span class="p">[</span><span class="mi">0</span> <span class="mi">3000</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">circularization</span>
  <span class="s">&quot;The start and end times for the circularization burn.&quot;</span>
  <span class="p">[</span><span class="mi">4000</span> <span class="mi">1000</span><span class="p">])</span>
</code>
<p>Now we&rsquo;ll change the thrust by adjusting the rate of fuel consumption. Instead of burning at maximum until running out of fuel, we&rsquo;ll execute two distinct burns.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">fuel-rate</span>
  <span class="s">&quot;How fast is fuel, in kilograms/second, consumed by the craft?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Out of fuel</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">0</span>

    <span class="c1">; Ascent burn</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">ascent</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">ascent</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:max-fuel-rate</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; Circularization burn</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">circularization</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">circularization</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:max-fuel-rate</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; Shut down engines otherwise</span>
    <span class="ss">:else</span> <span class="mi">0</span><span class="p">))</span>
</code>
<p>We&rsquo;re using <code>cond</code> to express four distinct possibilities: that we&rsquo;ve run out of fuel, executing either of the two burns, or resting with the engines shut down. Because the comparison function <code>&lt;=</code> takes any number of arguments and asserts that they occur in order, expressing intervals like &ldquo;the time is between the first and last times in the ascent&rdquo; is easy.</p>

<p>Finally, we need to determine the <em>direction</em> to burn in. This one&rsquo;s gonna require some tricky linear algebra. You don&rsquo;t need to worry about the specifics here&ndash;the goal is to find out what direction the rocket should burn to fly towards the horizon, in a circle around the planet. We&rsquo;re doing that by taking the rocket&rsquo;s velocity vector, and <em>flattening out</em> the velocity towards or away from the planet. All that&rsquo;s left is the direction the rocket is flying <em>around</em> the earth.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">dot-product</span>
  <span class="s">&quot;Finds the inner product of two x, y, z coordinate maps.</span>
<span class="s">  See http://en.wikipedia.org/wiki/Dot_product.&quot;</span>
  <span class="p">[</span><span class="nv">c1</span> <span class="nv">c2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:x</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c2</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">c2</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">c2</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">projection</span>
  <span class="s">&quot;The component of coordinate map a in the direction of coordinate map b.</span>
<span class="s">  See http://en.wikipedia.org/wiki/Vector_projection.&quot;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">b</span> <span class="p">(</span><span class="nf">unit-vector</span> <span class="nv">b</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nf">dot-product</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">rejection</span>
  <span class="s">&quot;The component of coordinate map a *not* in the direction of coordinate map</span>
<span class="s">  b.&quot;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span><span class="o">&#39;</span> <span class="p">(</span><span class="nf">projection</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))</span>
     <span class="ss">:y</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))</span>
     <span class="ss">:z</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))}))</span>
</code>
<p>With the mathematical underpinnings ready, we&rsquo;ll define the orientation control software:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">orientation</span>
  <span class="s">&quot;What direction is the craft pointing?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Initially, point along the *position* vector of the craft--that is</span>
    <span class="c1">; to say, straight up, away from the earth.</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">ascent</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">ascent</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; During the circularization burn, we want to burn *sideways*, in the</span>
    <span class="c1">; direction of the orbit. We&#39;ll find the component of our velocity</span>
    <span class="c1">; which is aligned with our position vector (that is to say, the vertical</span>
    <span class="c1">; velocity), and subtract the vertical component. All that&#39;s left is the</span>
    <span class="c1">; *horizontal* part of our velocity.</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">circularization</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">circularization</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">rejection</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">))</span>

    <span class="c1">; Otherwise, just point straight ahead.</span>
    <span class="ss">:else</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)))</span>
</code>
<p>For the ascent burn, we&rsquo;ll push straight away from the planet. For circularization, we use the <code>rejection</code> function to find the part of the velocity around the planet, and thrust in that direction. By default, we&rsquo;ll leave the rocket pointing in the direction of travel.</p>

<p>With these changes made, the rocket should execute two burns. Let&rsquo;s re-run the tests and see.</p>
<code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test scratch.rocket-test

lein test scratch.rocket-test

Ran 2 tests containing 3 assertions.
0 failures, 0 errors.</code>
<p>We finally did it! We&rsquo;re <em>rocket scientists</em>!</p>

<h2>Review</h2>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.rocket</span><span class="p">)</span>

<span class="c1">;; Linear algebra for {:x 1 :y 2 :z 3} coordinate vectors.</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">map-values</span>
  <span class="s">&quot;Applies f to every value in the map m.&quot;</span>
  <span class="p">[</span><span class="nv">f</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">into </span><span class="p">{}</span>
        <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pair</span><span class="p">]</span>
               <span class="p">[(</span><span class="nb">key </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">val </span><span class="nv">pair</span><span class="p">))])</span>
             <span class="nv">m</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">magnitude</span>
  <span class="s">&quot;What&#39;s the radius of a given set of cartesian coordinates?&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="c1">; By the Pythagorean theorem...</span>
  <span class="p">(</span><span class="nf">Math/sqrt</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nf">Math/pow</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="mi">2</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">scale</span>
  <span class="s">&quot;Multiplies a map of x, y, and z coordinates by the given factor.&quot;</span>
  <span class="p">[</span><span class="nv">factor</span> <span class="nv">coordinates</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">map-values</span> <span class="p">(</span><span class="nb">partial * </span><span class="nv">factor</span><span class="p">)</span> <span class="nv">coordinates</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">unit-vector</span>
  <span class="s">&quot;Scales coordinates to magnitude 1.&quot;</span>
  <span class="p">[</span><span class="nv">coordinates</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nf">magnitude</span> <span class="nv">coordinates</span><span class="p">))</span> <span class="nv">coordinates</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">dot-product</span>
  <span class="s">&quot;Finds the inner product of two x, y, z coordinate maps. See</span>
<span class="s">  http://en.wikipedia.org/wiki/Dot_product&quot;</span>
  <span class="p">[</span><span class="nv">c1</span> <span class="nv">c2</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:x</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c2</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">c2</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">c1</span><span class="p">)</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">c2</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">projection</span>
  <span class="s">&quot;The component of coordinate map a in the direction of coordinate map b.</span>
<span class="s">  See http://en.wikipedia.org/wiki/Vector_projection.&quot;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">b</span> <span class="p">(</span><span class="nf">unit-vector</span> <span class="nv">b</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nf">dot-product</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">rejection</span>
  <span class="s">&quot;The component of coordinate map a *not* in the direction of coordinate map</span>
<span class="s">  b.&quot;</span>
  <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">a</span><span class="o">&#39;</span> <span class="p">(</span><span class="nf">projection</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))</span>
     <span class="ss">:y</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:y</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))</span>
     <span class="ss">:z</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="ss">:z</span> <span class="nv">a</span><span class="o">&#39;</span><span class="p">))}))</span>

<span class="c1">;; Coordinate conversion</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">cartesian-&gt;spherical</span>
  <span class="s">&quot;Converts a map of Cartesian coordinates :x, :y, and :z to spherical</span>
<span class="s">  coordinates :r, :theta, and :phi.&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">magnitude</span> <span class="nv">c</span><span class="p">)]</span>
    <span class="p">{</span><span class="ss">:r</span>     <span class="nv">r</span>
     <span class="ss">:phi</span>   <span class="p">(</span><span class="nf">Math/acos</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:z</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">r</span><span class="p">))</span>
     <span class="ss">:theta</span> <span class="p">(</span><span class="nf">Math/atan</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="ss">:y</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="ss">:x</span> <span class="nv">c</span><span class="p">)))}))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">spherical-&gt;cartesian</span>
  <span class="s">&quot;Converts spherical to Cartesian coordinates.&quot;</span>
  <span class="p">[</span><span class="nv">c</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:x</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="p">(</span><span class="ss">:theta</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))</span>
   <span class="ss">:y</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:theta</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nf">Math/sin</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))</span>
   <span class="ss">:z</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="ss">:r</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">Math/cos</span> <span class="p">(</span><span class="ss">:phi</span> <span class="nv">c</span><span class="p">)))})</span>

<span class="c1">;; The earth</span>

<span class="p">(</span><span class="k">def </span><span class="nv">earth-equatorial-radius</span>
  <span class="s">&quot;Radius of the earth, in meters&quot;</span>
  <span class="mi">6378137</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">earth-day</span>
  <span class="s">&quot;Length of an earth day, in seconds.&quot;</span>
  <span class="mi">86400</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">earth-equatorial-speed</span>
  <span class="s">&quot;How fast points on the equator move, relative to the center of the earth, in</span>
<span class="s">  meters/sec.&quot;</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">Math/PI</span> <span class="nv">earth-equatorial-radius</span><span class="p">)</span>
     <span class="nv">earth-day</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">g</span> <span class="s">&quot;Acceleration of gravity in meters/s^2&quot;</span> <span class="mf">-9.8</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">initial-space-center</span>
  <span class="s">&quot;The initial position and velocity of the launch facility&quot;</span>
  <span class="p">{</span><span class="ss">:time</span>     <span class="mi">0</span>
   <span class="ss">:position</span> <span class="p">{</span><span class="ss">:x</span> <span class="nv">earth-equatorial-radius</span>
              <span class="ss">:y</span> <span class="mi">0</span>
              <span class="ss">:z</span> <span class="mi">0</span><span class="p">}</span>
   <span class="ss">:velocity</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>
              <span class="ss">:y</span> <span class="nv">earth-equatorial-speed</span>
              <span class="ss">:z</span> <span class="mi">0</span><span class="p">}})</span>


<span class="c1">;; Craft</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">centaur</span>
  <span class="s">&quot;The upper rocket stage.</span>
<span class="s">  http://en.wikipedia.org/wiki/Centaur_(rocket_stage)</span>
<span class="s">  http://www.astronautix.com/stages/cenaurde.htm&quot;</span>
  <span class="p">[]</span>
  <span class="p">{</span><span class="ss">:dry-mass</span>  <span class="mi">2361</span>
   <span class="ss">:fuel-mass</span> <span class="mi">13897</span>
   <span class="ss">:isp</span>       <span class="mi">4354</span>
   <span class="ss">:max-fuel-rate</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">13897</span> <span class="mi">470</span><span class="p">)})</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">atlas-v</span>
  <span class="s">&quot;The full launch vehicle. http://en.wikipedia.org/wiki/Atlas_V&quot;</span>
  <span class="p">[</span><span class="nv">next-stage</span><span class="p">]</span>
  <span class="p">{</span><span class="ss">:dry-mass</span>  <span class="mi">50050</span>
   <span class="ss">:fuel-mass</span> <span class="mi">284450</span>
   <span class="ss">:isp</span> <span class="mi">3050</span>
   <span class="ss">:max-fuel-rate</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">284450</span> <span class="mi">253</span><span class="p">)</span>
   <span class="ss">:next-stage</span> <span class="nv">next-stage</span><span class="p">})</span>

<span class="c1">;; Flight control</span>

<span class="p">(</span><span class="k">def </span><span class="nv">ascent</span>
  <span class="s">&quot;The start and end times for the ascent burn.&quot;</span>
  <span class="p">[</span><span class="mi">0</span> <span class="mi">300</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">circularization</span>
  <span class="s">&quot;The start and end times for the circularization burn.&quot;</span>
  <span class="p">[</span><span class="mi">400</span> <span class="mi">1000</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">orientation</span>
  <span class="s">&quot;What direction is the craft pointing?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Initially, point along the *position* vector of the craft--that is</span>
    <span class="c1">; to say, straight up, away from the earth.</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">ascent</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">ascent</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; During the circularization burn, we want to burn *sideways*, in the</span>
    <span class="c1">; direction of the orbit. We&#39;ll find the component of our velocity</span>
    <span class="c1">; which is aligned with our position vector (that is to say, the vertical</span>
    <span class="c1">; velocity), and subtract the vertical component. All that&#39;s left is the</span>
    <span class="c1">; *horizontal* part of our velocity.</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">circularization</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">circularization</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">rejection</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">))</span>

    <span class="c1">; Otherwise, just point straight ahead.</span>
    <span class="ss">:else</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fuel-rate</span>
  <span class="s">&quot;How fast is fuel, in kilograms/second, consumed by the craft?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Out of fuel</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="mi">0</span>

    <span class="c1">; Ascent burn</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">ascent</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">ascent</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:max-fuel-rate</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; Circularization burn</span>
    <span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="nb">first </span><span class="nv">circularization</span><span class="p">)</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">last </span><span class="nv">circularization</span><span class="p">))</span>
    <span class="p">(</span><span class="ss">:max-fuel-rate</span> <span class="nv">craft</span><span class="p">)</span>

    <span class="c1">; Shut down engines otherwise</span>
    <span class="ss">:else</span> <span class="mi">0</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">stage</span>
  <span class="s">&quot;When fuel reserves are exhausted, separate stages. Otherwise, return craft</span>
<span class="s">  unchanged.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="c1">; Still fuel left</span>
    <span class="p">(</span><span class="nb">pos? </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">))</span>
    <span class="nv">craft</span>

    <span class="c1">; No remaining stages</span>
    <span class="p">(</span><span class="nb">nil? </span><span class="p">(</span><span class="ss">:next-stage</span> <span class="nv">craft</span><span class="p">))</span>
    <span class="nv">craft</span>

    <span class="c1">; Stage!</span>
    <span class="ss">:else</span>
    <span class="p">(</span><span class="nb">merge </span><span class="p">(</span><span class="ss">:next-stage</span> <span class="nv">craft</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">select-keys </span><span class="nv">craft</span> <span class="p">[</span><span class="ss">:time</span> <span class="ss">:position</span> <span class="ss">:velocity</span><span class="p">]))))</span>

<span class="c1">;; Dynamics</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">thrust</span>
  <span class="s">&quot;How much force, in newtons, does the craft&#39;s rocket engines exert?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nf">fuel-rate</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:isp</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">mass</span>
  <span class="s">&quot;The total mass of a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="ss">:dry-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">gravity-force</span>
  <span class="s">&quot;The force vector, each component in Newtons, due to gravity.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="c1">; Since force is mass times acceleration...</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">total-force</span> <span class="p">(</span><span class="nb">* </span><span class="nv">g</span> <span class="p">(</span><span class="nf">mass</span> <span class="nv">craft</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">craft</span>
        <span class="c1">; Now we&#39;ll take the craft&#39;s position</span>
        <span class="ss">:position</span>
        <span class="c1">; in spherical coordinates,</span>
        <span class="nv">cartesian-&gt;spherical</span>
        <span class="c1">; replace the radius with the gravitational force...</span>
        <span class="p">(</span><span class="nb">assoc </span><span class="ss">:r</span> <span class="nv">total-force</span><span class="p">)</span>
        <span class="c1">; and transform back to Cartesian-land</span>
        <span class="nv">spherical-&gt;cartesian</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">declare </span><span class="nv">altitude</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">engine-force</span>
  <span class="s">&quot;The force vector, each component in Newtons, due to the rocket engine.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
<span class="c1">;  Debugging; useful for working through trajectories in detail.</span>
<span class="c1">;  (println craft)</span>
<span class="c1">;  (println &quot;t   &quot; (:time craft) &quot;alt&quot; (altitude craft) &quot;thrust&quot; (thrust craft))</span>
<span class="c1">;  (println &quot;fuel&quot; (:fuel-mass craft))</span>
<span class="c1">;  (println &quot;vel &quot; (:velocity craft))</span>
<span class="c1">;  (println &quot;ori &quot; (unit-vector (orientation craft)))</span>
  <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nf">thrust</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nf">unit-vector</span> <span class="p">(</span><span class="nf">orientation</span> <span class="nv">craft</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">total-force</span>
  <span class="s">&quot;Total force on a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="nf">engine-force</span> <span class="nv">craft</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">gravity-force</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">acceleration</span>
  <span class="s">&quot;Total acceleration of a craft.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">m</span> <span class="p">(</span><span class="nf">mass</span> <span class="nv">craft</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">scale</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">m</span><span class="p">)</span> <span class="p">(</span><span class="nf">total-force</span> <span class="nv">craft</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">step</span>
  <span class="p">[</span><span class="nv">craft</span> <span class="nv">dt</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">craft</span> <span class="p">(</span><span class="nf">stage</span> <span class="nv">craft</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">assoc </span><span class="nv">craft</span>
           <span class="c1">; Time advances by dt seconds</span>
           <span class="ss">:time</span>      <span class="p">(</span><span class="nb">+ </span><span class="nv">dt</span> <span class="p">(</span><span class="ss">:time</span> <span class="nv">craft</span><span class="p">))</span>
           <span class="c1">; We burn some fuel</span>
           <span class="ss">:fuel-mass</span> <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="ss">:fuel-mass</span> <span class="nv">craft</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">dt</span> <span class="p">(</span><span class="nf">fuel-rate</span> <span class="nv">craft</span><span class="p">)))</span>
           <span class="c1">; Our position changes based on our velocity</span>
           <span class="ss">:position</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:position</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)))</span>
           <span class="c1">; And our velocity changes based on our acceleration</span>
           <span class="ss">:velocity</span>  <span class="p">(</span><span class="nb">merge-with + </span><span class="p">(</span><span class="ss">:velocity</span> <span class="nv">craft</span><span class="p">)</span>
                                  <span class="p">(</span><span class="nf">scale</span> <span class="nv">dt</span> <span class="p">(</span><span class="nf">acceleration</span> <span class="nv">craft</span><span class="p">))))))</span>

<span class="c1">;; Launch and flight</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">prepare</span>
  <span class="s">&quot;Prepares a craft for launch from an equatorial space center.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">merge </span><span class="nv">craft</span> <span class="nv">initial-space-center</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">trajectory</span>
  <span class="p">[</span><span class="nv">dt</span> <span class="nv">craft</span><span class="p">]</span>
  <span class="s">&quot;Returns all future states of the craft, at dt-second intervals.&quot;</span>
  <span class="p">(</span><span class="nb">iterate </span><span class="o">#</span><span class="p">(</span><span class="nf">step</span> <span class="nv">%</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">craft</span><span class="p">))</span>

<span class="c1">;; Analyzing trajectories</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">altitude</span>
  <span class="s">&quot;The height above the surface of the equator, in meters.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">craft</span>
      <span class="ss">:position</span>
      <span class="nv">cartesian-&gt;spherical</span>
      <span class="ss">:r</span>
      <span class="p">(</span><span class="nb">- </span><span class="nv">earth-equatorial-radius</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">above-ground?</span>
  <span class="s">&quot;Is the craft at or above the surface?&quot;</span>
  <span class="p">[</span><span class="nv">craft</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">altitude</span> <span class="nv">craft</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">flight</span>
  <span class="s">&quot;The above-ground portion of a trajectory.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">take-while </span><span class="nv">above-ground?</span> <span class="nv">trajectory</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">crashed?</span>
  <span class="s">&quot;Does this trajectory crash into the surface before 10 hours are up?&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">time-limit</span> <span class="p">(</span><span class="nb">* </span><span class="mi">10</span> <span class="mi">3600</span><span class="p">)]</span> <span class="c1">; 10 hours</span>
    <span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">every? </span><span class="nv">above-ground?</span>
                 <span class="p">(</span><span class="nb">take-while </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;= </span><span class="p">(</span><span class="ss">:time</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">time-limit</span><span class="p">)</span> <span class="nv">trajectory</span><span class="p">)))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">crash-time</span>
  <span class="s">&quot;Given a trajectory, returns the time the rocket impacted the ground.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="ss">:time</span> <span class="p">(</span><span class="nb">last </span><span class="p">(</span><span class="nf">flight</span> <span class="nv">trajectory</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">apoapsis</span>
  <span class="s">&quot;The highest altitude achieved during a trajectory.&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply max </span><span class="p">(</span><span class="nb">map </span><span class="nv">altitude</span> <span class="p">(</span><span class="nf">flight</span> <span class="nv">trajectory</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">apoapsis-time</span>
  <span class="s">&quot;The time of apoapsis&quot;</span>
  <span class="p">[</span><span class="nv">trajectory</span><span class="p">]</span>
  <span class="p">(</span><span class="ss">:time</span> <span class="p">(</span><span class="nb">apply max-key </span><span class="nv">altitude</span> <span class="p">(</span><span class="nf">flight</span> <span class="nv">trajectory</span><span class="p">))))</span>
</code>
<p>As written here, our first non-trivial program tells a story&ndash;though a <em>different</em> one than the process of exploration and refinement that brought the rocket to orbit. It builds from small, abstract ideas: linear algebra and coordinates; physical constants describing the universe for the simulation; and the basic outline of the spacecraft. Then we define the software controlling the rocket; the times for the burns, how much to thrust, in what direction, and when to separate stages. Using those control functions, we build a <em>physics engine</em> including gravity and thrust forces, and use Newton&rsquo;s second law to build a basic <a href="http://en.wikipedia.org/wiki/Euler_method">Euler Method</a> solver. Finally, we analyze the trajectories the solver produces to answer key questions: how high, how long, and did it explode?</p>

<p>We used Clojure&rsquo;s immutable data structures&ndash;mostly maps&ndash;to represent the state of the universe, and defined <em>pure functions</em> to interpret those states and construct new ones. Using <code>iterate</code>, we projected a single state forward into an infinite timeline of the future&ndash;evaluated as demanded by the analysis functions. Though we pay a performance penalty, immutable data structures, pure functions, and lazy evaluation make simulating complex systems easier to reason about.</p>

<p>Had we written this simulation in a different language, different techniques might have come into play. In Java, C++, or Ruby, we would have defined a hierarchy of datatypes called <em>classes</em>, each one representing a small piece of state. We might define a <code>Craft</code> type, and created subtypes <code>Atlas</code> and <code>Centaur</code>. We&rsquo;d create a <code>Coordinate</code> type, subdivided into <code>Cartesian</code> and <code>Spherical</code>, and so on. The types add complexity and rigidity, but also prevent mis-spellings, and can prevent us from interpreting, say, coordinates as craft or vice-versa.</p>

<p>To move the system forward in a language emphasizing <em>mutable</em> data structures, we would have updated the time and coordinates of a single craft in-place. This introduces additional complexity, because many of the changes we made depended on the current values of the craft. To ensure the correct ordering of calculations, we&rsquo;d scatter temporary variables and explicit copies throughout the code, ensuring that functions didn&rsquo;t see inconsistent pictures of the craft state. The mutable approach would likely be faster, but would still demand some copying of data, and sacrifice clarity.</p>

<p>More <em>imperative</em> languages place less emphasis on laziness, and make it harder to express ideas like <code>map</code> and <code>take</code>. We might have simulated the trajectory for some fixed time, constructing a history of all the intermediate results we needed, then analyzed it by moving explicitly from slot to slot in that history, checking if the craft had crashed, and so on.</p>

<p>Across all these languages, though, some ideas remain the same. We solve big problems by breaking them up into smaller ones. We use data structures to represent the state of the system, and functions to alter that state. Comments and docstrings clarify the <em>story</em> of the code, making it readable to others. Tests ensure the software is correct, and allow us to work piecewise towards a solution.</p>

<h2>Exercises</h2>

<ol>
<li><p>We know the spacecraft reached orbit, but we have no idea what that orbit <em>looks</em> like. Since the trajectory is infinite in length, we can&rsquo;t ask about the <em>entire</em> history using <code>max</code>&ndash;but we know that all orbits have a high and low point. At the highest point, the difference between successive altitudes changes from increasing to decreasing, and at the lowest point, the difference between successive altitudes changes from decreasing to increasing. Using this technique, refine the <code>apoapsis</code> function to find the highest point using that <em>inflection</em> in altitudes&ndash;and write a corresponding <code>periapsis</code> function that finds the lowest point in the orbit. Display both periapsis and apoapsis in the test suite.</p></li>
<li><p>We assumed the force of gravity resulted in a constant 9.8 meter/second/second acceleration towards the earth, but in the real world, gravity falls off with the <a href="http://en.wikipedia.org/wiki/Newton&#x27;s_law_of_universal_gravitation">inverse square law</a>. Using the mass of the earth, mass of the spacecraft, and Newton&rsquo;s constant, refine the gravitational force used in this simulation to take Newton&rsquo;s law into account. How does this affect the apoapsis?</p></li>
<li><p>We ignored the atmosphere, which exerts <a href="http://en.wikipedia.org/wiki/Drag_(physics)">drag</a> on the craft as it moves through the air. Write a basic air-density function which falls off with altitude. Make some educated guesses as to how much drag a real rocket experiences, and assume that the drag force is proportional to the square of the rocket&rsquo;s velocity. Can your rocket still reach orbit?</p></li>
<li><p>Notice that the periapsis and apoapsis of the rocket are <em>different</em>. By executing the circularization burn carefully, can you make them the same&ndash;achieving a perfectly circular orbit? One way to do this is to pick an orbital altitude and velocity of a known satellite&ndash;say, the International Space Station&ndash;and write the control software to match that velocity at that altitude.</p></li>
</ol>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/311-clojure-from-the-ground-up-logistics">Clojure from the ground up: logistics</a></h1>
    </div>
    <div class="body">
      <p><em>Previously, we covered <a href="http://aphyr.com/posts/306-clojure-from-the-ground-up-state">state and mutability</a>.</em></p>

<p>Up until now, we&rsquo;ve been programming primarily at the REPL. However, the
REPL is a limited tool. While it lets us explore a problem interactively, that
interactivity comes at a cost: changing an expression requires retyping the
entire thing, editing multi-line expressions is awkward, and our work vanishes
when we restart the REPL&ndash;so we can&rsquo;t share our programs with others, or run
them again later. Moreover, programs in the REPL are hard to organize. To solve
large problems, we need a way of writing programs <em>durably</em>&ndash;so they can be read
and evaluated later.</p>

<p>In addition to the code itself, we often want to store <em>ancillary</em>
information. <em>Tests</em> verify the correctness of the program. <em>Resources</em> like
precomputed databases, lookup tables, images, and text files provide other data
the program needs to run. There may be <em>documentation</em>: instructions for how to use and understand the software. A program may also depend on code from <em>other</em> programs, which we call <em>libraries</em>, <em>packages</em>, or <em>dependencies</em>. In Clojure, we have a standardized way to bind together all these parts into a single directory, called a <em>project</em>.</p>

<h2>Project structure</h2>

<p>We created a project at the start of this book by using Leiningen, the Clojure
project tool.</p>
<code class="block"><span class="nv">$ </span>lein new scratch
</code>
<p><code>scratch</code> is the name of the project, and also the name of the directory where the project&rsquo;s files live. Inside the project are a few files.</p>
<code class="block"><span class="nv">$ </span><span class="nb">cd </span>scratch; ls
doc  project.clj  README.md  resources  src  target  <span class="nb">test</span>
</code>
<p><code>project.clj</code> defines the project: its name, its version, dependencies, and so
on. Notice the name of the project (<code>scratch</code>) comes first, followed by the
version (<code>0.1.0-SNAPSHOT</code>). <code>-SNAPSHOT</code> versions are for development; you can
change them at any time, and any projects which depend on the snapshot will
pick up the most recent changes. A version which does <em>not</em> end in <code>-SNAPSHOT</code>
is fixed: once published, it always points to the same version of the project.
This allows projects to specify precisely which projects they depend on. For
example, scratch&rsquo;s <code>project.clj</code> says scratch depends on <code>org.clojure/clojure</code>
version <code>1.5.1</code>.</p>
<code class="block"><span class="p">(</span><span class="kd">defproject </span><span class="nv">scratch</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
  <span class="ss">:description</span> <span class="s">&quot;FIXME: write description&quot;</span>
  <span class="ss">:url</span> <span class="s">&quot;http://example.com/FIXME&quot;</span>
  <span class="ss">:license</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Eclipse Public License&quot;</span>
            <span class="ss">:url</span> <span class="s">&quot;http://www.eclipse.org/legal/epl-v10.html&quot;</span><span class="p">}</span>
  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.5.1&quot;</span><span class="p">]</span> <span class="p">])</span>
</code>
<p><code>README.md</code> is the first file most people open when they look at a new project,
and Lein generates a generic readme for you to fill in later. We call this kind
of scaffolding or example a &ldquo;stub&rdquo;; it&rsquo;s just there to remind you what sort of
things to write yourself. You&rsquo;ll notice the readme includes the name of the
project, some notes on what it does and how to use it, a copyright notice where
your name should go, and a license, which sets the legal terms for the use of
the project. By default, Leiningen suggests the Eclipse Public License, which
allows everyone to use and modify the software, so long as they preserve the
license information.</p>

<p>The <code>doc</code> directory is for documentation; sometimes hand-written, sometimes
automatically generated from the source code. <code>resources</code> is for additional
files, like images. <code>src</code> is where Clojure code lives, and <code>test</code> contains the
corresponding tests. Finally, <code>target</code> is where Leiningen stores compiled code,
built packages, and so on.</p>

<h2>Namespaces</h2>

<p>Every lein project starts out with a stub namespace containing a simple function. Let&rsquo;s take a look at that namespace now&ndash;it lives in <code>src/scratch/core.clj</code>:</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.core</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">foo</span>
  <span class="s">&quot;I don&#39;t do a whole lot.&quot;</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">println </span><span class="nv">x</span> <span class="s">&quot;Hello, World!&quot;</span><span class="p">))</span>
</code>
<p>The first part of this file defines the <em>namespace</em> we&rsquo;ll be working in. The <code>ns</code> macro lets the Clojure compiler know that all following code belongs in the <code>scratch.core</code> namespace. Remember, <code>scratch</code> is the name of our project. <code>scratch.core</code> is for the core functions and definitions of the scratch project. As projects expand, we might add new namespaces to <em>separate</em> our work into smaller, more understandable pieces. For instance, Clojure&rsquo;s primary functions live in <code>clojure.core</code>, but there are auxiliary functions for string processing in <code>clojure.string</code>, functions for interoperating with Java&rsquo;s input-output system in <code>clojure.java.io</code>, for printing values in <code>clojure.pprint</code>, and so on.</p>

<p><code>def</code>, <code>defn</code>, and peers always work in the scope of a particular <em>namespace</em>. The function <code>foo</code> in <code>scratch.core</code> is <em>different</em> from the function <code>foo</code> in <code>scratch.pad</code>.</p>
<code class="block"><span class="nv">scratch.foo=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.core</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">scratch.core=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">foo</span> <span class="s">&quot;I&#39;m in core&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;scratch.core/foo</span>
<span class="nv">scratch.core=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.pad</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">scratch.pad=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">foo</span> <span class="s">&quot;I&#39;m in pad!&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;scratch.pad/foo</span>
</code>
<p>Notice the full names of these vars are different: <code>scratch.core/foo</code> vs <code>scratch.pad/foo</code>. You can always refer to a var by its fully qualified name: the namespace, followed by a slash <code>/</code>, followed by the short name.</p>

<p>Inside a namespace, symbols resolve to variables which are defined in that namespace. So in <code>scratch.pad</code>, <code>foo</code> refers to <code>scratch.pad/foo</code>.</p>
<code class="block"><span class="nv">scratch.pad=&gt;</span> <span class="nv">foo</span>
<span class="s">&quot;I&#39;m in pad!&quot;</span>
</code>
<p>Namespaces automatically include <code>clojure.core</code> by default; which is where all the standard functions, macros, and special forms come from. <code>let</code>, <code>defn</code>, <code>filter</code>, <code>vector</code>, etc: all live in <code>clojure.core</code>, but are automatically <em>included</em> in new namespaces so we can refer to them by their short names.</p>

<p>Notice that the values for <code>foo</code> we defined in <code>scratch.pad</code> and <code>scratch.core</code> aren&rsquo;t available in other namespaces, like <code>user</code>.</p>
<code class="block"><span class="nv">scratch.pad=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">user</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">foo</span>

<span class="nv">CompilerException</span> <span class="nv">java.lang.RuntimeException</span><span class="err">:</span> <span class="nv">Unable</span> <span class="nv">to</span> <span class="nb">resolve </span><span class="nv">symbol</span><span class="err">:</span> <span class="nv">foo</span> <span class="nv">in</span> <span class="nv">this</span> <span class="nv">context</span>, <span class="nv">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="ss">:1:602</span><span class="p">)</span>
</code>
<p>To access things from other namespaces, we have to <em>require</em> them in the namespace definition.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">user</span> <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">scratch.core</span><span class="p">]))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">scratch.core/foo</span>
<span class="s">&quot;I&#39;m in core&quot;</span>
</code>
<p>The <code>:require</code> part of the <code>ns</code> declaration told the compiler that the <code>user</code> namespace needed access to <code>scratch.core</code>. We could then refer to the fully qualified name <code>scratch.core/foo</code>.</p>

<p>Often, writing out the full namespace is cumbersome&ndash;so you can give a short alias for a namespace like so:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">user</span> <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">scratch.core</span> <span class="ss">:as</span> <span class="nv">c</span><span class="p">]))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">c/foo</span>
<span class="s">&quot;I&#39;m in core&quot;</span>
</code>
<p>The <code>:as</code> directive indicates that anywhere we write <code>c/something</code>, the compiler should expand that to <code>scratch.core/something</code>. If you plan on using a var from another namespace often, you can <em>refer</em> it to the local namespace&ndash;which means you may omit the namespace qualifier entirely.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">user</span> <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">scratch.core</span> <span class="ss">:refer</span> <span class="p">[</span><span class="nv">foo</span><span class="p">]]))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">foo</span>
<span class="s">&quot;I&#39;m in core&quot;</span>
</code>
<p>You can refer functions into the current namespace by listing them: <code>[foo bar ...]</code>. Alternatively, you can suck in <em>every</em> function from another namespace by saying <code>:refer :all</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">user</span> <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">scratch.core</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">foo</span>
<span class="s">&quot;I&#39;m in core&quot;</span>
</code>
<p>Namespaces <em>control complexity</em> by isolating code into more understandable, related pieces. They make it easier to read code by keeping similar things together, and unrelated things apart. By making dependencies between namespaces explicit, they make it clear how groups of functions relate to one another.</p>

<p>If you&rsquo;ve worked with Erlang, Modula-2, Haskell, Perl, or ML, you&rsquo;ll find namespaces analogous to <em>modules</em> or <em>packages</em>. Namespaces are often large, encompassing hundreds of functions; and most projects use only a handful of namespaces.</p>

<p>By contrast, object-oriented programming languages like Java, Scala, Ruby, and Objective C organize code in <em>classes</em>, which combine <em>names</em> and <em>state</em> in a single construct. Because all functions in a class operate on the same state, object-oriented languages tend to have <em>many</em> classes with <em>fewer</em> functions in each. It&rsquo;s not uncommon for a typical Java project to define hundreds or thousands of classes containing only one or two functions each. If you come from an object-oriented language, it can feel a bit unusual to combine so many functions in a single scope&ndash;but because functional programs isolate state differently, this is <em>normal</em>. If, on the other hand, you move <em>to</em> an object-oriented language after Clojure, remember that OO languages compose differently. Objects with hundreds of functions are usually considered unwieldy and should be split into smaller pieces.</p>

<h2>Code and tests</h2>

<p>It&rsquo;s perfectly fine to test small programs in the REPL. We&rsquo;ve written
and refined hundreds of functions that way: by calling the function and seeing
what happens. However, as programs grow in scope and complexity, testing them
by hand becomes harder and harder. If you change the behavior of a function
which ten other functions rely on, you may have to re-test <em>all ten</em> by hand. In real programs, a small change can alter thousands of distinct behaviors, all of which should be verified.</p>

<p>Wherever possible, we want to <em>automate</em> software tests&ndash;making the test itself
<em>another program</em>. If the test suite runs in a matter of seconds, we can make
changes freely&ndash;re-running the tests continuously to verify that everything
still works.</p>

<p>As a simple example, let&rsquo;s write and test a single function in <code>src/scratch/core.clj</code>. How about exponentiation&ndash;raising a number to the given power?</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.core</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">pow</span>
  <span class="s">&quot;Raises base to the given power. For instance, (pow 3 2) returns three squared, or nine.&quot;</span>
  <span class="p">[</span><span class="nv">base</span> <span class="nv">power</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply * </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">base</span> <span class="nv">power</span><span class="p">)))</span>
</code>
<p>So we <em>repeat</em> the base <em>power</em> times, then call <code>*</code> with that sequence of bases to multiply them all together. Seems straightforward enough. Now we need to test it.</p>

<p>By default, all lein projects come with a simple test stub. Let&rsquo;s see it in action by running <code>lein test</code>.</p>
<code class="block">aphyr@waterhouse:~/scratch<span class="nv">$ </span>lein <span class="nb">test</span>

lein <span class="nb">test </span>scratch.core-test

lein <span class="nb">test</span> :only scratch.core-test/a-test

FAIL in <span class="o">(</span>a-test<span class="o">)</span> <span class="o">(</span>core_test.clj:7<span class="o">)</span>
FIXME, I fail.
expected: <span class="o">(=</span> 0 1<span class="o">)</span>
  actual: <span class="o">(</span>not <span class="o">(=</span> 0 1<span class="o">))</span>

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
Tests failed.
</code>
<p>A <em>failure</em> is when a test returns the wrong value. An <em>error</em> is when a test throws an exception. In this case, the test named <code>a-test</code>, in the file <code>core_test.clj</code>, on line 7, failed. That test expected zero to be equal to one&ndash;but found that 0 and 1 were (in point of fact) not equal. Let&rsquo;s take a look at that test, in <code>test/scratch/core_test.clj</code>.</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.core-test</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.test</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">scratch.core</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">deftest</span> <span class="nv">a-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;FIXME, I fail.&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="mi">1</span><span class="p">))))</span>
</code>
<p>These tests live in a namespace too! Notice that namespaces and file names match up: <code>scratch.core</code> lives in <code>src/scratch/core.clj</code>, and <code>scratch.core-test</code> lives in <code>test/scratch/core_test.clj</code>. Dashes (<code>-</code>) in namespaces correspond to underscores (<code>_</code>) in filenames, and dots (<code>.</code>) correspond to directory separators (<code>/</code>).</p>

<p>The <code>scratch.core-test</code> namespace is responsible for testing things in <code>scratch.core</code>. Notice that it requires two namespaces: <code>clojure.test</code>, which provides testing functions and macros, and <code>scratch.core</code>, which is the namespace we want to test.</p>

<p>Then we define a test using <code>deftest</code>. <code>deftest</code> takes a symbol as a test name, and then any number of expressions to evaluate. We can use <code>testing</code> to split up tests into smaller pieces. If a test fails, <code>lein test</code> will print out the enclosing <code>deftest</code> and <code>testing</code> names, to make it easier to figure out what went wrong.</p>

<p>Let&rsquo;s change this test so that it passes. 0 should equal 0.</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">a-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;Numbers are equal to themselves, right?&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="mi">0</span><span class="p">))))</span>
</code><code class="block">aphyr@waterhouse:~/scratch<span class="nv">$ </span>lein <span class="nb">test</span>

lein <span class="nb">test </span>scratch.core-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
</code>
<p>Wonderful! Now let&rsquo;s test the <code>pow</code> function. I like to start with a really basic case and work my way up to more complicated ones. 1<sup>1</sup> is 1, so:</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">pow-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;unity&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)))))</span>
</code><code class="block">aphyr@waterhouse:~/scratch<span class="nv">$ </span>lein <span class="nb">test</span>

lein <span class="nb">test </span>scratch.core-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
</code>
<p>Excellent. How about something harder?</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">pow-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;unity&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>

  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;square integers&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">9</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)))))</span>
</code><code class="block">aphyr@waterhouse:~/scratch<span class="nv">$ </span>lein <span class="nb">test</span>

lein <span class="nb">test </span>scratch.core-test

lein <span class="nb">test</span> :only scratch.core-test/pow-test

FAIL in <span class="o">(</span>pow-test<span class="o">)</span> <span class="o">(</span>core_test.clj:10<span class="o">)</span>
square integers
expected: <span class="o">(=</span> 9 <span class="o">(</span>pow 3 2<span class="o">))</span>
  actual: <span class="o">(</span>not <span class="o">(=</span> 9 8<span class="o">))</span>

Ran 1 tests containing 2 assertions.
1 failures, 0 errors.
Tests failed.
</code>
<p>That&rsquo;s odd. 3<sup>2</sup> should be 9, not 8. Let&rsquo;s double-check our code in the REPL. <code>base</code> was 3, and <code>power</code> was 2, so&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">repeat </span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">8</span>
</code>
<p>Ah, there&rsquo;s the problem. We&rsquo;re mis-using <code>repeat</code>. Instead of repeating 3 twice, we repeated 2 thrice.</p>
<code class="block">user=&gt; (doc repeat)
-------------------------
clojure.core&#x2F;repeat
([x] [n x])
  Returns a lazy (infinite!, or length n if supplied) sequence of xs.</code>
<p>Let&rsquo;s redefine <code>pow</code> with the correct arguments to <code>repeat</code>:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">pow</span>
  <span class="s">&quot;Raises base to the given power. For instance, (pow 3 2) returns three</span>
<span class="s">  squared, or nine.&quot;</span>
  <span class="p">[</span><span class="nv">base</span> <span class="nv">power</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">apply * </span><span class="p">(</span><span class="nb">repeat </span><span class="nv">power</span> <span class="nv">base</span><span class="p">)))</span>
</code>
<p>How about 0<sup>0?</sup> By convention, mathematicians define 0<sup>0</sup> as 1.</p>
<code class="block"><span class="p">(</span><span class="nf">deftest</span> <span class="nv">pow-test</span>
  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;unity&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>

  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;square integers&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">9</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">))))</span>

  <span class="p">(</span><span class="nf">testing</span> <span class="s">&quot;0^0&quot;</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="p">(</span><span class="nf">pow</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)))))</span>
</code><code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test

lein test scratch.core-test

Ran 1 tests containing 3 assertions.
0 failures, 0 errors.</code>
<p>Hey, what do you know? It works! But <em>why</em>?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">repeat </span><span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">()</span>
</code>
<p>What happens when we call <code>*</code> with an <em>empty</em> list of arguments?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">*</span><span class="p">)</span>
<span class="mi">1</span>
</code>
<p>Remember when we talked about how the zero-argument forms of <code>+</code>, and <code>*</code> made some definitions simpler? This is one of those times. We didn&rsquo;t have to define a special exception for zero powers because <code>(*)</code> returns the multiplicative identity 1, by convention.</p>

<h2>Exploring data</h2>

<p>The last bit of logistics we need to talk about is <em>working with other people&rsquo;s code</em>. Clojure projects, like most modern programming environments, are built to work together. We can use libraries to parse data, solve mathematical problems, render graphics, perform simulations, talk to robots, or predict the weather. As a quick example, I&rsquo;d like to imagine that you and I are public-health researchers trying to identify the best location for an ad campaign to reduce drunk driving.</p>

<p>The FBI&rsquo;s <a href="http://www.fbi.gov/about-us/cjis/ucr/ucr">Uniform Crime Reporting</a> database tracks the annual tally of different types of arrests, broken down by county&ndash;but the data files provided by the FBI are a mess to work with. Helpfully, <a href="http://emdasheveryone.wordpress.com/">Matt Aliabadi</a> has helpfully organized the UCR&rsquo;s somewhat complex format into nice, normalized files in a data format called JSON, and made them available <a href="https://github.com/maliabadi/ucr-json">on Github</a>. Let&rsquo;s download the most recent year&rsquo;s <a href="https://raw2.github.com/maliabadi/ucr-json/master/data/parsed/normalized/2008.json">normalized data</a>, and save it in the <code>scratch</code> directory.</p>

<p>What&rsquo;s <em>in</em> this file, anyway? Let&rsquo;s take a look at the first few lines using <code>head</code>:</p>
<code class="block"><span class="err">aphyr@waterhouse:~/scratch$</span> <span class="err">head</span> <span class="mi">2008</span><span class="err">.json</span>
<span class="p">[</span>
  <span class="p">{</span>
    <span class="nt">&quot;icpsr_study_number&quot;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nt">&quot;icpsr_edition_number&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&quot;icpsr_part_number&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&quot;icpsr_sequential_case_id_number&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">&quot;fips_state_code&quot;</span><span class="p">:</span> <span class="s2">&quot;01&quot;</span><span class="p">,</span>
    <span class="nt">&quot;fips_county_code&quot;</span><span class="p">:</span> <span class="s2">&quot;001&quot;</span><span class="p">,</span>
    <span class="nt">&quot;county_population&quot;</span><span class="p">:</span> <span class="mi">52417</span><span class="p">,</span>
    <span class="nt">&quot;number_of_agencies_in_county&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</code>
<p>This is a data format called <a href="http://json.org/">JSON</a>, and it looks a lot like Clojure&rsquo;s data structures. That&rsquo;s the start of a vector on the first line, and the second line starts a map. Then we&rsquo;ve got string keys like <code>&quot;icpsr_study_number&quot;</code>, and values which look like <code>null</code> (<code>nil</code>), numbers, or strings. But in order to <em>work</em> with this file, we&rsquo;ll need to <em>parse</em> it into Clojure data structures. For that, we can use a JSON parsing library, like <a href="https://github.com/dakrone/cheshire">Cheshire</a>.</p>

<p>Cheshire, like most Clojure libraries, is published on an internet repository called <a href="http://clojars.org">Clojars</a>. To include it in our scratch project, all we have to do is add open <code>project.clj</code> in a text editor, and add a line specifying that we want to use a particular version of Cheshire.</p>
<code class="block"><span class="p">(</span><span class="kd">defproject </span><span class="nv">scratch</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span>
  <span class="ss">:description</span> <span class="s">&quot;Just playing around&quot;</span>
  <span class="ss">:url</span> <span class="s">&quot;http://example.com/FIXME&quot;</span>
  <span class="ss">:license</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Eclipse Public License&quot;</span>
            <span class="ss">:url</span> <span class="s">&quot;http://www.eclipse.org/legal/epl-v10.html&quot;</span><span class="p">}</span>
  <span class="ss">:dependencies</span> <span class="p">[[</span><span class="nv">org.clojure/clojure</span> <span class="s">&quot;1.5.1&quot;</span><span class="p">]</span>
                 <span class="p">[</span><span class="nv">cheshire</span> <span class="s">&quot;5.3.1&quot;</span><span class="p">]])</span>
</code>
<p>Now we&rsquo;ll exit the REPL with Control+D (^D), and restart it with <code>lein repl</code>. Leiningen, the Clojure package manager, will automatically download Cheshire from Clojars and make it available in the new REPL session.</p>

<p>Now let&rsquo;s figure out how to parse the JSON file. Looking at <a href="https://github.com/dakrone/cheshire">Cheshire&rsquo;s README</a> shows an example that looks helpful:</p>
<code class="block"><span class="c1">;; parse some json and get keywords back</span>
<span class="p">(</span><span class="nf">parse-string</span> <span class="s">&quot;{\&quot;foo\&quot;:\&quot;bar\&quot;}&quot;</span> <span class="nv">true</span><span class="p">)</span>
<span class="c1">;; =&gt; {:foo &quot;bar&quot;}</span>
</code>
<p>So Cheshire includes a parse-string function which can take a string and return a data structure. How can we get a string out of a file? Using <code>slurp</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;cheshire.core</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;2008.json&quot;</span><span class="p">))</span>
<span class="nv">...</span>
</code>
<p>Woooow, that&rsquo;s a lot of data! Let&rsquo;s chop it down to something more manageable. How about the first entry?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;2008.json&quot;</span><span class="p">)))</span>
<span class="p">{</span><span class="s">&quot;syntheticdrug_salemanufacture&quot;</span> <span class="mi">1</span>, <span class="s">&quot;all_other_offenses_except_traffic&quot;</span> <span class="mi">900</span>, <span class="s">&quot;arson&quot;</span> <span class="mi">3</span>, <span class="nv">...</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;2008.json&quot;</span> <span class="nb">slurp </span><span class="nv">parse-string</span> <span class="nv">first</span><span class="p">)</span>
</code>
<p>It&rsquo;d be nicer if this data used keywords instead of strings for its keys. Let&rsquo;s use the second argument to Chesire&rsquo;s <code>parse-string</code> to convert all the keys in maps to keywords.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nf">parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;2008.json&quot;</span><span class="p">)</span> <span class="nv">true</span><span class="p">))</span>
<span class="p">{</span><span class="ss">:other_assaults</span> <span class="mi">288</span>, <span class="ss">:gambling_all_other</span> <span class="mi">0</span>, <span class="ss">:arson</span> <span class="mi">3</span>, <span class="nv">...</span> <span class="ss">:drunkenness</span> <span class="mi">108</span><span class="p">}</span>
</code>
<p>Since we&rsquo;re going to be working with this dataset over and over again, let&rsquo;s bind it to a variable for easy re-use.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">data</span> <span class="p">(</span><span class="nf">parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;2008.json&quot;</span><span class="p">)</span> <span class="nv">true</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/data</span>
</code>
<p>Now we&rsquo;ve got a big long vector of counties, each represented by a map&ndash;but we&rsquo;re just interested in the <em>DUIs</em> of each one. What does that look like? Let&rsquo;s <em>map</em> each county to its <code>:driving_under_influence</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">))</span>
<span class="p">(</span><span class="mi">198</span> <span class="mi">1095</span> <span class="mi">114</span> <span class="mi">98</span> <span class="mi">135</span> <span class="mi">4</span> <span class="mi">122</span> <span class="mi">587</span> <span class="mi">204</span> <span class="mi">53</span> <span class="mi">177</span> <span class="nv">...</span>
</code>
<p>What&rsquo;s the most any county has ever reported?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="p">(</span><span class="nb">apply </span><span class="nv">max</span><span class="p">))</span>
<span class="mi">45056</span>
</code>
<p>45056 counts in one year? Wow! What about the second-worst county? The easiest way to find the <em>top n</em> counties is to <em>sort</em> the list, then look at the final elements.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="nb">sort </span><span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">8589</span> <span class="mi">10432</span> <span class="mi">10443</span> <span class="mi">10814</span> <span class="mi">11439</span> <span class="mi">13983</span> <span class="mi">17572</span> <span class="mi">18562</span> <span class="mi">26235</span> <span class="mi">45056</span><span class="p">)</span>
</code>
<p>So the top 10 counties range from 8549 counts to 45056 counts. What&rsquo;s the <em>most common</em> count? Clojure comes with a built-in function called <code>frequencies</code> which takes a sequence of elements, and returns a map from each element to how many times it appeared in the sequence.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="nv">frequencies</span><span class="p">)</span>
<span class="p">{</span><span class="mi">0</span> <span class="mi">227</span>, <span class="mi">1024</span> <span class="mi">1</span>, <span class="mi">45056</span> <span class="mi">1</span>, <span class="mi">32</span> <span class="mi">15</span>, <span class="mi">2080</span> <span class="mi">1</span>, <span class="mi">64</span> <span class="mi">12</span> <span class="nv">...</span>
</code>
<p>Now let&rsquo;s take those [drunk-driving, frequency] pairs and sort them by key to produce a <em>histogram</em>. <code>sort-by</code> takes a function to apply to each element in the collection&ndash;in this case, a key-value pair&ndash;and returns something that can be sorted, like a number. We&rsquo;ll choose the <code>key</code> function to extract the key from each key-value pair, effectively sorting the counties by number of reported incidents.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="nv">frequencies</span> <span class="p">(</span><span class="nb">sort-by </span><span class="nv">key</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">([</span><span class="mi">0</span> <span class="mi">227</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span> <span class="mi">24</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">2</span> <span class="mi">17</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">3</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">4</span> <span class="mi">17</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">5</span> <span class="mi">24</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">6</span> <span class="mi">23</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">7</span> <span class="mi">23</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">8</span> <span class="mi">17</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">9</span> <span class="mi">19</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10</span> <span class="mi">29</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">12</span> <span class="mi">18</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">13</span> <span class="mi">21</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">14</span> <span class="mi">25</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">15</span> <span class="mi">13</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">16</span> <span class="mi">18</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">17</span> <span class="mi">16</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">18</span> <span class="mi">17</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">19</span> <span class="mi">11</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">20</span> <span class="mi">8</span><span class="p">]</span>
 <span class="nv">...</span>
</code>
<p>So a ton of counties (227 out of 3172 total) report no drunk driving; a few hundred have one incident, a moderate number have 10-20, and it falls off from there. This is a common sort of shape in statistics; often a hallmark of an exponential distribution.</p>

<p>How about the 10 worst counties, all the way out on the end of the curve?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="nv">frequencies</span> <span class="p">(</span><span class="nb">sort-by </span><span class="nv">key</span><span class="p">)</span> <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">([</span><span class="mi">8589</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10432</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10443</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10814</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11439</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">13983</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">17572</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">18562</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">26235</span> <span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">45056</span> <span class="mi">1</span><span class="p">])</span>
</code>
<p>So it looks like 45056 is high, but there are 8 other counties with tens of thousands of reports too. Let&rsquo;s back up to the original dataset, and sort it by DUIs:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">({</span><span class="ss">:other_assaults</span> <span class="mi">3096</span>,
  <span class="ss">:gambling_all_other</span> <span class="mi">3</span>,
  <span class="ss">:arson</span> <span class="mi">106</span>,
  <span class="ss">:have_stolen_property</span> <span class="mi">698</span>,
  <span class="ss">:syntheticdrug_salemanufacture</span> <span class="mi">0</span>,
  <span class="ss">:icpsr_sequential_case_id_number</span> <span class="mi">220</span>,
  <span class="ss">:drug_abuse_salemanufacture</span> <span class="mi">1761</span>,
  <span class="nv">...</span>
</code>
<p>What we&rsquo;re looking for is the county names, but it&rsquo;s a little hard to read these enormous maps. Let&rsquo;s take a look at just the keys that define each county, and see which ones might be useful. We&rsquo;ll take this list of counties, map each one to a list of its keys, and concatenate those lists together into one big long list. <code>mapcat</code> maps and concatenates in a single step. We expect the same keys to show up over and over again, so we&rsquo;ll remove duplicates by merging all those keys <code>into</code> a <code>sorted-set</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">mapcat </span><span class="nv">keys</span><span class="p">)</span> <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">sorted-set</span><span class="p">))</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:aggravated_assaults</span> <span class="ss">:all_other_offenses_except_traffic</span> <span class="ss">:arson</span>
  <span class="ss">:auto_thefts</span> <span class="ss">:bookmaking_horsesport</span> <span class="ss">:burglary</span> <span class="ss">:county_population</span>
  <span class="ss">:coverage_indicator</span> <span class="ss">:curfew_loitering_laws</span> <span class="ss">:disorderly_conduct</span>
  <span class="ss">:driving_under_influence</span> <span class="ss">:drug_abuse_salemanufacture</span>
  <span class="ss">:drug_abuse_violationstotal</span> <span class="ss">:drug_possession_other</span>
  <span class="ss">:drug_possession_subtotal</span> <span class="ss">:drunkenness</span> <span class="ss">:embezzlement</span>
  <span class="ss">:fips_county_code</span> <span class="ss">:fips_state_code</span> <span class="ss">:forgerycounterfeiting</span> <span class="ss">:fraud</span>
  <span class="ss">:gambling_all_other</span> <span class="ss">:gambling_total</span> <span class="ss">:grand_total</span>
  <span class="ss">:have_stolen_property</span> <span class="ss">:icpsr_edition_number</span> <span class="ss">:icpsr_part_number</span>
  <span class="ss">:icpsr_sequential_case_id_number</span> <span class="ss">:icpsr_study_number</span> <span class="ss">:larceny</span>
  <span class="ss">:liquor_law_violations</span> <span class="ss">:marijuana_possession</span>
  <span class="ss">:marijuanasalemanufacture</span> <span class="ss">:multicounty_jurisdiction_flag</span> <span class="ss">:murder</span>
  <span class="ss">:number_of_agencies_in_county</span> <span class="ss">:numbers_lottery</span>
  <span class="ss">:offenses_against_family_child</span> <span class="ss">:opiumcocaine_possession</span>
  <span class="ss">:opiumcocainesalemanufacture</span> <span class="ss">:other_assaults</span> <span class="ss">:otherdang_nonnarcotics</span>
  <span class="ss">:part_1_total</span> <span class="ss">:property_crimes</span> <span class="ss">:prostitutioncomm_vice</span> <span class="ss">:rape</span> <span class="ss">:robbery</span>
  <span class="ss">:runaways</span> <span class="ss">:sex_offenses</span> <span class="ss">:suspicion</span> <span class="ss">:synthetic_narcoticspossession</span>
  <span class="ss">:syntheticdrug_salemanufacture</span> <span class="ss">:vagrancy</span> <span class="ss">:vandalism</span> <span class="ss">:violent_crimes</span>
  <span class="ss">:weapons_violations</span><span class="p">}</span>
</code>
<p>Ah, <code>:fips_county_code</code> and <code>:fips_state_code</code> look promising. Let&rsquo;s compact the dataset to just drunk driving and those codes, using <code>select-keys</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">data</span> <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span> <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">select-keys </span><span class="nv">%</span> <span class="p">[</span><span class="ss">:driving_under_influence</span> <span class="ss">:fips_county_code</span> <span class="ss">:fips_state_code</span><span class="p">]))</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">({</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;067&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">8589</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;48&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;201&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10432</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;32&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;003&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10443</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;065&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10814</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;53&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;033&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">11439</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;071&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">13983</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;059&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">17572</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;073&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">18562</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;04&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;013&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">26235</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;037&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">45056</span><span class="p">})</span>
</code>
<p>Now we&rsquo;re getting somewhere&ndash;but we need a way to interpret these state and county codes. Googling for &ldquo;FIPS&rdquo; led me to Wikipedia&rsquo;s account of the <a href="http://en.wikipedia.org/wiki/FIPS_county_code">FIPS county code system</a>, and the NOAA&rsquo;s ERDDAP service, which has a table <a href="http://coastwatch.pfeg.noaa.gov/erddap/convert/fipscounty.html">mapping FIPS codes to state and county names</a>. Let&rsquo;s save that file as <a href="http://coastwatch.pfeg.noaa.gov/erddap/convert/fipscounty.json">fips.json</a>.</p>

<p>Now we&rsquo;ll slurp that file into the REPL and parse it, just like we did with the crime dataset.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">fips</span> <span class="p">(</span><span class="nf">parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;fips.json&quot;</span><span class="p">)</span> <span class="nv">true</span><span class="p">))</span>
</code>
<p>Let&rsquo;s take a quick look at the structure of this data:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">keys </span><span class="nv">fips</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:table</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">keys </span><span class="p">(</span><span class="ss">:table</span> <span class="nv">fips</span><span class="p">))</span>
<span class="p">(</span><span class="ss">:columnNames</span> <span class="ss">:columnTypes</span> <span class="ss">:rows</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">fips</span> <span class="ss">:table</span> <span class="ss">:columnNames</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;FIPS&quot;</span> <span class="s">&quot;Name&quot;</span><span class="p">]</span>
</code>
<p>Great, so we expect the rows to be a list of FIPS code and Name.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">fips</span> <span class="ss">:table</span> <span class="ss">:rows</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span><span class="p">)</span> <span class="nv">pprint</span><span class="p">)</span>
<span class="p">([</span><span class="s">&quot;02000&quot;</span> <span class="s">&quot;AK&quot;</span><span class="p">]</span>
 <span class="p">[</span><span class="s">&quot;02013&quot;</span> <span class="s">&quot;AK, Aleutians East&quot;</span><span class="p">]</span>
 <span class="p">[</span><span class="s">&quot;02016&quot;</span> <span class="s">&quot;AK, Aleutians West&quot;</span><span class="p">])</span>
</code>
<p>Perfect. Now that&rsquo;s we&rsquo;ve done some exploratory work in the REPL, let&rsquo;s shift back to an editor. Create a new file in <code>src/scratch/crime.clj</code>:</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.crime</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">cheshire.core</span> <span class="ss">:as</span> <span class="nv">json</span><span class="p">]))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">fips</span>
  <span class="s">&quot;A map of FIPS codes to their county names.&quot;</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">json/parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;fips.json&quot;</span><span class="p">)</span> <span class="nv">true</span><span class="p">)</span>
       <span class="ss">:table</span>
       <span class="ss">:rows</span>
       <span class="p">(</span><span class="nb">into </span><span class="p">{})))</span>
</code>
<p>We&rsquo;re just taking a snippet we wrote in the REPL&ndash;parsing the FIPS dataset&ndash;and writing it down for use as a part of a bigger program. We use <code>(into {})</code> to convert the sequence of <code>[fips, name]</code> pairs into a map, just like we used <code>into (sorted-set)</code> to merge a list of keywords into a set earlier. <code>into</code> works just like <code>conj</code>, repeated over and over again, and is an incredibly useful tool for building up collections of things.</p>

<p>Back in the REPL, let&rsquo;s check if that worked:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.crime</span> <span class="ss">:reload</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">fips</span> <span class="s">&quot;10001&quot;</span><span class="p">)</span>
<span class="s">&quot;DE, Kent&quot;</span>
</code>
<p>Remember, maps act like functions in Clojure, so we can use the <code>fips</code> map to look up the names of counties efficiently.</p>

<p>We also have to load the UCR crime file&ndash;so let&rsquo;s split that load-and-parse code into its own function:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">load-json</span>
  <span class="s">&quot;Given a filename, reads a JSON file and returns it, parsed, with keywords.&quot;</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">json/parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="nv">file</span><span class="p">)</span> <span class="nv">true</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">fips</span>
  <span class="s">&quot;A map of FIPS codes to their county names.&quot;</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="s">&quot;fips.json&quot;</span>
       <span class="nv">load-json</span>
       <span class="ss">:table</span>
       <span class="ss">:rows</span>
       <span class="p">(</span><span class="nb">into </span><span class="p">{})))</span>
</code>
<p>Now we can re-use <code>load-json</code> to load the UCR crime file.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">most-duis</span>
  <span class="s">&quot;Given a JSON filename of UCR crime data for a particular year, finds the</span>
<span class="s">  counties with the most DUIs.&quot;</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">file</span>
       <span class="nv">load-json</span>
       <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">select-keys </span><span class="nv">%</span> <span class="p">[</span><span class="ss">:driving_under_influence</span>
                             <span class="ss">:fips_county_code</span>
                             <span class="ss">:fips_state_code</span><span class="p">]))))</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.crime</span> <span class="ss">:reload</span><span class="p">)</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">most-duis</span> <span class="s">&quot;2008.json&quot;</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="p">({</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;067&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">8589</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;48&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;201&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10432</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;32&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;003&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10443</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;065&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">10814</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;53&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;033&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">11439</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;071&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">13983</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;059&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">17572</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;073&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">18562</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;04&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;013&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">26235</span><span class="p">}</span>
 <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;06&quot;</span>,
  <span class="ss">:fips_county_code</span> <span class="s">&quot;037&quot;</span>,
  <span class="ss">:driving_under_influence</span> <span class="mi">45056</span><span class="p">})</span>
</code>
<p>Almost there. We need to join together the state and county FIPS codes into a single string, because that&rsquo;s how <code>fips</code> represents the county code:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">fips-code</span>
  <span class="s">&quot;Given a county (a map with :fips_state_code and :fips_county_code keys),</span>
<span class="s">   returns the five-digit FIPS code for the county, as a string.&quot;</span>
  <span class="p">[</span><span class="nv">county</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:fips_state_code</span> <span class="nv">county</span><span class="p">)</span> <span class="p">(</span><span class="ss">:fips_county_code</span> <span class="nv">county</span><span class="p">)))</span>
</code>
<p>Let&rsquo;s write a quick test in <code>test/scratch/crime_test.clj</code> to verify that function works correctly:</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.crime-test</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.test</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
            <span class="p">[</span><span class="nv">scratch.crime</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>

<span class="p">(</span><span class="nf">deftest</span> <span class="nv">fips-code-test</span>
  <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="s">&quot;12345&quot;</span> <span class="p">(</span><span class="nf">fips-code</span> <span class="p">{</span><span class="ss">:fips_state_code</span> <span class="s">&quot;12&quot;</span> <span class="ss">:fips_county_code</span> <span class="s">&quot;345&quot;</span><span class="p">}))))</span>
</code><code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein test scratch.crime-test

lein test scratch.crime-test

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.</code>
<p>Great. Note that <code>lein test some-namespace</code> runs only the tests in that particular namespace. For the last step, let&rsquo;s take the <code>most-duis</code> function and, using <code>fips</code> and <code>fips-code</code>, construct a map of county names to DUI reports.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">most-duis</span>
  <span class="s">&quot;Given a JSON filename of UCR crime data for a particular year, finds the</span>
<span class="s">  counties with the most DUIs.&quot;</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">file</span>
       <span class="nv">load-json</span>
       <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">county</span><span class="p">]</span>
              <span class="p">[(</span><span class="nf">fips</span> <span class="p">(</span><span class="nf">fips-code</span> <span class="nv">county</span><span class="p">))</span>
               <span class="p">(</span><span class="ss">:driving_under_influence</span> <span class="nv">county</span><span class="p">)]))</span>
       <span class="p">(</span><span class="nb">into </span><span class="p">{})))</span>
</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;scratch.crime</span> <span class="ss">:reload</span><span class="p">)</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">most-duis</span> <span class="s">&quot;2008.json&quot;</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="p">{</span><span class="s">&quot;CA, Orange&quot;</span> <span class="mi">17572</span>,
 <span class="s">&quot;CA, San Bernardino&quot;</span> <span class="mi">13983</span>,
 <span class="s">&quot;CA, Los Angeles&quot;</span> <span class="mi">45056</span>,
 <span class="s">&quot;CA, Riverside&quot;</span> <span class="mi">10814</span>,
 <span class="s">&quot;NV, Clark&quot;</span> <span class="mi">10443</span>,
 <span class="s">&quot;WA, King&quot;</span> <span class="mi">11439</span>,
 <span class="s">&quot;AZ, Maricopa&quot;</span> <span class="mi">26235</span>,
 <span class="s">&quot;CA, San Diego&quot;</span> <span class="mi">18562</span>,
 <span class="s">&quot;TX, Harris&quot;</span> <span class="mi">10432</span>,
 <span class="s">&quot;CA, Sacramento&quot;</span> <span class="mi">8589</span><span class="p">}</span>
</code>
<p>Our question is, at least in part, answered: Los Angeles and Maricopa counties, in California and Arizona, have the most reports of drunk driving out of any counties in the 2008 Uniform Crime Reporting database. These might be good counties for a PSA campaign. California has either lots of drunk drivers, or aggressive enforcement, or both! Remember, this only tells us about <em>reports</em> of crimes; not the crimes themselves. Numbers vary based on how the state enforces the laws!</p>
<code class="block"><span class="p">(</span><span class="kd">ns </span><span class="nv">scratch.crime</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">cheshire.core</span> <span class="ss">:as</span> <span class="nv">json</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">load-json</span>
  <span class="s">&quot;Given a filename, reads a JSON file and returns it, parsed, with keywords.&quot;</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">json/parse-string</span> <span class="p">(</span><span class="nb">slurp </span><span class="nv">file</span><span class="p">)</span> <span class="nv">true</span><span class="p">))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">fips</span>
  <span class="s">&quot;A map of FIPS codes to their county names.&quot;</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="s">&quot;fips.json&quot;</span>
       <span class="nv">load-json</span>
       <span class="ss">:table</span>
       <span class="ss">:rows</span>
       <span class="p">(</span><span class="nb">into </span><span class="p">{})))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">fips-code</span>
  <span class="s">&quot;Given a county (a map with :fips_state_code and :fips_county_code keys),</span>
<span class="s">  returns the five-digit FIPS code for the county, as a string.&quot;</span>
  <span class="p">[</span><span class="nv">county</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:fips_state_code</span> <span class="nv">county</span><span class="p">)</span> <span class="p">(</span><span class="ss">:fips_county_code</span> <span class="nv">county</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">most-duis</span>
  <span class="s">&quot;Given a JSON filename of UCR crime data for a particular year, finds the</span>
<span class="s">  counties with the most DUIs.&quot;</span>
  <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">file</span>
       <span class="nv">load-json</span>
       <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:driving_under_influence</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">take-last</span> <span class="mi">10</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">county</span><span class="p">]</span>
              <span class="p">[(</span><span class="nf">fips</span> <span class="p">(</span><span class="nf">fips-code</span> <span class="nv">county</span><span class="p">))</span>
               <span class="p">(</span><span class="ss">:driving_under_influence</span> <span class="nv">county</span><span class="p">)]))</span>
       <span class="p">(</span><span class="nb">into </span><span class="p">{})))</span>
</code>
<h2>Recap</h2>

<p>In this chapter, we expanded beyond transient programs written in the REPL. We learned how <em>projects</em> combine static resources, code, and tests into a single package, and how projects can relate to one another through <em>dependencies</em>. We learned the basics of Clojure&rsquo;s namespace system, which isolates distinct chunks of code from one another, and how to include definitions from one namespace in another via <code>require</code> and <code>use</code>. We learned how to write and run <em>tests</em> to verify our code&rsquo;s correctness, and how to move seamlessly between the repl and code in <code>.clj</code> files. We made use of Cheshire, a Clojure library published on Clojars, to parse JSON&ndash;a common data format. Finally, we brought together our knowledge of Clojure&rsquo;s basic grammar, immutable data structures, core functions, sequences, threading macros, and vars to explore a real-world problem.</p>

<h2>Exercises</h2>

<ol>
<li><p><code>most-duis</code> tells us about the raw number of reports, but doesn&rsquo;t account for differences in county population. One would naturally expect counties with more people to have more crime! Divide the <code>:driving_under_influence</code> of each county by its <code>:county_population</code> to find a <em>prevalence</em> of DUIs, and take the top ten counties based on prevalence. How should you handle counties with a population of zero?</p></li>
<li><p>How do the prevalence counties compare to the original counties? Expand most-duis to return vectors of <code>[county-name, prevalence, report-count, population]</code> What are the populations of the high-prevalence counties? Why do you suppose the data looks this way? If you were leading a public-health campaign to reduce drunk driving, would you target your intervention based on <em>report count</em> or <em>prevalence</em>? Why?</p></li>
<li><p>We can <em>generalize</em> the <code>most-duis</code> function to handle <em>any</em> type of crime. Write a function <code>most-prevalent</code> which takes a file and a field name, like <code>:arson</code>, and finds the counties where that field is most often reported, per capita.</p></li>
<li><p>Write a test to verify that <code>most-prevalent</code> is correct.</p></li>
</ol>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/306-clojure-from-the-ground-up-state">Clojure from the ground up: state</a></h1>
    </div>
    <div class="body">
      <p><em>Previously: <a href="http://aphyr.com/posts/305-clojure-from-the-ground-up-macros">Macros</a>.</em></p>

<p>Most programs encompass <em>change</em>. People grow up, leave town, fall in love, and take new names. Engines burn through fuel while their parts wear out, and new ones are swapped in. Forests burn down and their logs become nurseries for new trees. Despite these changes, we say &ldquo;She&rsquo;s still Nguyen&rdquo;, &ldquo;That&rsquo;s my motorcycle&rdquo;, &ldquo;The same woods I hiked through as a child.&rdquo;</p>

<p>Identity is a skein we lay across the world of immutable facts; a single entity which encompasses change. In programming, identities unify different values over time. Identity types are <em>mutable references</em> to <em>immutable values</em>.</p>

<p>In this chapter, we&rsquo;ll move from immutable references to complex concurrent transactions. In the process we&rsquo;ll get a taste of <em>concurrency</em> and <em>parallelism</em>, which will motivate the use of more sophisticated identity types. These are not easy concepts, so don&rsquo;t get discouraged. You don&rsquo;t have to understand this chapter fully to be a productive programmer, but I do want to hint at <em>why</em> things work this way. As you work with state more, these concepts will solidify.</p>

<h2>Immutability</h2>

<p>The references we&rsquo;ve used in <code>let</code> bindings and function arguments are <em>immutable</em>: they never change.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span><span class="p">]</span>
         <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)))</span>
<span class="mi">2</span>
<span class="mi">2</span>
</code>
<p>The expression <code>(inc x)</code> did not <em>alter</em> <code>x</code>: <code>x</code> remained <code>1</code>. The same applies to strings, lists, vectors, maps, sets, and most everything else in Clojure:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]]</span>
         <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">conj </span><span class="nv">x</span> <span class="ss">:a</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nb">conj </span><span class="nv">x</span> <span class="ss">:b</span><span class="p">)))</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="ss">:a</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="ss">:b</span><span class="p">]</span>
</code>
<p>Immutability also extends to <code>let</code> bindings, function arguments, and other symbols. Functions <em>remember</em> the values of those symbols at the time the function was constructed.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">present</span>
  <span class="p">[</span><span class="nv">gift</span><span class="p">]</span>
  <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">gift</span><span class="p">))</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">green-box</span> <span class="p">(</span><span class="nf">present</span> <span class="s">&quot;clockwork beetle&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/green-box</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">red-box</span> <span class="p">(</span><span class="nf">present</span> <span class="s">&quot;plush tiger&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/red-box</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">red-box</span><span class="p">)</span>
<span class="s">&quot;plush tiger&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">green-box</span><span class="p">)</span>
<span class="s">&quot;clockwork beetle&quot;</span>
</code>
<p>The <code>present</code> function <em>creates a new function</em>. That function takes no arguments, and always returns the gift. Which gift? Because <code>gift</code> is not an argument to the inner function, it refers to the value from the <em>outer function body</em>. When we packaged up the red and green boxes, the functions we created carried with them a memory of the <code>gift</code> symbol&rsquo;s value.</p>

<p>This is called <em>closing over</em> the <code>gift</code> variable; the inner function is sometimes called <em>a closure</em>. In Clojure, new functions close over <em>all</em> variables except their arguments&ndash;the arguments, of course, will be provided when the function is invoked.</p>

<h2>Delays</h2>

<p>Because functions <em>close over</em> their arguments, they can be used to <em>defer</em> evaluation of expressions. That&rsquo;s how we introduced functions originally&ndash;like <code>let</code> expressions, but with a number (maybe zero!) of symbols <em>missing</em>, to be filled in at a later time.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">prn </span><span class="s">&quot;Adding&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="s">&quot;Adding&quot;</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">later</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;Adding&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/later</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">later</span><span class="p">)</span>
<span class="s">&quot;Adding&quot;</span>
<span class="mi">3</span>
</code>
<p>Evaluating <code>(def later ...)</code> did <em>not</em> evaluate the expressions in the function body. Only when we invoked the function <code>later</code> did Clojure print <code>&quot;Adding&quot;</code> to the screen, and return <code>3</code>. This is the basis of <em>concurrency</em>: evaluating expressions outside their normal, sequential order.</p>

<p>This pattern of deferring evaluation is so common that there&rsquo;s a standard macro for it, called <code>delay</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">later</span> <span class="p">(</span><span class="nf">delay</span> <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;Adding&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/later</span>
<span class="nv">user=&gt;</span> <span class="nv">later</span>
<span class="o">#</span><span class="nv">&lt;Delay</span><span class="o">@</span><span class="mi">2</span><span class="nv">dd31aac</span><span class="err">:</span> <span class="ss">:pending&gt;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">later</span><span class="p">)</span>
<span class="s">&quot;Adding&quot;</span>
<span class="mi">3</span>
</code>
<p>Instead of a function, <code>delay</code> creates a special type of Delay object: an identity which <em>refers</em> to expressions which should be evaluated later. We extract, or <em>dereference</em>, the value of that identity with <code>deref</code>. Delays follow the same rules as functions, closing over lexical scope&ndash;because <code>delay</code> actually macroexpands into an anonymous function.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">delay</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">delay</span>
  <span class="s">&quot;Takes a body of expressions and yields a Delay object that will</span>
<span class="s">  invoke the body only the first time it is forced (with force or deref/@), and</span>
<span class="s">  will cache the result and return it on all subsequent force</span>
<span class="s">  calls. See also - realized?&quot;</span>
  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span><span class="p">}</span>
  <span class="p">[</span><span class="o">&amp;</span> <span class="nv">body</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;new</span> <span class="ss">&#39;clojure.lang.Delay</span> <span class="p">(</span><span class="nb">list* </span><span class="o">`^</span><span class="p">{</span><span class="ss">:once</span> <span class="nv">true</span><span class="p">}</span> <span class="nv">fn*</span> <span class="p">[]</span> <span class="nv">body</span><span class="p">)))</span>
</code>
<p>Why the <code>Delay</code> object instead of a plain old function? Because unlike function invocation, delays only evaluate their expressions <em>once</em>. They remember their value, after the first evaluation, and return it for every successive <code>deref</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">later</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">later</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>By the way, there&rsquo;s a shortcut for <code>(deref something)</code>: the wormhole operator <code>@</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">later</span> <span class="c1">; Interpreted as (deref later)</span>
<span class="mi">3</span>
</code>
<p>Remember how <code>map</code> returned a sequence immediately, but didn&rsquo;t actually perform any computation until we asked for elements? That&rsquo;s called <em>lazy</em> evaluation. Because delays are lazy, we can avoid doing expensive operations until they&rsquo;re really needed. Like an IOU, we use delays when we aren&rsquo;t ready to do something just yet, but when someone calls in the favor, we&rsquo;ll make sure it happens.</p>

<h2>Futures</h2>

<p>What if we wanted to <em>opportunistically</em> defer computation? Modern computers have multiple cores, and operating systems let us share a core between two tasks. It would be great if we could use that multitasking ability to say, &ldquo;I don&rsquo;t need the result of evaluating these expressions <em>yet</em>, but I&rsquo;d like it <em>later</em>. Could you start working on it in the meantime?&rdquo;</p>

<p>Enter the <em>future</em>: a delay which is evaluated <em>in parallel</em>. Like delays, futures return immediately, and give us an <em>identity</em> which will point to the value of the last expression in the future&ndash;in this case, the value of <code>(+ 1 2)</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;hi&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="s">&quot;hi&quot;</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">x</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>Notice how the future printed &ldquo;hi&rdquo; right away. That&rsquo;s because futures are evaluated in a new <em>thread</em>. On multicore computers, two threads can run in <em>parallel</em>, on different cores the same time. When there are more threads than cores, the cores <em>trade off</em> running different threads. Both parallel and non-parallel evaluation of threads are <em>concurrent</em> because expressions from different threads can be evaluated out of order.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">5</span><span class="p">]</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">prn </span><span class="nv">i</span><span class="p">)))</span>
<span class="mi">14</span>

<span class="mi">3</span>
<span class="mi">0</span>
<span class="mi">2</span>
<span class="nv">nil</span>
</code>
<p>Five threads running at once. Notice that the thread printing <code>1</code> didn&rsquo;t even get to move to a new line before <code>4</code> showed up&ndash;then both threads wrote new lines at the same time. There are techniques to control this concurrent execution so that things happen in some well-defined sequence, like agents and locks, but we&rsquo;ll discuss those later.</p>

<p>Just like delays, we can deref a future as many times as we want, and the expressions are only evaluated once.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;hi&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span><span class="s">&quot;hi&quot;</span>

<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">x</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">x</span>
<span class="mi">3</span>
</code>
<p>Futures are the most generic parallel construct in Clojure. You can use futures to do CPU-intensive computation faster, to wait for multiple network requests to complete at once, or to run housekeeping code periodically.</p>

<h2>Promises</h2>

<p>Delays <em>defer</em> evaluation, and futures <em>parallelize</em> it. What if we wanted to defer something we <em>don&rsquo;t even have yet</em>? To hand someone an empty box and, later, before they open it, sneak in and replacing its contents with an actual gift? Surely I&rsquo;m not the only one who does birthday presents this way.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">box</span> <span class="p">(</span><span class="nf">promise</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/box</span>
<span class="nv">user=&gt;</span> <span class="nv">box</span>
<span class="o">#</span><span class="nv">&lt;core$promise$reify__6310</span><span class="o">@</span><span class="mi">1</span><span class="nv">d7762e</span><span class="err">:</span> <span class="ss">:pending&gt;</span>
</code>
<p>This box is <em>pending</em> a value. Like futures and delays, if we try to open it, we&rsquo;ll get <em>stuck</em> and have to wait for something to appear inside:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">box</span><span class="p">)</span>
</code>
<p>But unlike futures and delays, this box won&rsquo;t be filled automatically. Hold the <code>Control</code> key and hit <code>c</code> to give up on trying to open that package. Nobody else is in this REPL, so we&rsquo;ll have to buy our own presents.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">deliver</span> <span class="nv">box</span> <span class="ss">:live-scorpions!</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;core$promise$reify__6310</span><span class="o">@</span><span class="mi">1</span><span class="nv">d7762e</span><span class="err">:</span> <span class="ss">:live-scorpions!&gt;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">box</span><span class="p">)</span>
<span class="ss">:live-scorpions!</span>
</code>
<p>Wow, that&rsquo;s a <em>terrible</em> gift. But at least there&rsquo;s something there: when we dereference the box, it opens immediately and live scorpions skitter out. Can we get a do-over? Let&rsquo;s try a nicer gift.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">deliver</span> <span class="nv">box</span> <span class="ss">:puppy</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">box</span><span class="p">)</span>
<span class="ss">:live-scorpions!</span>
</code>
<p>Like delays and futures, there&rsquo;s no going back on our promises. Once delivered, a promise <em>always</em> refers to the same value. This is a simple identity type: we can set it to a value once, and read it as many times as we want. <code>promise</code> is also a <em>concurrency primitive</em>: it guarantees that any attempt to read the value will <em>wait</em> until the value has been written. We can use promises to <em>synchronize</em> a program which is being evaluated concurrently&ndash;for instance, this simple card game:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">card</span> <span class="p">(</span><span class="nf">promise</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/card</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">dealer</span> <span class="p">(</span><span class="nf">future</span> 
                     <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">5000</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">deliver</span> <span class="nv">card</span> <span class="p">[(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">rand-int </span><span class="mi">13</span><span class="p">))</span>
                                    <span class="p">(</span><span class="nf">rand-nth</span> <span class="p">[</span><span class="ss">:clubs</span> <span class="ss">:spades</span> <span class="ss">:hearts</span> <span class="ss">:diamonds</span><span class="p">])])))</span>
<span class="o">#</span><span class="ss">&#39;user/dealer</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">card</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span> <span class="ss">:diamonds</span><span class="p">]</span>
</code>
<p>In this program, we set up a <code>dealer</code> thread which waits for five seconds (5000 milliseconds), then delivers a random card. While the dealer is sleeping, we try to deref our card&ndash;and have to wait until the five seconds are up. Synchronization and identity in one package.</p>

<p>Where delays are lazy, and futures are parallel, promises are concurrent <em>without specifying how the evaluation occurs</em>. We control exactly when and how the value is delivered. You can think of both delays and futures as being built atop promises, in a way.</p>

<h2>Vars</h2>

<p>So far the identities we&rsquo;ve discussed have referred (eventually) to a <em>single</em> value, but the real world needs names that refer to <em>different</em> values at different points in time. For this, we use <em>vars</em>.</p>

<p>We&rsquo;ve touched on vars before&ndash;they&rsquo;re transparent mutable references. Each var has a value associated with it, and that value can change over time. When a var is evaluated, it is replaced by its <em>present</em> value transparently&ndash;everywhere in the program.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="ss">:mouse</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">box</span> <span class="p">(</span><span class="k">fn </span><span class="p">[]</span> <span class="nv">x</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/box</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">box</span><span class="p">)</span>
<span class="ss">:mouse</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="ss">:cat</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">box</span><span class="p">)</span>
<span class="ss">:cat</span>
</code>
<p>The <code>box</code> function closed over <code>x</code>&ndash;but calling <code>(box)</code> returned <em>different</em> results depending on the current value of <code>x</code>. Even though the <em>var</em> <code>x</code> remained unchanged throughout this example, the <em>value associated with that var</em> did change!</p>

<p>Using mutable vars allows us to write programs which we can redefine as we go along.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">decouple</span> <span class="p">[</span><span class="nv">glider</span><span class="p">]</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;bolts released&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/decouple</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">launch</span> <span class="p">[</span><span class="nv">glider</span><span class="p">]</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nf">decouple</span> <span class="nv">glider</span><span class="p">)</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">prn </span><span class="nv">glider</span> <span class="s">&quot;away!&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/launch</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">launch</span> <span class="s">&quot;albatross&quot;</span><span class="p">)</span>
<span class="s">&quot;bolts released&quot;</span>
<span class="s">&quot;albatross&quot;</span> <span class="s">&quot;away!&quot;</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">decouple</span> <span class="p">[</span><span class="nv">glider</span><span class="p">]</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;tether released&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/decouple</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">launch</span> <span class="s">&quot;albatross&quot;</span><span class="p">)</span>
<span class="s">&quot;tether released&quot;</span>
<span class="s">&quot;albatross&quot;</span> <span class="s">&quot;away!&quot;</span>
</code>
<p>A reference which is the same everywhere is called a <em>global variable</em>, or simply a <em>global</em>. But vars have an additional trick up their sleeve: with a <em>dynamic</em> var, we can override their value only within the scope of a particular function call, and nowhere else.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">*board*</span> <span class="ss">:maple</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/*board*</span>
</code>
<p><code>^:dynamic</code> tells Clojure that this var can be overridden in one particular scope. By convention, dynamic variables are named with asterisks around them&ndash;this reminds us, as programmers, that they are likely to change. Next, we define a function that uses that dynamic var:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">cut</span> <span class="p">[]</span> <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;sawing through&quot;</span> <span class="nv">*board*</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/cut</span>
</code>
<p>Note that <code>cut</code> closes over the var <code>*board*</code>, but not the <em>value</em> :maple. Every time the function is invoked, it looks up the <em>current</em> value of <code>*board*</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cut</span><span class="p">)</span>
<span class="s">&quot;sawing through&quot;</span> <span class="ss">:maple</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">*board*</span> <span class="ss">:cedar</span><span class="p">]</span> <span class="p">(</span><span class="nf">cut</span><span class="p">))</span>
<span class="s">&quot;sawing through&quot;</span> <span class="ss">:cedar</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cut</span><span class="p">)</span>
<span class="s">&quot;sawing through&quot;</span> <span class="ss">:maple</span>
</code>
<p>Like <code>let</code>, the <code>binding</code> macro assigns a value to a name&ndash;but where <code>fn</code> and <code>let</code> create immutable <em>lexical scope</em>, <code>binding</code> creates <em>dynamic scope</em>. The difference? Lexical scope is constrained to the literal text of the <code>fn</code> or <code>let</code> expression&ndash;but dynamic scope propagates <em>through function calls</em>.</p>

<p>Within the <code>binding</code> expression, and in every function called from that expression, and every function called from <em>those</em> functions, and so on, <code>*board*</code> has the value <code>:cedar</code>. Outside the <code>binding</code> expression, the value is still <code>:maple</code>. This safety property holds even when the program is executed in multiple threads: only the thread which evaluated the <code>binding</code> expression uses that value. Other threads are unaffected.</p>

<p>While we use <code>def</code> all the time in the REPL, in real programs you should only mutate vars sparingly. They&rsquo;re intended for naming functions, important bits of global data, and for tracking the <em>environment</em> of a program&ndash;like where to print messages with <code>prn</code>, which database to talk to, and so on. Using vars for mutable program state is a recipe for disaster, as we&rsquo;re about to see.</p>

<h2>Atoms</h2>

<p>Vars can be read, set, and dynamically bound&ndash;but they aren&rsquo;t easy to <em>evolve</em>. Imagine building up a set of integers:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="o">#</span><span class="p">{})</span>
<span class="o">#</span><span class="ss">&#39;user/xs</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">xs</span> <span class="nv">i</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="nv">xs</span>
<span class="o">#</span><span class="p">{</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">}</span>
</code>
<p>For each number from 0 to 9, we take the current set of numbers <code>xs</code>, add a particular number <code>i</code> to that set, and redefine <code>xs</code> as the result. This is a common idiom in imperative language like C, Ruby, Javascript, or Java&ndash;all variables are mutable by default.</p>
<code class="block"><span class="n">ImmutableSet</span> <span class="n">xs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ImmutableSet</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">++;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code>
<p>It seems straightforward enough, but there are serious problems lurking here. Specifically, this program is not <em>thread safe</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="o">#</span><span class="p">{})</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">xs</span> <span class="nv">i</span><span class="p">))))</span>
<span class="o">#</span><span class="ss">&#39;user/xs</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">xs</span>
<span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">}</span>
</code>
<p>This program runs 10 threads in parallel, and each reads the current value of <code>xs</code>, adds its particular number, and defines <code>xs</code> to be that new set of numbers. This read-modify-update process assumed that all updates would be <em>consecutive</em>&ndash;not <em>concurrent</em>. When we allowed the program to do two read-modify-updates at the same time, updates were lost.</p>

<ol>
<li>Thread 2 read <code>#{0 1}</code></li>
<li>Thread 3 read <code>#{0 1}</code></li>
<li>Thread 2 wrote <code>#{0 1 2}</code></li>
<li>Thread 3 wrote <code>#{0 1 3}</code></li>
</ol>

<p>This interleaving of operations allowed the number <code>2</code> to slip through the cracks. We need something stronger&ndash;an identity which supports safe transformation from one state to another. Enter *atoms.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">#</span><span class="p">{}))</span>
<span class="o">#</span><span class="ss">&#39;user/xs</span>
<span class="nv">user=&gt;</span> <span class="nv">xs</span>
<span class="o">#</span><span class="nv">&lt;Atom</span><span class="o">@</span><span class="mi">30</span><span class="nv">bb8cc9</span><span class="err">:</span> <span class="o">#</span><span class="p">{}</span><span class="nv">&gt;</span>
</code>
<p>The initial value of this atom is <code>#{}</code>. Unlike vars, atoms are not transparent. When evaluated, they don&rsquo;t return their underlying values&ndash;but notice that when printed, the current value is hiding inside. To get the current value out of an atom, we have to use <code>deref</code> or <code>@</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">xs</span><span class="p">)</span>
<span class="o">#</span><span class="p">{}</span>
<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">xs</span>
<span class="o">#</span><span class="p">{}</span>
</code>
<p>Like vars, atoms can be set to a particular value&ndash;but instead of <code>def</code>, we use <code>reset!</code>. The exclamation point (sometimes called a <em>bang</em>) is there to remind us that this function <em>modifies</em> the state of its arguments&ndash;in this case, changing the value of the atom.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reset!</span> <span class="nv">xs</span> <span class="ss">:foo</span><span class="p">)</span>
<span class="ss">:foo</span>
<span class="nv">user=&gt;</span> <span class="nv">xs</span>
<span class="o">#</span><span class="nv">&lt;Atom</span><span class="o">@</span><span class="mi">30</span><span class="nv">bb8cc9</span><span class="err">:</span> <span class="ss">:foo&gt;</span>
</code>
<p>Unlike vars, atoms can be safely <em>updated</em> using <code>swap!</code>. <code>swap!</code> uses a pure function which takes the current value of the atom and returns a <em>new</em> value. Under the hood, Clojure does some tricks to ensure that these updates are <em>linearizable</em>, which means:</p>

<ol>
<li>All updates with `swap! complete in what <em>appears</em> to be a single consecutive order.</li>
<li>The effect of a swap! never takes place before calling <code>swap!</code>.</li>
<li>The effect of a swap! is visible to everyone once swap! returns.</li>
</ol>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">atom</span> <span class="mi">0</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">x</span> <span class="nv">inc</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">x</span> <span class="nv">inc</span><span class="p">)</span>
<span class="mi">2</span>
</code>
<p>The first <code>swap!</code> reads the value <code>0</code>, calls <code>(inc 0)</code> to obtain <code>1</code>, and writes <code>1</code> back to the atom. Each call to <code>swap!</code> returns the value that was just written.</p>

<p>We can pass additional arguments to the function <code>swap!</code> calls. For instance, <code>(swap! x + 5 6)</code> will call <code>(+ x 5 6)</code> to find the new value. Now we have the tools to correct our parallel program from earlier:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">atom</span> <span class="o">#</span><span class="p">{}))</span>
<span class="o">#</span><span class="ss">&#39;user/xs</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">i</span> <span class="mi">10</span><span class="p">]</span> <span class="p">(</span><span class="nf">future</span> <span class="p">(</span><span class="nf">swap!</span> <span class="nv">xs</span> <span class="nb">conj </span><span class="nv">i</span><span class="p">)))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">xs</span>
<span class="o">#</span><span class="p">{</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">}</span>
</code>
<p>Note that the function we use to update an atom must be <em>pure</em>&ndash;must not mutate any state&ndash;because when resolving conflicts between multiple threads, Clojure might need to call the update function more than once. Clojure&rsquo;s reliance on immutable datatypes, immutable variables, and pure functions <em>enables</em> this approach to linearizable mutability. Languages which emphasize mutable datatypes need to use other constructs.</p>

<p>Atoms are the workhorse of Clojure state. They&rsquo;re lightweight, safe, fast, and flexible. You can use atoms with any immutable datatype&ndash;for instance, a map to track complex state. Reach for an atom whenever you want to update a single thing over time.</p>

<h2>Refs</h2>

<p>Atoms are a great way to represent state, but they are only linearizable <em>individually</em>. Updates to an atom aren&rsquo;t well-ordered with respect to other atoms, so if we try to update more than one atom at once, we could see the same kinds of bugs that we did with vars.</p>

<p>For multi-identity updates, we need a stronger safety property than single-atom linearizability. We want <em>serializability</em>: a global order. For this, Clojure has an identity type called a <em>Ref</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="nv">x</span>
<span class="o">#</span><span class="nv">&lt;Ref</span><span class="o">@</span><span class="mi">1835</span><span class="nv">d850</span><span class="err">:</span> <span class="mi">0</span><span class="nv">&gt;</span>
</code>
<p>Like all identity types, refs are dereferencable:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">x</span>
<span class="mi">0</span>
</code>
<p>But where atoms are updated individually with <code>swap!</code>, refs are updated in <em>groups</em> using <code>dosync</code> transactions. Just as we <code>reset!</code> an atom, we can set refs to new values using <code>ref-set</code>&ndash;but unlike atoms, we can change more than one ref at once.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">dosync</span>
         <span class="p">(</span><span class="nb">ref-set </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">ref-set </span><span class="nv">y</span> <span class="mi">2</span><span class="p">))</span>
<span class="mi">2</span>
<span class="nv">user=&gt;</span> <span class="p">[</span><span class="o">@</span><span class="nv">x</span> <span class="o">@</span><span class="nv">y</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</code>
<p>The equivalent of <code>swap!</code>, for a ref, is <code>alter</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">1</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">y</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">2</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">dosync</span>
         <span class="p">(</span><span class="nb">alter </span><span class="nv">x</span> <span class="nb">+ </span><span class="mi">2</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">alter </span><span class="nv">y</span> <span class="nv">inc</span><span class="p">))</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">[</span><span class="o">@</span><span class="nv">x</span> <span class="o">@</span><span class="nv">y</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span> <span class="mi">3</span><span class="p">]</span>
</code>
<p>All <code>alter</code> operations within a <code>dosync</code> take place atomically&ndash;their effects are never interleaved with other transactions. If it&rsquo;s OK for an operation to take place out of order, you can use <code>commute</code> instead of <code>alter</code> for a performance boost:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">dosync</span>
         <span class="p">(</span><span class="nb">commute </span><span class="nv">x</span> <span class="nb">+ </span><span class="mi">2</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">commute </span><span class="nv">y</span> <span class="nv">inc</span><span class="p">))</span>
</code>
<p>These updates are <em>not</em> guaranteed to take place in the same order&ndash;but if all our transactions are equivalent, we can <em>relax</em> the ordering constraints. x + 2 + 3 is equal to x + 3 + 2, so we can do the additions in either order. That&rsquo;s what <em>commutative</em> means: the same result from all orders. It&rsquo;s a weaker, but faster kind of safety property.</p>

<p>Finally, if you want to read a value from one ref and use it to update another, use <code>ensure</code> instead of <code>deref</code> to perform a <em>strongly consistent read</em>&ndash;one which is guaranteed to take place in the same logical order as the <code>dosync</code> transaction itself. To add <code>y</code>&rsquo;s current value to <code>x</code>, use:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">dosync</span>
         <span class="p">(</span><span class="nb">alter </span><span class="nv">x</span> <span class="nb">+ </span><span class="p">(</span><span class="nb">ensure </span><span class="nv">y</span><span class="p">)))</span>
</code>
<p>Refs are a powerful construct, and make it easier to write complex transactional logic safely. However, that safety comes at a cost: refs are typically an order of magnitude slower to update than atoms.</p>

<p>Use refs only where you need to update multiple pieces of state independently&ndash;specifically, where different transactions need to work with distinct but <em>partly overlapping</em> pieces of state. If there&rsquo;s no overlap between updates, use distinct atoms. If all operations update the same identities, use a single atom to hold a map of the system&rsquo;s state. If a system requires complex interlocking state spread throughput the program&ndash;that&rsquo;s when to reach for refs.</p>

<h2>Summary</h2>

<p>We moved beyond immutable programs into the world of <em>changing state</em>&ndash;and discovered the challenges of concurrency and parallelism. Where symbols provide immutable and transparent names for values objects, Vars provide <em>mutable</em> transparent names. We also saw a host of anonymous identity types for different purposes: delays for lazy evaluation, futures for parallel evaluation, and promises for arbitrary handoff of a value. Updates to vars are unsafe, so atoms and refs provide linearizable and serializable identities where transformations are <em>safe</em>.</p>

<p>Where reading a symbol or var is <em>transparent</em>&ndash;they evaluate directly to their current values&ndash;reading these new identity types requires the use of <code>deref</code>. Delays, futures, and promises <em>block</em>: deref must wait until the value is ready. This allows synchronization of concurrent threads. Atoms and refs, by contrast, can be read immediately at any time&ndash;but <em>updating</em> their values should occur within a <code>swap!</code> or <code>dosync</code> transaction, respectively.</p>

<table>
<thead>
<th>Type</th>
<th>Mutability</th>
<th>Reads</th>
<th>Updates</th>
<th>Evaluation</th>
<th>Scope</th>
</thead>
<tbody>
<tr>
  <td>Symbol</td>
  <td>Immutable</td>
  <td>Transparent</td>
  <td></td>
  <td></td>
  <td>Lexical</td>
</tr>
<tr>
  <td>Var</td>
  <td>Mutable</td>
  <td>Transparent</td>
  <td>Unrestricted</td>
  <td></td>
  <td>Global/Dynamic</td>
</tr>
<tr>
  <td>Delay</td>
  <td>Mutable</td>
  <td>Blocking</td>
  <td>Once only</td>
  <td>Lazy</td>
  <td></td>
</tr>
<tr>
  <td>Future</td>
  <td>Mutable</td>
  <td>Blocking</td>
  <td>Once only</td>
  <td>Parallel</td>
  <td></td>
</tr>
<tr>
  <td>Promise</td>
  <td>Mutable</td>
  <td>Blocking</td>
  <td>Once only</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>Atom</td>
  <td>Mutable</td>
  <td>Nonblocking</td>
  <td>Linearizable</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>Ref</td>
  <td>Mutable</td>
  <td>Nonblocking</td>
  <td>Serializable</td>
  <td></td>
  <td></td>
</tr>
</tbody>
</table>

<p>State is undoubtedly the hardest part of programming, and this chapter probably felt overwhelming! On the other hand, we&rsquo;re now equipped to solve serious problems. We&rsquo;ll take a break to apply what we&rsquo;ve learned through practical examples, in Chapter Seven: <a href="http://aphyr.com/posts/311-clojure-from-the-ground-up-logistics">Logistics</a>.</p>

<h2>Exercises</h2>

<p>Finding the sum of the first 10000000 numbers takes about 1 second on my machine:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">start</span> <span class="nv">end</span><span class="p">]</span> <span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">range </span><span class="nv">start</span> <span class="nv">end</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">sum</span> <span class="mi">0</span> <span class="mi">1</span><span class="nv">e7</span><span class="p">))</span>
<span class="s">&quot;Elapsed time: 1001.295323 msecs&quot;</span>
<span class="mi">49999995000000</span>
</code>
<ol>
<li><p>Use <code>delay</code> to compute this sum lazily; show that it takes no time to return the delay, but roughly 1 second to <code>deref</code>.</p></li>
<li><p>We can do the computation in a new thread directly, using <code>(.start (Thread. (fn [] (sum 0 1e7)))</code>&ndash;but this simply runs the <code>(sum)</code> function and discards the results. Use a promise to hand the result back out of the thread. Use this technique to write your own version of the <code>future</code> macro.</p></li>
<li><p>If your computer has two cores, you can do this expensive computation twice as fast by splitting it into two parts: <code>(sum 0 (/ 1e7 2))</code>, and <code>(sum (/ 1e7 2) 1e7)</code>, then adding those parts together. Use <code>future</code> to do both parts at once, and show that this strategy gets the same answer as the single-threaded version, but takes roughly half the time.</p></li>
<li><p>Instead of using <code>reduce</code>, store the sum in an atom and use two futures to add each number from the lower and upper range to that atom. Wait for both futures to complete using <code>deref</code>, then check that the atom contains the right number. Is this technique faster or slower than <code>reduce</code>? Why do you think that might be?</p></li>
<li><p>Instead of using a lazy list, imagine two threads are removing tasks from a pile of work. Our work pile will be the list of all integers from 0 to 10000:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">work</span> <span class="p">(</span><span class="nb">ref </span><span class="p">(</span><span class="nb">apply list </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span><span class="nv">e5</span><span class="p">))))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="o">@</span><span class="nv">work</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>And the sum will be a ref as well:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">sum</span> <span class="p">(</span><span class="nb">ref </span><span class="mi">0</span><span class="p">))</span>
</code>
<p>Write a function which, in a <code>dosync</code> transaction, removes the first number in <code>work</code> and adds it to <code>sum</code>.<br>
Then, in two futures, call that function over and over again until there&rsquo;s no work left. Verify that <code>@sum</code> 
is <code>4999950000</code>. Experiment with different combinations of <code>alter</code> and <code>commute</code>&ndash;if both are correct, is 
one faster? Does using <code>deref</code> instead of <code>ensure</code> change the result?</p></li>
</ol>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/305-clojure-from-the-ground-up-macros">Clojure from the ground up: macros</a></h1>
    </div>
    <div class="body">
      <p>In <a href="/posts/301-clojure-from-the-ground-up-welcome">Chapter 1</a>, I asserted that the grammar of Lisp is uniform: every expression is a list, beginning with a verb, and followed by some arguments. Evaluation proceeds from left to right, and every element of the list must be evaluated <em>before</em> evaluating the list itself. Yet we just saw, at the end of <a href="/posts/304-clojure-from-the-ground-up-sequences">Sequences</a>, an expression which seemed to <em>violate</em> these rules.</p>

<p>Clearly, this is not the whole story.</p>

<h2>Macroexpansion</h2>

<p>There is another phase to evaluating an expression; one which takes place before the rules we&rsquo;ve followed so far. That process is called <em>macro-expansion</em>. During macro-expansion, the <em>code itself</em> is restructured according to some set of rules&ndash;rules which you, the programmer, can define.</p>
<code class="block"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">ignore</span>
  <span class="s">&quot;Cancels the evaluation of an expression, returning nil instead.&quot;</span>
  <span class="p">[</span><span class="nv">expr</span><span class="p">]</span>
  <span class="nv">nil</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ignore</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">nil</span>
</code>
<p><code>defmacro</code> looks a lot like <code>defn</code>: it has a name, an optional documentation string, an argument vector, and a body&ndash;in this case, just <code>nil</code>. In this case, it looks like it simply ignored the expr <code>(+ 1 2)</code> and returned <code>nil</code>&ndash;but it&rsquo;s actually deeper than that. <code>(+ 1 2)</code> was <em>never evaluated at all</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="nv">x</span>
<span class="mi">1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ignore</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="nv">x</span>
<span class="mi">1</span>
</code>
<p><code>def</code> should have defined <code>x</code> to be <code>2</code> <em>no matter what</em>&ndash;but that never happened. At macroexpansion time, the expression <code>(ignore (+ 1 2))</code> was <em>replaced</em> by the expression <code>nil</code>, which was then evaluated to <code>nil</code>. Where functions rewrite <em>values</em>, macros rewrite <em>code</em>.</p>

<p>To see these different layers in play, let&rsquo;s try a macro which reverses the order of arguments to a function.</p>
<code class="block"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">rev</span> <span class="p">[</span><span class="nv">fun</span> <span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cons </span><span class="nv">fun</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">args</span><span class="p">)))</span>
</code>
<p>This macro, named <code>rev</code>, takes one mandatory argument: a function. Then it takes any number of arguments, which are collected in the list <code>args</code>. It constructs a new list, starting with the function, and followed by the arguments, in reverse order.</p>

<p>First, we macro-expand:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">rev</span> <span class="nb">str </span><span class="s">&quot;hi&quot;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
</code>
<p>So the <code>rev</code> macro took <code>str</code> as the function, and <code>&quot;hi&quot;</code> and <code>(+ 1 2)</code> as the arguments; then constructed a new list with the same function, but the arguments reversed. When we <em>evaluate</em> that expression, we get:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">eval </span><span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">rev</span> <span class="nb">str </span><span class="s">&quot;hi&quot;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
<span class="s">&quot;3hi&quot;</span>
</code>
<p><code>macroexpand</code> takes an expression and returns that expression with all macros expanded. <code>eval</code> takes an expression and evaluates it. When you type an unquoted expression into the REPL, Clojure macroexpands, then evaluates. Two stages&ndash;the first transforming <em>code</em>, the second transforming <em>values</em>.</p>

<h2>Across languages</h2>

<p>Some languages have a <em>metalanguage</em>: a language for extending the language itself. In C, for example, macros are implemented by the <a href="http://www.rt-embedded.com/blog/archives/macros-in-the-c-programming-language/">C preprocessor</a>, which has its own syntax for defining expressions, matching patterns in the source code&rsquo;s text, and replacing that text with other text. But that preprocessor is <em>not</em> C&ndash;it is a separate language entirely, with special limitations. In Clojure, the metalanguage is <em>Clojure itself</em>&ndash;the full power of the language is available to restructure programs. This is called a <em>procedural</em> macro system. Some Lisps, like Scheme, use a macro system based on templating expressions, and still others use more powerful models like <em>f-expressions</em>&ndash;but that&rsquo;s a discussion for a later time.</p>

<p>There is another key difference between Lisp macros and many other macro systems: in Lisp, the macros operate on <em>expressions</em>: the data structure of the code itself. Because Lisp code is <em>written</em> explicitly as a data structure, a tree made out of lists, this transformation is natural. You can <em>see</em> the structure of the code, which makes it easy to reason about its transformation. In the C preprocessor, macros operate only on <em>text</em>: there is no understanding of the underlying syntax. Even in languages like Scala which have syntactic macros, the fact that the code looks <em>nothing like</em> the syntax tree makes it <a href="http://docs.scala-lang.org/overviews/macros/overview.html">cumbersome</a> to truly restructure expressions.</p>

<p>When people say that Lisp&rsquo;s syntax is &ldquo;more elegant&rdquo;, or &ldquo;more beautiful&rdquo;, or &ldquo;simpler&rdquo;, this is part of what they they mean. By choosing to represent the program directly as a a data structure, we make it much easier to define complex transformations of code itself.</p>

<h2>Defining new syntax</h2>

<p>What kind of transformations are best expressed with macros?</p>

<p>Most languages encode special syntactic forms&ndash;things like &ldquo;define a function&rdquo;, &ldquo;call a function&rdquo;, &ldquo;define a local variable&rdquo;, &ldquo;if this, then that&rdquo;, and so on. In Clojure, these are called <em>special forms</em>. <code>if</code> is a special form, for instance. Its definition is built into the language core itself; it cannot be reduced into smaller parts.</p>
<code class="block"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="mi">3</span> <span class="nv">x</span><span class="p">)</span>
  <span class="s">&quot;big&quot;</span>
  <span class="s">&quot;small&quot;</span><span class="p">)</span>
</code>
<p>Or in Javascript:</p>
<code class="block"><span class="k">if</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">&quot;big&quot;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">&quot;small&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code>
<p>In Javascript, Ruby, and many other languages, these special forms are <em>fixed</em>. You cannot define your own syntax. For instance, one cannot define <code>or</code> in a language like JS or Ruby: it must be defined <em>for</em> you by the language author.</p>

<p>In Clojure, <code>or</code> is just a macro.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">or</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defmacro </span><span class="nv">or</span>
  <span class="s">&quot;Evaluates exprs one at a time, from left to right. If a form</span>
<span class="s">  returns a logical true value, or returns that value and doesn&#39;t</span>
<span class="s">  evaluate any of the other expressions, otherwise it returns the</span>
<span class="s">  value of the last expression. (or) returns nil.&quot;</span>
  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span><span class="p">}</span>
  <span class="p">([]</span> <span class="nv">nil</span><span class="p">)</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">([</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">next</span><span class="p">]</span>
      <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">or#</span> <span class="o">~</span><span class="nv">x</span><span class="p">]</span>
         <span class="p">(</span><span class="k">if </span><span class="nv">or#</span> <span class="nv">or#</span> <span class="p">(</span><span class="nb">or </span><span class="o">~@</span><span class="nv">next</span><span class="p">)))))</span>
<span class="nv">nil</span>
</code>
<p>That <code>&#96;</code> operator&ndash;that&rsquo;s called <em>syntax-quote</em>. It works just like regular quote&ndash;preventing evaluation of the following list&ndash;but with a twist: we can escape the quoting rule and substitute in regularly evaluated expressions using <em>unquote</em> (<code>~</code>), and <em>unquote-splice</em> (<code>~@</code>). Think of a syntax-quoted expression like a <em>template</em> for code, with some parts filled in by evaluated forms.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">2</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">clojure.core/inc</span> <span class="nv">user/x</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">2</span><span class="p">]</span> <span class="o">`</span><span class="p">(</span><span class="nb">inc </span><span class="o">~</span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">clojure.core/inc</span> <span class="mi">2</span><span class="p">)</span>
</code>
<p>See the difference? <code>~x</code> <em>substitutes</em> the value of x, instead of using <code>x</code> as an unevaluated symbol. This code is essentially just shorthand for something like</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">2</span><span class="p">]</span> <span class="p">(</span><span class="nb">list </span><span class="ss">&#39;clojure.core/inc</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nb">inc </span><span class="mi">2</span><span class="p">)</span>
</code>
<p>&hellip; where we explicitly constructed a new list with the quoted symbol <code>&#39;inc</code> and the current value of <code>x</code>. Syntax quote just makes it easier to read the code, since the quoted and expanded expressions have similar shapes.</p>

<p>The <code>~@</code> unquote splice works just like <code>~</code>, except it explodes a list into <em>multiple</em> expressions in the resulting form:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nf">foo</span> <span class="o">~</span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="nf">user/foo</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">user=&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nf">foo</span> <span class="o">~@</span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="nf">user/foo</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p><code>~@</code> is particularly useful when a function or macro takes an <em>arbitrary</em> number of arguments. In the definition of <code>or</code>, it&rsquo;s used to expand <code>(or a b c)</code> <em>recursively</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nb">macroexpand </span><span class="o">&#39;</span><span class="p">(</span><span class="nb">or </span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">let*</span>
 <span class="p">[</span><span class="nv">or__3943__auto__</span> <span class="nv">a</span><span class="p">]</span>
 <span class="p">(</span><span class="k">if </span><span class="nv">or__3943__auto__</span> <span class="nv">or__3943__auto__</span> <span class="p">(</span><span class="nf">clojure.core/or</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)))</span>
</code>
<p>We&rsquo;re using <code>pprint</code> (for &ldquo;pretty print&rdquo;) to make this expression easier to read. <code>(or a b c d)</code> is defined in terms of <em>if</em>: if the first element is truthy we return it; otherwise we evaluate <code>(or b c d)</code> instead, and so on.</p>

<p>The final piece of the puzzle here is that weirdly named symbol: <code>or__3943__auto__</code>. That variable was <em>automatically generated</em> by Clojure, to prevent <em>conflicts</em> with an existing variable name. Because macros rewrite code, they have to be careful not to interfere with local variables, or it could get very confusing. Whenever we need a new variable in a macro, we use <code>gensym</code> to <em>generate a new symbol</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">gensym </span><span class="s">&quot;hi&quot;</span><span class="p">)</span>
<span class="nv">hi326</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">gensym </span><span class="s">&quot;hi&quot;</span><span class="p">)</span>
<span class="nv">hi329</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">gensym </span><span class="s">&quot;hi&quot;</span><span class="p">)</span>
<span class="nv">hi332</span>
</code>
<p>Each symbol is different! If we tack on a <code>#</code> to the end of a symbol in a syntax-quoted expression, it&rsquo;ll be expanded to a particular gensym:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x#</span> <span class="mi">2</span><span class="p">]</span> <span class="nv">x#</span><span class="p">)</span>
<span class="p">(</span><span class="nf">clojure.core/let</span> <span class="p">[</span><span class="nv">x__339__auto__</span> <span class="mi">2</span><span class="p">]</span> <span class="nv">x__339__auto__</span><span class="p">)</span>
</code>
<p>Note that you can always escape this safety feature if you <em>want</em> to override local variables. That&rsquo;s called <em>symbol capture</em>, or an <em>anaphoric</em> or <em>unhygenic</em> macro. To override local symbols, just use <code>~&#39;foo</code> instead of <code>foo#</code>.</p>

<p>With all the pieces on the board, let&rsquo;s compare the <code>or</code> macro and its expansion:</p>
<code class="block"><span class="p">(</span><span class="kd">defmacro </span><span class="nv">or</span>
  <span class="s">&quot;Evaluates exprs one at a time, from left to right. If a form</span>
<span class="s">  returns a logical true value, or returns that value and doesn&#39;t</span>
<span class="s">  evaluate any of the other expressions, otherwise it returns the</span>
<span class="s">  value of the last expression. (or) returns nil.&quot;</span>
  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span><span class="p">}</span>
  <span class="p">([]</span> <span class="nv">nil</span><span class="p">)</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">([</span><span class="nv">x</span> <span class="o">&amp;</span> <span class="nv">next</span><span class="p">]</span>
      <span class="o">`</span><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">or#</span> <span class="o">~</span><span class="nv">x</span><span class="p">]</span>
         <span class="p">(</span><span class="k">if </span><span class="nv">or#</span> <span class="nv">or#</span> <span class="p">(</span><span class="nb">or </span><span class="o">~@</span><span class="nv">next</span><span class="p">)))))</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">clojure.walk/macroexpand-all</span>
                 <span class="o">&#39;</span><span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">mossy?</span> <span class="nv">stone</span><span class="p">)</span> <span class="p">(</span><span class="nf">cool?</span> <span class="nv">stone</span><span class="p">)</span> <span class="p">(</span><span class="nf">wet?</span> <span class="nv">stone</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">let*</span>
 <span class="p">[</span><span class="nv">or__3943__auto__</span> <span class="p">(</span><span class="nf">mossy?</span> <span class="nv">stone</span><span class="p">)]</span>
 <span class="p">(</span><span class="nf">if</span>
  <span class="nv">or__3943__auto__</span>
  <span class="nv">or__3943__auto__</span>
  <span class="p">(</span><span class="nf">let*</span>
   <span class="p">[</span><span class="nv">or__3943__auto__</span> <span class="p">(</span><span class="nf">cool?</span> <span class="nv">stone</span><span class="p">)]</span>
   <span class="p">(</span><span class="k">if </span><span class="nv">or__3943__auto__</span> <span class="nv">or__3943__auto__</span> <span class="p">(</span><span class="nf">wet?</span> <span class="nv">stone</span><span class="p">)))))</span>
</code>
<p>See how the macro&rsquo;s syntax-quoted <code>(let ...</code> has the same shape as the resulting code? <code>or#</code> is expanded to a variable named <code>or__3943__auto__</code>, which is bound to the expression <code>(mossy? stone)</code>. If that variable is truthy, we return it. Otherwise, we (and here&rsquo;s the recursive part) rebind <code>or__3943__auto__</code> to <code>(cool? stone)</code> and try again. If <em>that</em> fails, we fall back to evaluating <code>(wet? stone)</code>&ndash;thanks to the base case, the single-argument form of the <code>or</code> macro.</p>

<h2>Control flow</h2>

<p>We&rsquo;ve seen that <code>or</code> is a macro written in terms of the special form <code>if</code>&ndash;and because of the way the macro is structured, it does <em>not</em> obey the normal execution order. In <code>(or a b c)</code>, only <code>a</code> is evaluated first&ndash;then, only if it is <code>false</code> or <code>nil</code>, do we evaluate <code>b</code>. This is called <em>short-circuiting</em>, and it works for <code>and</code> as well.</p>

<p>Changing the order of evaluation in a language is called <em>control flow</em>, and lets programs make decisions based on varying circumstances. We&rsquo;ve already seen <code>if</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span>
<span class="ss">:a</span>
</code>
<p><code>if</code> takes a predicate and two expressions, and only evaluates one of them, depending on whether the predicate evaluates to a truthy or falsey value. Sometimes you want to evaluate <em>more than one</em> expression in order. For this, we have <code>do</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pos? </span><span class="mi">-5</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;-5 is positive&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">do</span>
           <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;-5 is negative&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;Who would have thought?&quot;</span><span class="p">)))</span>
<span class="s">&quot;-5 is negative&quot;</span>
<span class="s">&quot;Who would have thought?&quot;</span>
<span class="nv">nil</span>
</code>
<p><code>prn</code> is a function which has a <em>side effect</em>: it prints a message to the screen, and returns <code>nil</code>. We wanted to print <em>two</em> messages, but <code>if</code> only takes a single expression per branch&ndash;so in our false branch, we used <code>do</code> to wrap up two <code>prn</code>s into a single expression, and evaluate them in order. <code>do</code> returns the value of the final expression, which happens to be <code>nil</code> here.</p>

<p>When you only want to take one branch of an <code>if</code>, you can use <code>when</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when </span><span class="nv">false</span>
         <span class="p">(</span><span class="nb">prn </span><span class="ss">:hi</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">prn </span><span class="ss">:there</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when </span><span class="nv">true</span>
         <span class="p">(</span><span class="nb">prn </span><span class="ss">:hi</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">prn </span><span class="ss">:there</span><span class="p">))</span>
<span class="ss">:hi</span>
<span class="ss">:there</span>
<span class="nv">nil</span>
</code>
<p>Because there is only one path to take, <code>when</code> takes any number of expressions, and evaluates them only when the predicate is truthy. If the predicate evaluates to <code>nil</code> or <code>false</code>, <code>when</code> does not evaluate its body, and returns <code>nil</code>.</p>

<p>Both <code>when</code> and <code>if</code> have complementary forms, <code>when-not</code> and <code>if-not</code>, which simply invert the sense of their predicate.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when-not </span><span class="p">(</span><span class="nf">number?</span> <span class="s">&quot;a string&quot;</span><span class="p">)</span>
         <span class="ss">:here</span><span class="p">)</span>
<span class="ss">:here</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">if-not </span><span class="p">(</span><span class="nb">vector? </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
         <span class="ss">:a</span>
         <span class="ss">:b</span><span class="p">)</span>
<span class="ss">:a</span>
</code>
<p>Often, you want to perform some operation, and if it&rsquo;s truthy, re-use that value without recomputing it. For this, we have <code>when-let</code> and <code>if-let</code>. These work just like <code>when</code> and <code>let</code> combined.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)]</span>
         <span class="p">(</span><span class="nb">str </span><span class="nv">x</span><span class="p">))</span>
<span class="s">&quot;10&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">first </span><span class="p">[])]</span>
         <span class="p">(</span><span class="nb">str </span><span class="nv">x</span><span class="p">))</span>
<span class="nv">nil</span>
</code>
<p><code>while</code> evaluates an expression so long as its predicate is truthy. This is generally useful only for side effects, like <code>prn</code> or <code>def</code>; things that change the state of the world.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">while</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">5</span><span class="p">)</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">prn </span><span class="nv">x</span><span class="p">)</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)))</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="nv">nil</span>
</code>
<p><code>cond</code> (for &ldquo;conditional&rdquo;) is like a multiheaded <code>if</code>: it takes <em>any number</em> of test/expression pairs, and tries each test in turn. The first test which evaluates truthy causes the following expression to be evaluated; then <code>cond</code> returns that expression&rsquo;s value.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">cond</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">5</span><span class="p">)</span> <span class="ss">:nope</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">= </span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="ss">:yep</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="p">(</span><span class="nb">= </span><span class="mi">5</span> <span class="mi">5</span><span class="p">)</span> <span class="ss">:cant-get-here</span>
  <span class="o">#</span><span class="nv">_=&gt;</span>   <span class="ss">:else</span>   <span class="ss">:a-default-value</span><span class="p">)</span>
<span class="ss">:yep</span>
</code>
<p>If you find yourself making several similar decisions based on a value, try <code>condp</code>, for &ldquo;cond with predicate&rdquo;. For instance, we might categorize a number based on some ranges:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">category</span>
  <span class="s">&quot;Determines the Saffir-Simpson category of a hurricane, by wind speed in meters/sec&quot;</span>
  <span class="p">[</span><span class="nv">wind-speed</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">condp</span> <span class="nb">&lt;= </span><span class="nv">wind-speed</span>
    <span class="mi">70</span> <span class="ss">:F5</span>
    <span class="mi">58</span> <span class="ss">:F4</span>
    <span class="mi">49</span> <span class="ss">:F3</span>
    <span class="mi">42</span> <span class="ss">:F2</span>
       <span class="ss">:F1</span><span class="p">))</span> <span class="c1">; Default value</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">category</span> <span class="mi">10</span><span class="p">)</span>
<span class="ss">:F1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">category</span> <span class="mi">50</span><span class="p">)</span>
<span class="ss">:F3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">category</span> <span class="mi">100</span><span class="p">)</span>
<span class="ss">:F5</span>
</code>
<p><code>condp</code> generates code which combines the predicate <code>&lt;=</code> with each number, and the value of <code>wind-speed</code>, like so:</p>
<code class="block"><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mi">70</span> <span class="nv">wind-speed</span><span class="p">)</span> <span class="ss">:F5</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mi">58</span> <span class="nv">wind-speed</span><span class="p">)</span> <span class="ss">:F4</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mi">49</span> <span class="nv">wind-speed</span><span class="p">)</span> <span class="ss">:F3</span>
      <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt;= </span><span class="mi">42</span> <span class="nv">wind-speed</span><span class="p">)</span> <span class="ss">:F2</span>
        <span class="ss">:F1</span><span class="p">))))</span>
</code>
<p>Specialized macros like <code>condp</code> are less commonly used than <code>if</code> or <code>when</code>, but they still play an important role in simplifying repeated code. They clarify the meaning of complex expressions, making them easier to read and maintain.</p>

<p>Finally, there&rsquo;s <code>case</code>, which works a little bit like a map of keys to values&ndash;only the values are <em>code</em>, to be evaluated. You can think of <code>case</code> like <code>(condp = ...)</code>, trying to match an expression to a particular branch for which it is equal.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">with-tax</span>
  <span class="s">&quot;Computes the total cost, with tax, of a purchase in the given state.&quot;</span>
  <span class="p">[</span><span class="nv">state</span> <span class="nv">subtotal</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">case</span> <span class="nv">state</span>
    <span class="ss">:WA</span> <span class="p">(</span><span class="nb">* </span><span class="mf">1.065</span> <span class="nv">subtotal</span><span class="p">)</span>
    <span class="ss">:OR</span> <span class="nv">subtotal</span>
    <span class="ss">:CA</span> <span class="p">(</span><span class="nb">* </span><span class="mf">1.075</span> <span class="nv">subtotal</span><span class="p">)</span>
    <span class="c1">; ... 48 other states ...</span>
    <span class="nv">subtotal</span><span class="p">))</span> <span class="c1">; a default case</span>
</code>
<p>Unlike <code>cond</code> and <code>condp</code>, <code>case</code> does <em>not</em> evaluate its tests in order. It jumps <em>immediately</em> to the matching expression. This makes <code>case</code> much faster when there are many branches to take&ndash;at the cost of reduced generality.</p>

<h2>Recursion</h2>

<p>Previously, we defined recursive functions by having those functions call themselves explicitly.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">sum</span> <span class="p">[</span><span class="nv">numbers</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nb">first </span><span class="nv">numbers</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">numbers</span><span class="p">)))</span>
    <span class="mi">0</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="mi">45</span>
</code>
<p>But this approach breaks down when we have the function call itself <em>deeply</em>, over and over again.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100000</span><span class="p">))</span>

<span class="nv">StackOverflowError</span>   <span class="nv">clojure.core/range/fn--4269</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:2664</span><span class="p">)</span>
</code>
<p>Every time you call a function, the arguments for that function are stored in memory, in a region called <em>the stack</em>. They remain there for as long as the function is being called&ndash;including any deeper function calls.</p>
<code class="block">    <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">numbers</span><span class="p">)))</span>
</code>
<p>In order to add <code>n</code> and <code>(sum (rest numbers))</code>, we have to call <code>sum</code> <em>first</em>&ndash;while holding onto the memory for <code>n</code> and <code>numbers</code>. We can&rsquo;t re-use that memory until <em>every single recursive call</em> has completed. Clojure complains, after tens of thousands of stack frames are in use, that it has run out of space in the stack and can allocate no more.</p>

<p>But consider this variation on <code>sum</code>:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">sum</span>
  <span class="p">([</span><span class="nv">numbers</span><span class="p">]</span>
   <span class="p">(</span><span class="nf">sum</span> <span class="mi">0</span> <span class="nv">numbers</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">subtotal</span> <span class="nv">numbers</span><span class="p">]</span>
   <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nb">first </span><span class="nv">numbers</span><span class="p">)]</span>
     <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">subtotal</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">numbers</span><span class="p">))</span>
     <span class="nv">subtotal</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">sum</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100000</span><span class="p">))</span>
<span class="mi">4999950000</span>
</code>
<p>We&rsquo;ve added an additional parameter to the function. In its two-argument form, <code>sum</code> now takes an accumulator, <code>subtotal</code>, which represents the count so far. In addition, <code>recur</code> has taken the place of <code>sum</code>. Notice, however, that the final expression to be evaluated is not <code>+</code>, but <code>sum</code> (viz <code>recur</code>) itself. We don&rsquo;t need to hang on to any of the variables in this function any more, because the final return value won&rsquo;t depend on them. <code>recur</code> hints to the Clojure compiler that we <em>don&rsquo;t need</em> to hold on to the stack, and can re-use that space for other things. This is called a <em>tail-recursive</em> function, and it requires only a single stack frame no matter how deep the recursive calls go.</p>

<p>Use <code>recur</code> wherever possible. It requires much less memory and is much faster than the explicit recursion.</p>

<p>You can also use <code>recur</code> within the context of the <code>loop</code> macro, where it acts just like an unnamed recursive function with initial values provided. Think of it, perhaps, like a recursive <code>let</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">loop </span><span class="p">[</span><span class="nv">i</span> <span class="mi">0</span>
              <span class="nv">nums</span> <span class="p">[]]</span>
         <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="mi">10</span> <span class="nv">i</span><span class="p">)</span>
           <span class="nv">nums</span>
           <span class="p">(</span><span class="nf">recur</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">nums</span> <span class="nv">i</span><span class="p">))))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">]</span>
</code>
<h2>Laziness</h2>

<p>In chapter 4 we mentioned that most of the sequences in Clojure, like <code>map</code>, <code>filter</code>, <code>iterate</code>, <code>repeatedly</code>, and so on, were <em>lazy</em>: they did not evaluate any of their elements until required. This too is provided by a macro, called <code>lazy-seq</code>.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">integers</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span>
    <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="p">(</span><span class="nf">integers</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">x</span><span class="p">)))))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">xs</span> <span class="p">(</span><span class="nf">integers</span> <span class="mi">0</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/xs</span>
</code>
<p>This sequence does not terminate; it is <em>infinitely</em> recursive. Yet it returned instantaneously. <code>lazy-seq</code> interrupted that recursion and restructured it into a sequence which constructs elements only when they are requested.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">xs</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>When using <code>lazy-seq</code> and its partner <code>lazy-cat</code>, you don&rsquo;t have to use <code>recur</code>&ndash;or even be tail-recursive. The macros interrupt each level of recursion, preventing stack overflows.</p>

<p>You can also delay evaluation of some expressions until later, using <code>delay</code> and <code>deref</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">delay</span>
                <span class="p">(</span><span class="nb">prn </span><span class="s">&quot;computing a really big number!&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">last </span><span class="p">(</span><span class="nb">take </span><span class="mi">10000000</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)))))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span> <span class="c1">; Did nothing, returned immediately</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">x</span><span class="p">)</span>
<span class="s">&quot;computing a really big number!&quot;</span> <span class="c1">; Now we have to wait!</span>
<span class="mi">9999999</span>
</code>
<h2>List comprehensions</h2>

<p>Combining recursion and laziness is the <em>list comprehension</em> macro, <code>for</code>. In its simplest form, <code>for</code> works like <code>map</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)]</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">-1</span> <span class="mi">-2</span> <span class="mi">-3</span> <span class="mi">-4</span> <span class="mi">-5</span> <span class="mi">-6</span> <span class="mi">-7</span> <span class="mi">-8</span> <span class="mi">-9</span><span class="p">)</span>
</code>
<p>Like <code>let</code>, <code>for</code> takes a vector of <code>bindings</code>. Unlike <code>let</code>, however, <code>for</code> binds its variables to <em>each possible combination of elements in their corresponding sequences</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
             <span class="nv">y</span> <span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">]]</span>
         <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>
<span class="p">([</span><span class="mi">1</span> <span class="ss">:a</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="ss">:b</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="ss">:a</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="ss">:b</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="ss">:a</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="ss">:b</span><span class="p">])</span>
</code>
<p>&ldquo;For each x in the sequence <code>[1 2 3]</code>, and for each <code>y</code> in the sequence <code>[:a :b]</code>, find all <code>[x y]</code> pairs.&rdquo; Note that the rightmost variable <code>y</code> iterates the fastest.</p>

<p>Like most sequence functions, the <code>for</code> macro yields lazy sequences. You can filter them with <code>take</code>, <code>filter</code>, et al like any other sequence. Or you can use <code>:while</code> to tell <code>for</code> when to stop, or <code>:when</code> to filter out combinations of elements.</p>
<code class="block"><span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span>     <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span>
      <span class="nv">y</span>     <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span>
      <span class="ss">:when</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nf">even?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">odd?</span> <span class="nv">y</span><span class="p">))]</span>
  <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])</span>
<span class="p">([</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">3</span><span class="p">])</span>
</code>
<p>Clojure includes a rich smrgsbord of control-flow constructs; we&rsquo;ll meet new ones throughout the book.</p>

<h2>The threading macros</h2>

<p>Sometimes you want to <em>thread</em> a computation through several expressions, like a chain. Object-oriented languages like Ruby or Java are well-suited to this style:</p>
<code class="block"><span class="mi">1</span><span class="o">.</span><span class="mi">9</span><span class="o">.</span><span class="mi">3</span><span class="n">p385</span> <span class="p">:</span><span class="mo">004</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:odd?</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:+</span><span class="p">)</span>
<span class="mi">25</span>
</code>
<p>Start with the range <code>0</code> to <code>10</code>, then call <code>select</code> on that range, with the function <code>odd?</code>. Finally, take <em>that</em> sequence of numbers, and reduce it with the <code>+</code> function.</p>

<p>The Clojure threading macros do the same by restructuring a sequence of expressions, inserting each expression as the first (or final) argument in the next expression.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">clojure.walk/macroexpand-all</span> 
         <span class="o">&#39;</span><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">)</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">)</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="mi">25</span>
</code>
<p><code>-&gt;&gt;</code> took <code>(range 10)</code> and inserted it at the end of <code>(filter odd?)</code>, forming <code>(filter odd? (range 10))</code>. Then it took <em>that</em> expression and inserted it at the end of <code>(reduce +)</code>. In essence, <code>-&gt;&gt;</code> <em>flattens and reverses</em> a nested chain of operations.</p>

<p><code>-&gt;</code>, by contrast, inserts each form in as the <em>first</em> argument in the following expression.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">clojure.walk/macroexpand-all</span> 
         <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="p">{</span><span class="ss">:proton</span> <span class="ss">:fermion</span><span class="p">}</span> <span class="p">(</span><span class="nb">assoc </span><span class="ss">:photon</span> <span class="ss">:boson</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="ss">:neutrino</span> <span class="ss">:fermion</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">assoc </span><span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:proton</span> <span class="ss">:fermion</span><span class="p">}</span> <span class="ss">:photon</span> <span class="ss">:boson</span><span class="p">)</span> <span class="ss">:neutrino</span> <span class="ss">:fermion</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">{</span><span class="ss">:proton</span> <span class="ss">:fermion</span><span class="p">}</span>
           <span class="p">(</span><span class="nb">assoc </span><span class="ss">:photon</span> <span class="ss">:boson</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">assoc </span><span class="ss">:neutrino</span> <span class="ss">:fermion</span><span class="p">))</span>
<span class="p">{</span><span class="ss">:neutrino</span> <span class="ss">:fermion</span>, <span class="ss">:photon</span> <span class="ss">:boson</span>, <span class="ss">:proton</span> <span class="ss">:fermion</span><span class="p">}</span>
</code>
<p>Clojure isn&rsquo;t just <code>function-oriented</code> in its syntax; it can be object-oriented, and stack-oriented, and array-oriented, and so on&ndash;and <em>mix all of these styles freely, in a controlled way</em>. If you don&rsquo;t like the way the language fits a certain problem, you can write a macro which defines a <em>new</em> language, specifically for that subproblem.</p>

<p><code>cond</code>, <code>condp</code> and <code>case</code>, for example, express a language for branching based on predicates. <code>-&gt;</code>, <code>-&gt;&gt;</code>, and <code>doto</code> express object-oriented and other expression-chaining languages.</p>

<ul>
<li><a href="https://github.com/clojure/core.match">core.match</a> is a set of macros which express powerful <em>pattern-matching</em> and substitution languages.</li>
<li><a href="https://github.com/clojure/core.logic">core.logic</a> expresses syntax for <em>logic programming</em>, for finding values which satisfy complex constraints.</li>
<li><a href="http://clojure.com/blog/2013/06/28/clojure-core-async-channels.html">core.async</a> restructures Clojure code into <em>asynchronous</em> forms so they can do many things at once.</li>
<li>For those with a twisted sense of humor, <a href="https://github.com/rplevy/swiss-arrows">Swiss Arrows</a> extends the threading macros into evil&ndash;but delightfully concise!&ndash;forms.</li>
</ul>

<p>We&rsquo;ll see a plethora of macros, from simple to complex, through the course of this book. Each one shares the common pattern of <em>simplifying code</em>; reducing tangled or verbose expressions into something more concise, more meaningful, better suited to the problem at hand.</p>

<h2>When to use macros</h2>

<p>While it&rsquo;s important to be aware of the purpose and behavior of the macro system, you don&rsquo;t need to write your own macros to be productive with Clojure. For now, you&rsquo;ll be just fine writing code which uses the existing macros in the language. When you <em>do</em> need to delve deeper, come back to this guide and experiment. It&rsquo;ll take some time to sink in.</p>

<p>First, know that writing macros is <em>tricky</em>, even for experts. It requires you to think at two levels simultaneously, and to be mindful of the distinction between <em>expression</em> and underlying <em>evaluation</em>. Writing a macro is essentially extending the language, the compiler, the syntax and evaluation model of Clojure, by restructuring <em>arbitrary</em> expressions into ones the evaluation system understands. This is hard, and it&rsquo;ll take practice to get used to.</p>

<p>In addition, Clojure macros come with some important restrictions. Because they&rsquo;re expanded prior to evaluation, macros are invisible to functions. They can&rsquo;t be composed functionally&ndash;you can&rsquo;t <code>(map or ...)</code>, for instance.</p>

<p>So in general, if you <em>can</em> solve a problem without writing a macro, <em>don&rsquo;t write one</em>. It&rsquo;ll be easier to debug, easier to understand, and easier to compose later. Only reach for macros when you need <em>new syntax</em>, or when performance demands the code be transformed at compile time.</p>

<p>When you do write a macro, consider its scope carefully. Keep the transformation simple; and do as much in normal functions as possible. Provide an escape hatch where possible, by doing most of the work in a function, and writing a small wrapper macro which calls that function. Finally, remember the distinction between <em>code</em> and what that code <em>evaluates to</em>. Use <code>let</code> whenever a value is to be re-used, to prevent it being evaluated twice by accident.</p>

<p>For a deeper exploration of Clojure macros in a real-world application, try <a href="http://aphyr.com/posts/268-language-power">Language Power</a>.</p>

<h2>Review</h2>

<p>In Chapter 4, deeply nested expressions led to the desire for a <em>simpler</em>, <em>more direct</em> expression of a chain of sequence operations. We learned that the Clojure compiler first <em>expands</em> expressions before evaluating them, using macros&ndash;special functions which take code and return other code. We used macros to define the short-circuiting <code>or</code> operator, and followed that with a tour of basic control flow, recursion, laziness, list comprehensions, and chained expressions. Finally, we learned a bit about when and how to write our own macros.</p>

<p>Throughout this chapter we&rsquo;ve brushed against the idea of <em>side effects</em>: things which change the outside world. We might change a var with <code>def</code>, or print a message to the screen with <code>prn</code>. Real languages must model a continually shifting universe, which leads us to <a href="http://aphyr.com/posts/306-clojure-from-the-ground-up-state">Chapter Six: Side effects and state</a>.</p>

<h2>Problems</h2>

<ol>
<li><p>Using the control flow constructs we&rsquo;ve learned, write a <code>schedule</code> function which, given an hour of the day, returns what you&rsquo;ll be doing at that time. <code>(schedule 18)</code>, for me, returns <code>:dinner</code>.</p></li>
<li><p>Using the threading macros, find how many numbers from 0 to 9999 are palindromes: identical when written forwards and backwards. <code>121</code> is a palindrome, as is <code>7447</code> and <code>5</code>, but not <code>12</code> or <code>953</code>.</p></li>
<li><p>Write a macro <code>id</code> which takes a function and a list of args: <code>(id f a b c)</code>, and returns an expression which calls that function with the given args: <code>(f a b c)</code>.</p></li>
<li><p>Write a macro <code>log</code> which uses a var, <code>logging-enabled</code>, to determine whether or not to print an expression to the console at compile time. If <code>logging-enabled</code> is false, <code>(log :hi)</code> should macroexpand to <code>nil</code>. If <code>logging-enabled</code> is true, <code>(log :hi)</code> should macroexpand to <code>(prn :hi)</code>. Why would you want to do this check during <em>compilation</em>, instead of when running the program? What might you <em>lose</em>?</p></li>
<li><p>(Advanced) Using the <code>rationalize</code> function, write a macro <code>exact</code> which rewrites any use of <code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code> to force the use of <em>ratios</em> instead of <a href="http://erlang.org/pipermail/erlang-questions/2013-November/076114.html">floating-point numbers</a>. <code>(* 2452.45 100)</code> returns <code>245244.99999999997</code>, but <code>(exact (* 2452.45 100))</code> should return <code>245245N</code></p></li>
</ol>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/304-clojure-from-the-ground-up-sequences">Clojure from the ground up: sequences</a></h1>
    </div>
    <div class="body">
      <p>In <a href="/posts/303-clojure-from-the-ground-up-functions">Chapter 3</a>, we discovered functions as a way to <em>abstract</em> expressions; to
rephrase a particular computation with some parts missing. We used functions to
transform a single value. But what if we want to apply a function to <em>more than
one</em> value at once? What about sequences?</p>

<p>For example, we know that <code>(inc 2)</code> increments the number 2. What if we wanted to increment <em>every number</em> in the vector <code>[1 2 3]</code>, producing <code>[2 3 4]</code>?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">ClassCastException</span> <span class="nv">clojure.lang.PersistentVector</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nb">cast </span><span class="nv">to</span> <span class="nv">java.lang.Number</span>  <span class="nv">clojure.lang.Numbers.inc</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:110</span><span class="p">)</span>
</code>
<p>Clearly <code>inc</code> can only work on numbers, not on vectors. We need a different
kind of tool.</p>

<h2>A direct approach</h2>

<p>Let&rsquo;s think about the problem in concrete terms. We want to increment each of
three elements: the first, second, and third. We know how to get an element
from a sequence by using nth, so let&rsquo;s start with the first number, at index 0:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">numbers</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">#</span><span class="ss">&#39;user/numbers</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">0</span><span class="p">))</span>
<span class="mi">2</span>
</code>
<p>So there&rsquo;s the first element incremented. Now we can do the second:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">1</span><span class="p">))</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">2</span><span class="p">))</span>
<span class="mi">4</span>
</code>
<p>And it should be straightforward to combine these into a vector&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">[(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">2</span><span class="p">))]</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</code>
<p>Success! We&rsquo;ve incremented each of the numbers in the list! How about a list with only two elements?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">numbers</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">#</span><span class="ss">&#39;user/numbers</span>
<span class="nv">user=&gt;</span> <span class="p">[(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">nth </span><span class="nv">numbers</span> <span class="mi">2</span><span class="p">))]</span>

<span class="nv">IndexOutOfBoundsException</span>   <span class="nv">clojure.lang.PersistentVector.arrayFor</span> <span class="p">(</span><span class="nf">PersistentVector.java</span><span class="ss">:107</span><span class="p">)</span>
</code>
<p>Shoot. We tried to get the element at index 2, but <em>couldn&rsquo;t</em>, because
<code>numbers</code> only has indices 0 and 1. Clojure calls that &ldquo;index out of bounds&rdquo;.</p>

<p>We could just leave off the third expression in the vector; taking only
elements 0 and 1. But the problem actually gets much worse, because we&rsquo;d need
to make this change <em>every</em> time we wanted to use a different sized vector. And
what of a vector with 1000 elements? We&rsquo;d need 1000 <code>(inc (nth numbers ...))</code>
expressions! Down this path lies madness.</p>

<p>Let&rsquo;s back up a bit, and try a slightly smaller problem.</p>

<h2>Recursion</h2>

<p>What if we just incremented the <em>first</em> number in the vector? How would that
work? We know that <code>first</code> finds the first element in a sequence, and <code>rest</code>
finds all the remaining ones.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="mi">1</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rest </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>So there&rsquo;s the <em>pieces</em> we&rsquo;d need. To glue them back together, we can use a
function called <code>cons</code>, which says &ldquo;make a list beginning with the first
argument, followed by all the elements in the second argument&rdquo;.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</code>
<p>OK so we can split up a sequence, increment the first part, and join them back together. Not so hard, right?</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">inc-first</span> <span class="p">[</span><span class="nv">nums</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">first </span><span class="nv">nums</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">rest </span><span class="nv">nums</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-first</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</code>
<p>Hey, there we go! First element changed. Will it work with any length list?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-first</span> <span class="p">[</span><span class="mi">5</span><span class="p">])</span>
<span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-first</span> <span class="p">[])</span>

<span class="nv">NullPointerException</span>   <span class="nv">clojure.lang.Numbers.ops</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:942</span><span class="p">)</span>
</code>
<p>Shoot. We can&rsquo;t increment the first element of this empty vector, because it
doesn&rsquo;t <em>have</em> a first element.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">[])</span>
<span class="nv">nil</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">nil</span><span class="p">)</span>

<span class="nv">NullPointerException</span>   <span class="nv">clojure.lang.Numbers.ops</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:942</span><span class="p">)</span>
</code>
<p>So there are really <em>two</em> cases for this function. If there is a first element
in <code>nums</code>, we&rsquo;ll increment it as normal. If there&rsquo;s <em>no</em> such element, we&rsquo;ll
return an empty list. To express this kind of conditional behavior, we&rsquo;ll use a
Clojure special form called <code>if</code>:</p>
<code class="block">user=&gt; (doc if)
-------------------------
if
  (if test then else?)
Special Form
  Evaluates test. If not the singular values nil or false,
  evaluates and yields then, otherwise, evaluates and yields else. If
  else is not supplied it defaults to nil.

  Please see http:&#x2F;&#x2F;clojure.org&#x2F;special_forms#if</code>
<p>To confirm our intuition:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="nv">true</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span>
<span class="ss">:a</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="nv">false</span> <span class="ss">:a</span> <span class="ss">:b</span><span class="p">)</span>
<span class="ss">:b</span>
</code>
<p>Seems straightforward enough.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">inc-first</span> <span class="p">[</span><span class="nv">nums</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">first </span><span class="nv">nums</span><span class="p">)</span>
    <span class="c1">; If there&#39;s a first number, build a new list with cons</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">first </span><span class="nv">nums</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">rest </span><span class="nv">nums</span><span class="p">))</span>
    <span class="c1">; If there&#39;s no first number, just return an empty list</span>
    <span class="p">(</span><span class="nf">list</span><span class="p">)))</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-first</span> <span class="p">[])</span>
<span class="p">()</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-first</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>Success! Now we can handle <em>both</em> cases: empty sequences, and sequences with
things in them. Now how about incrementing that <em>second</em> number? Let&rsquo;s stare at
that code for a bit.</p>
<code class="block"><span class="p">(</span><span class="nb">rest </span><span class="nv">nums</span><span class="p">)</span>
</code>
<p>Hang on. That list&ndash;<code>(rest nums)</code>&ndash;that&rsquo;s a list of numbers too.  What if we&hellip;
used our inc-first function on <em>that</em> list, to increment <em>its</em> first number?
Then we&rsquo;d have incremented both the first <em>and</em> the second element.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">inc-more</span> <span class="p">[</span><span class="nv">nums</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">first </span><span class="nv">nums</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">first </span><span class="nv">nums</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">inc-more</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">nums</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">list</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-more</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code>
<p>Odd. That didn&rsquo;t just increment the first two numbers. It incremented <em>all</em> the
numbers. We fell into the <em>complete</em> solution entirely by accident.  What
happened here?</p>

<p>Well first we&hellip; yes, we got the number one, and incremented it. Then we stuck
that onto <code>(inc-first [2 3 4])</code>, which got two, and incremented it. Then we stuck
that two onto <code>(inc-first [3 4])</code>, which got three, and then we did the same for
four. Only <em>that</em> time around, at the very end of the list, <code>(rest [4])</code> would
have been <em>empty</em>. So when we went to get the first number of the empty list,
we took the <em>second</em> branch of the <code>if</code>, and returned the empty list.</p>

<p>Having reached the <em>bottom</em> of the function calls, so to speak, we zip back up
the chain. We can imagine this function turning into a long string of <code>cons</code>
calls, like so:</p>
<code class="block"><span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">4</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="o">&#39;</span><span class="p">()))))</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">4</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code>
<p>This technique is called <em>recursion</em>, and it is a fundamental principle in
working with collections, sequences, trees, or graphs&hellip; any problem which has
small parts linked together. There are two key elements in a recursive program:</p>

<ol>
<li>Some part of the problem which has a known solution</li>
<li>A relationship which connects one part of the problem to the next</li>
</ol>

<p>Incrementing the elements of an empty list returns the empty list. This is our
<em>base case</em>: the ground to build on. Our <em>inductive</em> case, also called the
<em>recurrence relation</em>, is how we broke the problem up into incrementing the
<em>first</em> number in the sequence, and incrementing all the numbers in the
<em>rest</em> of the sequence. The <code>if</code> expression bound these two cases together into
a single function; a function <em>defined in terms of itself</em>.</p>

<p>Once the initial step has been taken, <em>every</em> step can be taken.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">inc-more</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">)</span>
</code>
<p>This is the beauty of a recursive function; folding an unbounded stream of
computation over and over, onto itself, until only a single step remains.</p>

<h2>Generalizing from inc</h2>

<p>We set out to increment every number in a vector, but nothing in our solution
actually depended on <code>inc</code>. It just as well could have been <code>dec</code>, or <code>str</code>, or
<code>keyword</code>. Let&rsquo;s <em>parameterize</em> our <code>inc-more</code> function to use <em>any</em>
transformation of its elements:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">transform-all</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">xs</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">first </span><span class="nv">xs</span><span class="p">))</span>
          <span class="p">(</span><span class="nf">transform-all</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">xs</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">list</span><span class="p">)))</span>
</code>
<p>Because we could be talking about <em>any</em> kind of sequence, not just numbers,
we&rsquo;ve named the sequence <code>xs</code>, and its first element <code>x</code>. We also take a
function <code>f</code> as an argument, and that function will be applied to each <code>x</code> in
turn. So not only can we increment numbers&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">transform-all</span> <span class="nb">inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code>
<p>&hellip;but we can turn strings to keywords&hellip;</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">transform-all</span> <span class="nb">keyword </span><span class="p">[</span><span class="s">&quot;bell&quot;</span> <span class="s">&quot;hooks&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="ss">:bell</span> <span class="ss">:hooks</span><span class="p">)</span>
</code>
<p>&hellip;or wrap every element in a list:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">transform-all</span> <span class="nb">list </span><span class="p">[</span><span class="ss">:codex</span> <span class="ss">:book</span> <span class="ss">:manuscript</span><span class="p">])</span>
<span class="p">((</span><span class="ss">:codex</span><span class="p">)</span> <span class="p">(</span><span class="ss">:book</span><span class="p">)</span> <span class="p">(</span><span class="ss">:manuscript</span><span class="p">))</span>
</code>
<p>In short, this function expresses a sequence in which each element is some
function applied to the corresponding element in the underlying sequence.
This idea is so important that it has its own name, in mathematics, Clojure, and other languages. We call it <code>map</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code>
<p>You might remember maps as a datatype in Clojure, too&ndash;they&rsquo;re dictionaries
that relate keys to values.</p>
<code class="block"><span class="p">{</span><span class="ss">:year</span>  <span class="mi">1969</span>
 <span class="ss">:event</span> <span class="s">&quot;moon landing&quot;</span><span class="p">}</span>
</code>
<p>The <em>function</em> <code>map</code> relates one sequence to another. The <code>type</code> map relates
keys to values. There is a deep symmetry between the two: maps are usually
sparse, and the relationships between keys and values may be arbitrarily
complex. The map function, on the other hand, usually expresses the <em>same</em> type
of relationship, applied to a series of elements in <em>fixed order</em>.</p>

<h2>Building sequences</h2>

<p>Recursion can do more than just <code>map</code>. We can use it to expand a single value
into a sequence of values, each related by some function. For
instance:</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">expand</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">x</span> <span class="nv">count</span><span class="p">]</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pos? </span><span class="nv">count</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="p">(</span><span class="nf">expand</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">count</span><span class="p">)))))</span>
</code>
<p>Our base case is <code>x</code> itself, followed by the sequence beginning with <code>(f x)</code>.
That sequence in turn expands to <code>(f (f x))</code>, and then <code>(f (f (f x)))</code>, and so on.
Each time we call <code>expand</code>, we count down by one using <code>dec</code>. Once the count is zero,
the <code>if</code> returns <code>nil</code>, and evaluation stops. If we start with the number 0 and 
use inc as our function:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">expand</span> <span class="nb">inc </span><span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>Clojure has a more general form of this function, called <code>iterate</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>Since this sequence is <em>infinitely</em> long, we&rsquo;re using <code>take</code> to select only the
first 10 elements. We can construct more complex sequences by using more
complex functions:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">iterate </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">odd?</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">10</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</code>
<p>Or build up strings:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="p">(</span><span class="nb">iterate </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="nv">x</span> <span class="s">&quot;o&quot;</span><span class="p">))</span> <span class="s">&quot;y&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="s">&quot;y&quot;</span> <span class="s">&quot;yo&quot;</span> <span class="s">&quot;yoo&quot;</span> <span class="s">&quot;yooo&quot;</span> <span class="s">&quot;yoooo&quot;</span><span class="p">)</span>
</code>
<p><code>iterate</code> is extremely handy for working with infinite sequences, and has some
partners in crime. <code>repeat</code>, for instance, constructs a sequence where every
element is the same.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">repeat </span><span class="ss">:hi</span><span class="p">))</span>
<span class="p">(</span><span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span> <span class="ss">:hi</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">repeat </span><span class="mi">3</span> <span class="ss">:echo</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:echo</span> <span class="ss">:echo</span> <span class="ss">:echo</span><span class="p">)</span>
</code>
<p>And its close relative <code>repeatedly</code> simply calls a function <code>(f)</code> to generate an
infinite sequence of values, over and over again, without any relationship
between elements. For an infinite sequence of random numbers:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
<span class="mf">0.9002678382322784</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">rand</span><span class="p">)</span>
<span class="mf">0.12375594203332863</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="nv">rand</span><span class="p">))</span>
<span class="p">(</span><span class="mf">0.44442397843046755</span> <span class="mf">0.33668691162169784</span> <span class="mf">0.18244875487846746</span><span class="p">)</span>
</code>
<p>Notice that calling <code>(rand)</code> returns a different number each time. We say that
<code>rand</code> is an <em>impure</em> function, because it cannot simply be replaced by the
same value every time. It does something different each time it&rsquo;s called.</p>

<p>There&rsquo;s another very handy sequence function specifically for numbers: <code>range</code>,
which generates a sequence of numbers between two points. <code>(range n)</code> gives n
successive integers starting at 0. <code>(range n m)</code> returns integers from n to
m-1. <code>(range n m step)</code> returns integers from n to m, but separated by <code>step</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">100</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">5</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">20</span> <span class="mi">25</span> <span class="mi">30</span> <span class="mi">35</span> <span class="mi">40</span> <span class="mi">45</span> <span class="mi">50</span> <span class="mi">55</span> <span class="mi">60</span> <span class="mi">65</span> <span class="mi">70</span> <span class="mi">75</span> <span class="mi">80</span> <span class="mi">85</span> <span class="mi">90</span> <span class="mi">95</span><span class="p">)</span>
</code>
<p>To extend a sequence by repeating it forever, use <code>cycle</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">cycle </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">)</span>
</code>
<h2>Transforming sequences</h2>

<p>Given a sequence, we often want to find a <em>related</em> sequence. <code>map</code>, for
instance, applies a function to each element&ndash;but has a few more tricks up its
sleeve.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">n</span> <span class="nv">vehicle</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;I&#39;ve got &quot;</span> <span class="nv">n</span> <span class="s">&quot; &quot;</span> <span class="nv">vehicle</span> <span class="s">&quot;s&quot;</span><span class="p">))</span>
         <span class="p">[</span><span class="mi">0</span> <span class="mi">200</span> <span class="mi">9</span><span class="p">]</span>
         <span class="p">[</span><span class="s">&quot;car&quot;</span> <span class="s">&quot;train&quot;</span> <span class="s">&quot;kiteboard&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="s">&quot;I&#39;ve got 0 cars&quot;</span> <span class="s">&quot;I&#39;ve got 200 trains&quot;</span> <span class="s">&quot;I&#39;ve got 9 kiteboards&quot;</span><span class="p">)</span>
</code>
<p>If given multiple sequences, <code>map</code> calls its function with one element from each sequence in turn. So the first value will be <code>(f 0 &quot;car&quot;)</code>, the second <code>(f 200
&quot;train&quot;)</code>, and so on. Like a zipper, map folds together corresponding elements
from multiple collections. To sum three vectors, column-wise:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map + </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
              <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
              <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="p">(</span><span class="mi">12</span> <span class="mi">15</span> <span class="mi">18</span><span class="p">)</span>
</code>
<p>If one sequence is bigger than another, map stops at the end of the smaller
one. We can exploit this to combine finite and infinite sequences. For example, to number the elements in a vector:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">index </span><span class="nv">element</span><span class="p">]</span> <span class="p">(</span><span class="nb">str index </span><span class="s">&quot;. &quot;</span> <span class="nv">element</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)</span>
            <span class="p">[</span><span class="s">&quot;erlang&quot;</span> <span class="s">&quot;ruby&quot;</span> <span class="s">&quot;haskell&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="s">&quot;0. erlang&quot;</span> <span class="s">&quot;1. ruby&quot;</span> <span class="s">&quot;2. haskell&quot;</span><span class="p">)</span>
</code>
<p>Transforming elements together with their indices is so common that Clojure has
a special function for it: <code>map-indexed</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">map-indexed</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">index </span><span class="nv">element</span><span class="p">]</span> <span class="p">(</span><span class="nb">str index </span><span class="s">&quot;. &quot;</span> <span class="nv">element</span><span class="p">))</span>
                    <span class="p">[</span><span class="s">&quot;erlang&quot;</span> <span class="s">&quot;ruby&quot;</span> <span class="s">&quot;haskell&quot;</span><span class="p">])</span>
<span class="p">(</span><span class="s">&quot;0. erlang&quot;</span> <span class="s">&quot;1. ruby&quot;</span> <span class="s">&quot;2. haskell&quot;</span><span class="p">)</span>
</code>
<p>You can also tack one sequence onto the end of another, like so:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
</code>
<p>Another way to combine two sequences is to riffle them together, using
<code>interleave</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">interleave </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>And if you want to insert a specific element between each successive pair in a
sequence, try <code>interpose</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">interpose</span> <span class="ss">:and</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="ss">:and</span> <span class="mi">2</span> <span class="ss">:and</span> <span class="mi">3</span> <span class="ss">:and</span> <span class="mi">4</span><span class="p">)</span>
</code>
<p>To reverse a sequence, use <code>reverse</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reverse </span><span class="s">&quot;woolf&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="sc">\f</span> <span class="sc">\l</span> <span class="sc">\o</span> <span class="sc">\o</span> <span class="sc">\w</span><span class="p">)</span>
</code>
<p>Strings are sequences too! Each element of a string is a <em>character</em>, written <code>\f</code>. You can rejoin those characters into a string with <code>apply str</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">reverse </span><span class="s">&quot;woolf&quot;</span><span class="p">))</span>
<span class="s">&quot;floow&quot;</span>
</code>
<p>&hellip;and break strings up into sequences of chars with <code>seq</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="s">&quot;sato&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="sc">\s</span> <span class="sc">\a</span> <span class="sc">\t</span> <span class="sc">\o</span><span class="p">)</span>
</code>
<p>To randomize the order of a sequence, use <code>shuffle</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">shuffle</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">]</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nf">shuffle</span> <span class="p">(</span><span class="nb">seq </span><span class="s">&quot;abracadabra&quot;</span><span class="p">)))</span>
<span class="s">&quot;acaadabrrab&quot;</span>
</code>
<h2>Subsequences</h2>

<p>We&rsquo;ve already seen <code>take</code>, which selects the first n elements. There&rsquo;s also
<code>drop</code>, which removes the first n elements.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">drop </span><span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>And for slicing apart the other end of the sequence, we have <code>take-last</code> and <code>drop-last</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">take-last</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">drop-last</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
</code>
<p><code>take-while</code> and <code>drop-while</code> work just like <code>take</code> and <code>drop</code>, but use a function to decide when to cut.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take-while pos? </span><span class="p">[</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">-1</span> <span class="mi">-2</span> <span class="mi">10</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code>
<p>In general, one can cut a sequence in twain by using <code>split-at</code>, and giving it
a particular index. There&rsquo;s also <code>split-with</code>, which uses a function to decide
when to cut.</p>
<code class="block"><span class="p">(</span><span class="nb">split-at </span><span class="mi">4</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">[(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)]</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">split-with </span><span class="nv">number?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="ss">:mark</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="ss">:mark</span> <span class="mi">7</span><span class="p">])</span>
<span class="p">[(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="ss">:mark</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="ss">:mark</span> <span class="mi">7</span><span class="p">)]</span>
</code>
<p>Notice that because indexes start at zero, sequence functions tend to have
predictable numbers of elements. <code>(split-at 4)</code> yields <em>four</em> elements in the
first collection, and ensures the second collection <em>begins at index four</em>.
<code>(range 10)</code> has ten elements, corresponding to the first ten indices in a
sequence. <code>(range 3 5)</code> has two (since 5 - 3 is two) elements. These choices simplify the
definition of recursive functions as well.</p>

<p>We can select particular elements from a sequence by applying a function. To
find all positive numbers in a list, use <code>filter</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">filter pos? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">5</span> <span class="mi">-4</span> <span class="mi">-7</span> <span class="mi">3</span> <span class="mi">0</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">5</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p><code>filter</code> looks at each element in turn, and includes it in the resulting
sequence <em>only</em> if <code>(f element)</code> returns a truthy value. Its complement is
<code>remove</code>, which only includes those elements where <code>(f element)</code> is <code>false</code> or <code>nil</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">remove string? </span><span class="p">[</span><span class="mi">1</span> <span class="s">&quot;turing&quot;</span> <span class="ss">:apple</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="ss">:apple</span><span class="p">)</span>
</code>
<p>Finally, one can group a sequence into chunks using <code>partition</code>,
<code>partition-all</code>, or <code>partition-by</code>. For instance, one might group alternating
values into pairs:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="p">[</span><span class="ss">:cats</span> <span class="mi">5</span> <span class="ss">:bats</span> <span class="mi">27</span> <span class="ss">:crocodiles</span> <span class="mi">0</span><span class="p">])</span>
<span class="p">((</span><span class="ss">:cats</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="ss">:bats</span> <span class="mi">27</span><span class="p">)</span> <span class="p">(</span><span class="ss">:crocodiles</span> <span class="mi">0</span><span class="p">))</span>
</code>
<p>Or separate a series of numbers into negative and positive runs:</p>
<code class="block"><span class="p">(</span><span class="nf">user=&gt;</span> <span class="p">(</span><span class="nf">partition-by</span> <span class="nb">neg? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">-1</span> <span class="mi">-2</span> <span class="mi">-3</span> <span class="mi">-2</span> <span class="mi">-1</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">((</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">-1</span> <span class="mi">-2</span> <span class="mi">-3</span> <span class="mi">-2</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</code>
<h2>Collapsing sequences</h2>

<p>After transforming a sequence, we often want to collapse it in some way; to
derive some smaller value. For instance, we might want the number of times each element appears in a sequence:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">frequencies</span> <span class="p">[</span><span class="ss">:meow</span> <span class="ss">:mrrrow</span> <span class="ss">:meow</span> <span class="ss">:meow</span><span class="p">])</span>
<span class="p">{</span><span class="ss">:meow</span> <span class="mi">3</span>, <span class="ss">:mrrrow</span> <span class="mi">1</span><span class="p">}</span>
</code>
<p>Or to group elements by some function:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">group-by</span> <span class="ss">:first</span> <span class="p">[{</span><span class="ss">:first</span> <span class="s">&quot;Li&quot;</span>    <span class="ss">:last</span> <span class="s">&quot;Zhou&quot;</span><span class="p">}</span>
                                 <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Sarah&quot;</span> <span class="ss">:last</span> <span class="s">&quot;Lee&quot;</span><span class="p">}</span>
                                 <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Sarah&quot;</span> <span class="ss">:last</span> <span class="s">&quot;Dunn&quot;</span><span class="p">}</span>
                                 <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Li&quot;</span>    <span class="ss">:last</span> <span class="s">&quot;O&#39;Toole&quot;</span><span class="p">}]))</span>
<span class="p">{</span><span class="s">&quot;Li&quot;</span>    <span class="p">[{</span><span class="ss">:last</span> <span class="s">&quot;Zhou&quot;</span>, <span class="ss">:first</span> <span class="s">&quot;Li&quot;</span><span class="p">}</span>   <span class="p">{</span><span class="ss">:last</span> <span class="s">&quot;O&#39;Toole&quot;</span>, <span class="ss">:first</span> <span class="s">&quot;Li&quot;</span><span class="p">}]</span>,
 <span class="s">&quot;Sarah&quot;</span> <span class="p">[{</span><span class="ss">:last</span> <span class="s">&quot;Lee&quot;</span>, <span class="ss">:first</span> <span class="s">&quot;Sarah&quot;</span><span class="p">}</span> <span class="p">{</span><span class="ss">:last</span> <span class="s">&quot;Dunn&quot;</span>, <span class="ss">:first</span> <span class="s">&quot;Sarah&quot;</span><span class="p">}]}</span>
</code>
<p>Here we&rsquo;ve taken a sequence of people with first and last names, and used the
<code>:first</code> keyword (which can act as a function!) to look up those first names.
<code>group-by</code> used that function to produce a <em>map</em> of first names to lists of
people&ndash;kind of like an index.</p>

<p>In general, we want to <em>combine</em> elements together in some way, using a
function. Where <code>map</code> treated each element independently, reducing a sequence
requires that we bring some information along. The most general way to collapse a sequence is <code>reduce</code>.</p>
<code class="block">user=&gt; (doc reduce)
-------------------------
clojure.core&#x2F;reduce
([f coll] [f val coll])
  f should be a function of 2 arguments. If val is not supplied,
  returns the result of applying f to the first 2 items in coll, then
  applying f to that result and the 3rd item, etc. If coll contains no
  items, f must accept no arguments as well, and reduce returns the
  result of calling f with no arguments.  If coll has only 1 item, it
  is returned and f is not called.  If val is supplied, returns the
  result of applying f to val and the first item in coll, then
  applying f to that result and the 2nd item, etc. If coll contains no
  items, returns val and f is not called.</code>
<p>That&rsquo;s a little complicated, so we&rsquo;ll start small. We need a function, <code>f</code>,
which combines successive elements of the sequence. <code>(f state element)</code> will
return the state for the <em>next</em> invocation of <code>f</code>. As <code>f</code> moves along the
sequence, it carries some changing state with it. The final state is the return
value of <code>reduce</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce + </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="mi">10</span>
</code>
<p><code>reduce</code> begins by calling <code>(+ 1 2)</code>, which yields the state <code>3</code>. Then it calls
<code>(+ 3 3)</code>, which yields <code>6</code>. Then <code>(+ 6 4)</code>, which returns <code>10</code>. We&rsquo;ve taken a
function over <em>two</em> elements, and used it to combine <em>all</em> the elements. Mathematically, we could write:</p>
<code class="block">1 + 2 + 3 + 4
    3 + 3 + 4
        6 + 4
           10</code>
<p>So another way to look at <code>reduce</code> is like sticking a function <em>between</em> each
pair of elements. To see the reducing process in action, we can use
<code>reductions</code>, which returns a sequence of all the intermediate states.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reductions</span> <span class="nb">+ </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">6</span> <span class="mi">10</span><span class="p">)</span>
</code>
<p>Oftentimes we include a <em>default</em> state to start with. For instance, we could
start with an empty set, and add each element to it as we go along:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce conj </span><span class="o">#</span><span class="p">{}</span> <span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:b</span> <span class="ss">:b</span> <span class="ss">:a</span> <span class="ss">:a</span><span class="p">])</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span>
</code>
<p>Reducing elements into a collection has its own name: <code>into</code>. We can conj <code>[key
value]</code> vectors into a map, for instance, or build up a list:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">into </span><span class="p">{}</span> <span class="p">[[</span><span class="ss">:a</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="ss">:b</span> <span class="mi">3</span><span class="p">]])</span>
<span class="p">{</span><span class="ss">:a</span> <span class="mi">2</span>, <span class="ss">:b</span> <span class="mi">3</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">list</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code>
<p>Because elements added to a list appear at the <em>beginning</em>, not the end, this
expression reverses the sequence. Vectors <code>conj</code> onto the end, so to emit the
elements in order, using <code>reduce</code>, we might try:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce conj </span><span class="p">[]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
<span class="p">(</span><span class="nb">reduce conj </span><span class="p">[]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
</code>
<p>Which brings up an interesting thought: this looks an awful lot like <code>map</code>. All that&rsquo;s missing is some kind of transformation applied to each element.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-map</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">output</span> <span class="nv">element</span><span class="p">]</span>
            <span class="p">(</span><span class="nb">conj </span><span class="nv">output</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">element</span><span class="p">)))</span>
          <span class="p">[]</span>
          <span class="nv">coll</span><span class="p">))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">my-map</span> <span class="nb">inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
</code>
<p>Huh. <code>map</code> is just a special kind of <code>reduce</code>. What about, say, <code>take-while</code>?</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">my-take-while</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">out</span> <span class="nv">elem</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">f</span> <span class="nv">elem</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">conj </span><span class="nv">out</span> <span class="nv">elem</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">reduced</span> <span class="nv">out</span><span class="p">)))</span>
          <span class="p">[]</span>
          <span class="nv">coll</span><span class="p">))</span>
</code>
<p>We&rsquo;re using a special function here, <code>reduced</code>, to indicate that we&rsquo;ve
completed our reduction <em>early</em> and can skip the rest of the sequence.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">my-take-while</span> <span class="nb">pos? </span><span class="p">[</span><span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">-1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">1</span><span class="p">]</span>
</code>
<p><code>reduce</code> really is the uberfunction over sequences. Almost any
operation on a sequence can be expressed in terms of a reduce&ndash;though for
various reasons, many of the Clojure sequence functions are not written this
way. For instance, <code>take-while</code> is <em>actually</em> defined like so:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">take-while</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">take-while</span>
  <span class="s">&quot;Returns a lazy sequence of successive items from coll while</span>
<span class="s">  (pred item) returns true. pred must be free of side-effects.&quot;</span>
  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span>
   <span class="ss">:static</span> <span class="nv">true</span><span class="p">}</span>
  <span class="p">[</span><span class="nv">pred</span> <span class="nv">coll</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">lazy-seq</span>
   <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">coll</span><span class="p">)]</span>
       <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">))</span>
         <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">first </span><span class="nv">s</span><span class="p">)</span> <span class="p">(</span><span class="nb">take-while </span><span class="nv">pred</span> <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)))))))</span>
</code>
<p>There&rsquo;s a few new pieces here, but the structure is <em>essentially</em> the same as
our initial attempt at writing <code>map</code>. When the predicate matches the first
element, cons the first element onto <code>take-while</code>, applied to the rest of the
sequence. That <code>lazy-seq</code> construct allows Clojure to compute this sequence <em>as
required</em>, instead of right away. It defers execution to a later time.</p>

<p>Most of Clojure&rsquo;s sequence functions are lazy. They don&rsquo;t do anything until
needed. For instance, we can increment every number from zero to infinity:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">infseq</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/infseq</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">realized?</span> <span class="nv">infseq</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p>That function returned <em>immediately</em>. Because it hasn&rsquo;t done any work yet, we
say the sequence is <em>unrealized</em>. It doesn&rsquo;t increment any numbers at all until
we ask for them:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">infseq</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">realized?</span> <span class="nv">infseq</span><span class="p">)</span>
<span class="nv">true</span>
</code>
<p>Lazy sequences also <em>remember</em> their contents, once evaluated, for faster
access.</p>

<h2>Putting it all together</h2>

<p>We&rsquo;ve seen how recursion generalizes a function over <em>one</em> thing into a
function over <em>many</em> things, and discovered a rich landscape of recursive
functions over sequences. Now let&rsquo;s use our knowledge of sequences to solve a
more complex problem: find the sum of the products of consecutive pairs of the
first 1000 odd integers.</p>

<p>First, we&rsquo;ll need the integers. We can start with 0, and work our way up to
infinity. To save time printing an infinite number of integers, we&rsquo;ll start
with just the first 10.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</code>
<p>Now we need to find only the ones which are odd. Remember, <code>filter</code> pares down
a sequence to only those elements which pass a test.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span> <span class="mi">17</span> <span class="mi">19</span><span class="p">)</span>
</code>
<p>For consecutive pairs, we want to take <code>[1 3 5 7 ...]</code> and find a sequence like <code>([1 3] [3 5] [5 7] ...)</code>. That sounds like a job for <code>partition</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">))))</span>
<span class="p">((</span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="mi">11</span><span class="p">))</span>
</code>
<p>Not quite right&ndash;this gave us non-overlapping pairs, but we wanted overlapping
ones too. A quick check of <code>(doc partition)</code> reveals the <code>step</code> parameter:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">))))</span>
<span class="p">((</span><span class="mi">1</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">))</span>
</code>
<p>Now we need to find the product for each pair. Given a pair, multiply the two
pieces together&hellip; yes, that sounds like <code>map</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pair</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">first </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">pair</span><span class="p">)))</span>
                    <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)))))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">15</span> <span class="mi">35</span><span class="p">)</span>
</code>
<p>Getting a bit unwieldy, isn&rsquo;t it? Only one final step: sum all those products.
We&rsquo;ll adjust the <code>take</code> to include the first 1000, not the first 3, elements.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span>
               <span class="p">(</span><span class="nb">take </span><span class="mi">1000</span>
                     <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pair</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">first </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">pair</span><span class="p">)))</span>
                          <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="mi">1</span>
                                    <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span>
                                            <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">0</span><span class="p">)))))</span>
<span class="mi">1335333000</span>
</code>
<p>The sum of the first thousand products of consecutive pairs of the odd integers
starting at 0. See how each part leads to the next? This expression looks a lot
like the way we phrased the problem in English&ndash;but both English and Lisp
expressions are sort of backwards, in a way. The part that <em>happens first</em>
appears <em>deepest</em>, <em>last</em>, in the expression. In a chain of reasoning like
this, it&rsquo;d be nicer to write it in order.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="mi">0</span>
            <span class="p">(</span><span class="nb">iterate </span><span class="nv">inc</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">partition</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">pair</span><span class="p">]</span>
                   <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">first </span><span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">second </span><span class="nv">pair</span><span class="p">))))</span>
            <span class="p">(</span><span class="nb">take </span><span class="mi">1000</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="mi">1335333000</span>
</code>
<p>Much easier to read: now everything flows in order, from top to bottom, and
we&rsquo;ve flattened out the deeply nested expressions into a single level. This is
how object-oriented languages structure their expressions: as a chain of
function invocations, each acting on the previous value.</p>

<p>But how is this possible? Which expression gets evaluated first? <code>(take 1000)</code>
isn&rsquo;t even a valid call&ndash;where&rsquo;s its second argument? How are <em>any</em> of these
forms evaluated?</p>

<p>What kind of arcane function <em>is</em> <code>-&gt;&gt;</code>?</p>

<p>All these mysteries, and more, in <a href="/posts/305-clojure-from-the-ground-up-macros">Chapter 5: Macros</a>.</p>

<h2>Problems</h2>

<ol>
<li>Write a function to find out if a string is a palindrome&ndash;that is, if it
looks the same forwards and backwards.</li>
<li>Find the number of &lsquo;c&rsquo;s in &ldquo;abracadabra&rdquo;.</li>
<li>Write your own version of <code>filter</code>.</li>
<li>Find the first 100 prime numbers: 2, 3, 5, 7, 11, 13, 17, &hellip;.</li>
</ol>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/303-clojure-from-the-ground-up-functions">Clojure from the ground up: functions</a></h1>
    </div>
    <div class="body">
      <p>We <a href="/posts/302-clojure-from-the-ground-up-basic-types">left off last chapter</a> with a question: what <em>are</em> verbs, anyway? When you evaluate <code>(type :mary-poppins)</code>, what really happens?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="ss">:mary-poppins</span><span class="p">)</span>
<span class="nv">clojure.lang.Keyword</span>
</code>
<p>To understand how <code>type</code> works, we&rsquo;ll need several new ideas. First, we&rsquo;ll expand on the notion of symbols as references to other values. Then we&rsquo;ll learn about functions: Clojure&rsquo;s verbs. Finally, we&rsquo;ll use the Var system to explore and change the definitions of those functions.</p>

<h2>Let bindings</h2>

<p>We know that symbols are names for things, and that when evaluated, Clojure replaces those symbols with their corresponding values. <code>+</code>, for instance, is a symbol which points to the verb <code>#&lt;core$_PLUS_ clojure.core$_PLUS_@12992c&gt;</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">+</span>
<span class="o">#</span><span class="nv">&lt;core$_PLUS_</span> <span class="nv">clojure.core$_PLUS_</span><span class="o">@</span><span class="mi">12992</span><span class="nv">c&gt;</span>
</code>
<p>When you try to use a symbol which has no defined meaning, Clojure refuses:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">cats</span>

<span class="nv">CompilerException</span> <span class="nv">java.lang.RuntimeException</span><span class="err">:</span> <span class="nv">Unable</span> <span class="nv">to</span> <span class="nb">resolve </span><span class="nv">symbol</span><span class="err">:</span> <span class="nv">cats</span> <span class="nv">in</span> <span class="nv">this</span> <span class="nv">context</span>, <span class="nv">compiling</span><span class="err">:</span><span class="p">(</span><span class="nf">NO_SOURCE_PATH</span><span class="ss">:0:0</span><span class="p">)</span>
</code>
<p>But we can define a meaning for a symbol within a specific expression, using <code>let</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cats</span> <span class="mi">5</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;I have &quot;</span> <span class="nv">cats</span> <span class="s">&quot; cats.&quot;</span><span class="p">))</span>
<span class="s">&quot;I have 5 cats.&quot;</span>
</code>
<p>The <code>let</code> expression first takes a vector of <em>bindings</em>: alternating symbols and values that those symbols are <em>bound</em> to, within the remainder of the expression. &ldquo;Let the symbol <code>cats</code> be 5, and construct a string composed of <code>&quot;I have &quot;</code>, <code>cats</code>, and <code>&quot; cats&quot;</code>.</p>

<p>Let bindings apply only within the let expression itself. They also override any existing definitions for symbols at that point in the program. For instance, we can redefine addition to mean subtraction, for the duration of a <code>let</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nb">+ </span><span class="nv">-</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">-1</span>
</code>
<p>But that definition doesn&rsquo;t apply outside the let:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">5</span>
</code>
<p>We can also provide <em>multiple</em> bindings. Since Clojure doesn&rsquo;t care about spacing, alignment, or newlines, I&rsquo;ll write this on multiple lines for clarity.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">person</span>   <span class="s">&quot;joseph&quot;</span>
             <span class="nv">num-cats</span> <span class="mi">186</span><span class="p">]</span>
         <span class="p">(</span><span class="nb">str </span><span class="nv">person</span> <span class="s">&quot; has &quot;</span> <span class="nv">num-cats</span> <span class="s">&quot; cats!&quot;</span><span class="p">))</span>
<span class="s">&quot;joseph has 186 cats!&quot;</span>
</code>
<p>When multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">cats</span> <span class="mi">3</span>
             <span class="nv">legs</span> <span class="p">(</span><span class="nb">* </span><span class="mi">4</span> <span class="nv">cats</span><span class="p">)]</span>
         <span class="p">(</span><span class="nb">str </span><span class="nv">legs</span> <span class="s">&quot; legs all together&quot;</span><span class="p">))</span>
<span class="s">&quot;12 legs all together&quot;</span>
</code>
<p>So fundamentally, <code>let</code> defines the meaning of symbols within an expression. When Clojure evaluates a <code>let</code>, it replaces all occurrences of those symbols in the rest of the <code>let</code> expression with their corresponding values, then evaluates the rest of the expression.</p>

<h2>Functions</h2>

<p>We saw in <a href="http://aphyr.com/posts/301-clojure-from-the-ground-up-first-principles">chapter one</a> that Clojure evaluates lists by <em>substituting</em> some other value in their place:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
</code>
<p><code>inc</code> takes any number, and is replaced by that number plus one. That sounds an awful lot like a let:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span> <span class="mi">1</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="mi">2</span>
</code>
<p>If we bound <code>x</code> to <code>5</code> instead of <code>1</code>, this expression would evaluate to <code>6</code>. We can think about <code>inc</code> like a let expression, but without particular values provided for the symbols.</p>
<code class="block"><span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</code>
<p>We can&rsquo;t actually evaluate this program, because there&rsquo;s no value for <code>x</code> yet. It could be 1, or 4, or 1453. We say that <code>x</code> is <em>unbound</em>, because it has no binding to a particular value. This is the nature of the <em>function</em>: an expression with unbound symbols.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;user$eval293$fn__294</span> <span class="nv">user$eval293$fn__294</span><span class="o">@</span><span class="mi">663</span><span class="nv">fc37&gt;</span>
</code>
<p>Does the name of that function remind you of anything?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">inc</span>
<span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">16</span><span class="nv">bc0b3c&gt;</span>
</code>
<p>Almost all verbs in Clojure are functions. Functions represent unrealized computation: expressions which are not yet evaluated, or incomplete. This particular function works just like <code>inc</code>: it&rsquo;s an expression which has a single unbound symbol, <code>x</code>. When we <em>invoke</em> the function with a particular value, the expressions in the function are evaluated with <code>x</code> bound to that value.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">((</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>We say that <code>x</code> is this functions <em>argument</em>, or <em>parameter</em>. When Clojure evaluates <code>(inc 2)</code>, we say that <code>inc</code> is <em>called</em> with <code>2</code>, or that <code>2</code> is <em>passed</em> to <code>inc</code>. The result of that <em>function invocation</em> is the function&rsquo;s <em>return value</em>. We say that <code>(inc 2)</code> <em>returns</em> <code>3</code>.</p>

<p>Fundamentally, functions describe the relationship between arguments and return values: given <code>1</code>, return <code>2</code>. Given <code>2</code>, return <code>3</code>, and so on. Let bindings describe a similar relationship, but with a specific set of values for those arguments. <code>let</code> is evaluated immediately, whereas <code>fn</code> is evaluated <em>later</em>, when bindings are provided.</p>

<p>There&rsquo;s a shorthand for writing functions, too: <code>#(+ % 1)</code> is equivalent to <code>(fn [x] (+ x 1))</code>. <code>%</code> takes the place of the first argument to the function. You&rsquo;ll sometime see <code>%1</code>, <code>%2</code>, etc. used for the first argument, second argument, and so on.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">burrito</span> <span class="o">#</span><span class="p">(</span><span class="nb">list </span><span class="s">&quot;beans&quot;</span> <span class="nv">%</span> <span class="s">&quot;cheese&quot;</span><span class="p">)]</span>
         <span class="p">(</span><span class="nf">burrito</span> <span class="s">&quot;carnitas&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="s">&quot;beans&quot;</span> <span class="s">&quot;carnitas&quot;</span> <span class="s">&quot;cheese&quot;</span><span class="p">)</span>
</code>
<p>Since functions exist to <em>defer</em> evaluation, there&rsquo;s no sense in creating and invoking them in the same expression as we&rsquo;ve done here. What we want is to give <em>names</em> to our functions, so they can be recombined in different ways.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">twice</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))]</span>
         <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">twice</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">twice</span> <span class="mi">3</span><span class="p">)))</span>
<span class="mi">8</span>
</code>
<p>Compare that expression to an equivalent, expanded form:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</code>
<p>The name <code>twice</code> is gone, and in its place is the same sort of computation&ndash;<code>(* 2 something)</code>&ndash;written twice. While we <em>could</em> represent our programs as a single massive expression, it&rsquo;d be impossible to reason about. Instead, we use functions to compact redundant expressions, by isolating common patterns of computation. Symbols help us re-use those functions (and other values) in more than one place. By giving the symbols meaningful names, we make it easier to reason about the structure of the program as a whole; breaking it up into smaller, understandable parts.</p>

<p>This is core pursuit of software engineering: organizing expressions. Almost every programming language is in search of the right tools to break apart, name, and recombine expressions to solve large problems. In Clojure we&rsquo;ll see one particular set of tools for composing programs, but the underlying ideas will transfer to many other languages.</p>

<h2>Vars</h2>

<p>We&rsquo;ve used <code>let</code> to define a symbol within an expression, but what about the default meanings of <code>+</code>, <code>conj</code>, and <code>type</code>? Are they also <code>let</code> bindings? Is the whole universe one giant <code>let</code>?</p>

<p>Well, not exactly. That&rsquo;s one way to think about default bindings, but it&rsquo;s brittle. We&rsquo;d need to wrap our whole program in a new <code>let</code> expression every time we wanted to change the meaning of a symbol. And moreover, once a <code>let</code> is defined, there&rsquo;s no way to change it. If we want to redefine symbols for <em>everyone</em>&ndash;even code that we didn&rsquo;t write&ndash;we need a new construct: a <em>mutable</em> variable.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">cats</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/cats</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="o">#</span><span class="ss">&#39;user/cats</span><span class="p">)</span>
<span class="nv">clojure.lang.Var</span>
</code>
<p><code>def</code> <em>defines</em> a type of value we haven&rsquo;t seen before: a var. Vars, like symbols, are references to other values. When evaluated, a symbol pointing to a var is replaced by the var&rsquo;s corresponding value:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">user/cats</span>
<span class="mi">5</span>
</code>
<p><code>def</code> also <em>binds</em> the symbol <code>cats</code> (and its globally qualified equivalent <code>user/cats</code>) to that var.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">user/cats</span>
<span class="mi">5</span>
<span class="nv">user=&gt;</span> <span class="nv">cats</span>
<span class="mi">5</span>
</code>
<p>When we said in chapter one that <code>inc</code>, <code>list</code>, and friends were symbols that pointed to functions, that wasn&rsquo;t the whole story. The symbol <code>inc</code> points to the var <code>#&#39;inc</code>, which in turn points to the function <code>#&lt;core$inc clojure.core$inc@16bc0b3c&gt;</code>. We can see the intermediate var with <code>resolve</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="ss">&#39;inc</span>
<span class="nb">inc </span><span class="c1">; the symbol</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">resolve </span><span class="ss">&#39;inc</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;clojure.core/inc</span> <span class="c1">; the var</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">eval </span><span class="ss">&#39;inc</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">16</span><span class="nv">bc0b3c&gt;</span> <span class="c1">; the value</span>
</code>
<p>Why two layers of indirection? Because unlike the symbol, we can <em>change</em> the meaning of a Var for everyone, globally, at any time.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">astronauts</span> <span class="p">[])</span>
<span class="o">#</span><span class="ss">&#39;user/astronauts</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="nv">astronauts</span><span class="p">)</span>
<span class="mi">0</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">astronauts</span> <span class="p">[</span><span class="s">&quot;Sally Ride&quot;</span> <span class="s">&quot;Guy Bluford&quot;</span><span class="p">])</span>
<span class="o">#</span><span class="ss">&#39;user/astronauts</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="nv">astronauts</span><span class="p">)</span>
<span class="mi">2</span>
</code>
<p>Notice that <code>astronauts</code> had <em>two</em> distinct meanings, depending on <em>when</em> we evaluated it. After the first <code>def</code>, astronauts was an empty vector. After the second <code>def</code>, it had one entry.</p>

<p>If this seems dangerous, you&rsquo;re a smart cookie. Redefining names in this way changes the meaning of expressions <em>everywhere</em> in a program, without warning. Expressions which relied on the value of a Var could suddenly take on new, possibly incorrect, meanings. It&rsquo;s a powerful tool for experimenting at the REPL, and for updating a running program, but it can have unexpected consequences. Good Clojurists use <code>def</code> to set up a program initially, and only change those definitions with careful thought.</p>

<p>Totally redefining a Var isn&rsquo;t the only option. There are safer, controlled ways to change the meaning of a Var within a particular part of a program, which we&rsquo;ll explore later.</p>

<h2>Defining functions</h2>

<p>Armed with <em>def</em>, we&rsquo;re ready to create our own named functions in Clojure.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">half</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">number</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">number</span> <span class="mi">2</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/half</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">half</span> <span class="mi">6</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>Creating a function and binding it to a var is so common that it has its own form: <code>defn</code>, short for <code>def</code> <code>fn</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">half</span> <span class="p">[</span><span class="nv">number</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">number</span> <span class="mi">2</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/half</span>
</code>
<p>Functions don&rsquo;t have to take an argument. We&rsquo;ve seen functions which take zero arguments, like <code>(+)</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">half</span> <span class="p">[]</span> <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/half</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">half</span><span class="p">)</span>
<span class="mi">1</span><span class="nv">/2</span>
</code>
<p>But if we try to use our earlier form with one argument, Clojure complains that the <em>arity</em>&ndash;the number of arguments to the function&ndash;is incorrect.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">half</span> <span class="mi">10</span><span class="p">)</span>

<span class="nv">ArityException</span> <span class="nv">Wrong</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">args</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="nv">passed</span> <span class="nv">to</span><span class="err">:</span> <span class="nv">user$half</span>  <span class="nv">clojure.lang.AFn.throwArity</span> <span class="p">(</span><span class="nf">AFn.java</span><span class="ss">:437</span><span class="p">)</span>
</code>
<p>To handle <em>multiple</em> arities, functions have an alternate form. Instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">half</span>
         <span class="p">([]</span>  <span class="mi">1</span><span class="nv">/2</span><span class="p">)</span>
         <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">half</span><span class="p">)</span>
<span class="mi">1</span><span class="nv">/2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">half</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">5</span>
</code>
<p>Multiple arguments work just like you expect. Just specify an argument vector of two, or three, or however many arguments the function takes.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">add</span>
         <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
         <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/add</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">add</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>Some functions can take <em>any</em> number of arguments. For that, Clojure provides <code>&amp;</code>, which slurps up all remaining arguments as a list:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">vargs</span>
         <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span> <span class="o">&amp;</span> <span class="nv">more-args</span><span class="p">]</span>
         <span class="p">{</span><span class="ss">:x</span>    <span class="nv">x</span>
          <span class="ss">:y</span>    <span class="nv">y</span>
          <span class="ss">:more</span> <span class="nv">more-args</span><span class="p">})</span>
<span class="o">#</span><span class="ss">&#39;user/vargs</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vargs</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">ArityException</span> <span class="nv">Wrong</span> <span class="nv">number</span> <span class="nv">of</span> <span class="nv">args</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="nv">passed</span> <span class="nv">to</span><span class="err">:</span> <span class="nv">user$vargs</span>  <span class="nv">clojure.lang.AFn.throwArity</span> <span class="p">(</span><span class="nf">AFn.java</span><span class="ss">:437</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vargs</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span>, <span class="ss">:y</span> <span class="mi">2</span>, <span class="ss">:more</span> <span class="nv">nil</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vargs</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span>, <span class="ss">:y</span> <span class="mi">2</span>, <span class="ss">:more</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)}</span>
</code>
<p>Note that <code>x</code> and <code>y</code> are mandatory, though there don&rsquo;t have to be any remaining arguments.</p>

<p>To keep track of what arguments a function takes, why the function exists, and what it does, we usually include a <em>docstring</em>. Docstrings help fill in the missing context around functions, to explain their assumptions, context, and purpose to the world.</p>
<code class="block"><span class="p">(</span><span class="kd">defn </span><span class="nv">launch</span>
  <span class="s">&quot;Launches a spacecraft into the given orbit by initiating a</span>
<span class="s">   controlled on-axis burn. Does not automatically stage, but</span>
<span class="s">   does vector thrust, if the craft supports it.&quot;</span>
  <span class="p">[</span><span class="nv">craft</span> <span class="nv">target-orbit</span><span class="p">]</span>
  <span class="s">&quot;OK, we don&#39;t know how to control spacecraft yet.&quot;</span><span class="p">)</span>
</code>
<p>Docstrings are used to automatically generate documentation for Clojure programs, but you can also access them from the REPL.</p>
<code class="block">user=&gt; (doc launch)
-------------------------
user&#x2F;launch
([craft target-orbit])
   Launches a spacecraft into the given orbit by initiating a
   controlled on-axis burn. Does not automatically stage, but
   does vector thrust, if the craft supports it.
nil</code>
<p><code>doc</code> tells us the full name of the function, the arguments it accepts, and its docstring. This information comes from the <code>#&#39;launch</code> var&rsquo;s <em>metadata</em>, and is saved there by <code>defn</code>. We can inspect metadata directly with the <code>meta</code> function:</p>
<code class="block"><span class="p">(</span><span class="nb">meta </span><span class="o">#</span><span class="ss">&#39;launch</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:arglists</span> <span class="p">([</span><span class="nv">craft</span> <span class="nv">target-orbit</span><span class="p">])</span>, <span class="ss">:ns</span> <span class="o">#</span><span class="nv">&lt;Namespace</span> <span class="nv">user&gt;</span>, <span class="ss">:name</span> <span class="nv">launch!</span>, <span class="ss">:column</span> <span class="mi">1</span>, <span class="ss">:doc</span> <span class="s">&quot;Launches a spacecraft into the given orbit.&quot;</span>, <span class="ss">:line</span> <span class="mi">1</span>, <span class="ss">:file</span> <span class="s">&quot;NO_SOURCE_PATH&quot;</span><span class="p">}</span>
</code>
<p>There&rsquo;s some other juicy information in there, like the file the function was defined in and which line and column it started at, but that&rsquo;s not particularly useful since we&rsquo;re in the REPL, not a file. However, this <em>does</em> hint at a way to answer our motivating question: how does the <code>type</code> function work? </p>

<h2>How does type work?</h2>

<p>We know that <code>type</code> returns the type of an object:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">java.lang.long</span>
</code>
<p>And that <code>type</code>, like all functions, is a kind of object with its own unique type:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">type</span>
<span class="o">#</span><span class="nv">&lt;core$type</span> <span class="nv">clojure.core$type</span><span class="o">@</span><span class="mi">39</span><span class="nv">bda9b9&gt;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="nv">type</span><span class="p">)</span>
<span class="nv">clojure.core$type</span>
</code>
<p>This tells us that <code>type</code> is a particular <em>instance</em>, at memory address <code>39bda9b9</code>, of the type <code>clojure.core$type</code>. <code>clojure.core</code> is a namespace which defines the fundamentals of the Clojure language, and <code>$type</code> tells us that it&rsquo;s named <code>type</code> in that namespace. None of this is particularly helpful, though. Maybe we can find out more about the <code>clojure.core$type</code> by asking what its <em>supertypes</em> are:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">supers</span> <span class="p">(</span><span class="nf">type</span> <span class="nv">type</span><span class="p">))</span>
<span class="o">#</span><span class="p">{</span><span class="nv">clojure.lang.AFunction</span> <span class="nv">clojure.lang.IMeta</span> <span class="nv">java.util.concurrent.Callable</span> <span class="nv">clojure.lang.Fn</span> <span class="nv">clojure.lang.AFn</span> <span class="nv">java.util.Comparator</span> <span class="nv">java.lang.Object</span> <span class="nv">clojure.lang.RestFn</span> <span class="nv">clojure.lang.IObj</span> <span class="nv">java.lang.Runnable</span> <span class="nv">java.io.Serializable</span> <span class="nv">clojure.lang.IFn</span><span class="p">}</span>
</code>
<p>This is a set of all the types that include <code>type</code>. We say that <code>type</code> is an <em>instance</em> of <code>clojure.lang.AFunction</code>, or that it <em>implements</em> or <em>extends</em> <code>java.util.concurrent.Callable</code>, and so on. Since it&rsquo;s a member of <code>clojure.lang.IMeta</code> it has metadata, and since it&rsquo;s a member of clojure.lang.AFn, it&rsquo;s a function. Just to double check, let&rsquo;s confirm that <code>type</code> is indeed a function:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">fn?</span> <span class="nv">type</span><span class="p">)</span>
<span class="nv">true</span>
</code>
<p>What about its documentation?</p>
<code class="block">user=&gt; (doc type)
-------------------------
clojure.core&#x2F;type
([x])
  Returns the :type metadata of x, or its Class if none
nil</code>
<p>Ah, that&rsquo;s helpful. <code>type</code> can take a single argument, which it calls <code>x</code>. If it has <code>:type</code> metadata, that&rsquo;s what it returns. Otherwise, it returns the class of <code>x</code>. Let&rsquo;s take a deeper look at <code>type</code>&rsquo;s metadata for more clues.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">meta </span><span class="o">#</span><span class="ss">&#39;type</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:ns</span> <span class="o">#</span><span class="nv">&lt;Namespace</span> <span class="nv">clojure.core&gt;</span>, <span class="ss">:name</span> <span class="nv">type</span>, <span class="ss">:arglists</span> <span class="p">([</span><span class="nv">x</span><span class="p">])</span>, <span class="ss">:column</span> <span class="mi">1</span>, <span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span>, <span class="ss">:static</span> <span class="nv">true</span>, <span class="ss">:doc</span> <span class="s">&quot;Returns the :type metadata of x, or its Class if none&quot;</span>, <span class="ss">:line</span> <span class="mi">3109</span>, <span class="ss">:file</span> <span class="s">&quot;clojure/core.clj&quot;</span><span class="p">}</span>
</code>
<p>Look at that! This function was first added to Clojure in version 1.0, and is defined in the file <code>clojure/core.clj</code>, on line 3109. We could go dig up the Clojure source code and read its definition there&ndash;or we could ask Clojure to do it for us:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">type</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">type</span> 
  <span class="s">&quot;Returns the :type metadata of x, or its Class if none&quot;</span>
  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.0&quot;</span>
   <span class="ss">:static</span> <span class="nv">true</span><span class="p">}</span>
  <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nb">meta </span><span class="nv">x</span><span class="p">)</span> <span class="ss">:type</span><span class="p">)</span> <span class="p">(</span><span class="nb">class </span><span class="nv">x</span><span class="p">)))</span>
<span class="nv">nil</span>
</code>
<p>Aha! Here, at last, is how <code>type</code> works. It&rsquo;s a function which takes a single argument <code>x</code>, and returns either <code>:type</code> from its metadata, or <code>(class x)</code>.</p>

<p>We can delve into any function in Clojure using these tools:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">+</span><span class="p">)</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">+</span>
  <span class="s">&quot;Returns the sum of nums. (+) returns 0. Does not auto-promote</span>
<span class="s">  longs, will throw on overflow. See also: +&#39;&quot;</span>
  <span class="p">{</span><span class="ss">:inline</span> <span class="p">(</span><span class="nf">nary-inline</span> <span class="ss">&#39;add</span> <span class="ss">&#39;unchecked_add</span><span class="p">)</span>
   <span class="ss">:inline-arities</span> <span class="nv">&gt;1?</span>
   <span class="ss">:added</span> <span class="s">&quot;1.2&quot;</span><span class="p">}</span>
  <span class="p">([]</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">([</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">cast </span><span class="nv">Number</span> <span class="nv">x</span><span class="p">))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="k">. </span><span class="nv">clojure.lang.Numbers</span> <span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
  <span class="p">([</span><span class="nv">x</span> <span class="nv">y</span> <span class="o">&amp;</span> <span class="nv">more</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">reduce1</span> <span class="nb">+ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">more</span><span class="p">)))</span>
<span class="nv">nil</span>
</code>
<p>Almost every function in a programming language is made up of other, simpler functions. <code>+</code>, for instance, is defined in terms of <code>cast</code>, <code>add</code>, and <code>reduce1</code>. Sometimes functions are defined in terms of themselves. <code>+</code> uses itself twice in this definition; a technique called <em>recursion</em>.</p>

<p>At the bottom, though, are certain fundamental constructs below which you can go no further. Core axioms of the language. Lisp calls these &quot;special forms&rdquo;. <code>def</code> and <code>let</code> are special forms (well&ndash;almost: <code>let</code> is a thin wrapper around <code>let*</code>, which is a special form) in Clojure. These forms are defined by the core implementation of the language, and are not reducible to other Clojure expressions.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">source</span> <span class="nv">def</span><span class="p">)</span>
<span class="nv">Source</span> <span class="nb">not </span><span class="nv">found</span>
</code>
<p>Some Lisps are written <em>entirely</em> in terms of a few special forms, but Clojure is much less pure. Many functions bottom out in Java functions and types, or, for CLJS, in terms of Javascript. Any time you see an expression like <code>(. clojure.lang.Numbers (add x y))</code>, there&rsquo;s Java code underneath. Below Java lies the JVM, which might be written in C or C++, depending on which one you use. And underneath C and C++ lie more libraries, the operating system, assembler, microcode, registers, and ultimately, electrons flowing through silicon.</p>

<p>A well-designed language <em>isolates</em> you from details you don&rsquo;t need to worry about, like which logic gates or registers to use, and lets you focus on the task at hand. Good languages also need to allow escape hatches for performance or access to dangerous functionality, as we saw with Vars. You can write entire programs entirely in terms of Clojure, but sometimes, for performance or to use tools from other languages, you&rsquo;ll rely on Java. The Clojure code is easy to explore with <code>doc</code> and <code>source</code>, but Java can be more opaque&ndash;I usually rely on the java source files and online documentation.</p>

<h2>Review</h2>

<p>We&rsquo;ve seen how <code>let</code> associates names with values in a particular expression, and how Vars allow for <em>mutable</em> bindings which apply universally. and whose definitions can change over time. We learned that Clojure verbs are functions, which express the general shape of an expression but with certain values <em>unbound</em>. Invoking a function <em>binds</em> those variables to specific values, allowing evaluation of the function to proceed.</p>

<p>Functions <em>decompose</em> programs into simpler pieces, expressed in terms of one another. Short, meaningful names help us understand what those functions (and other values) mean.</p>

<p>Finally, we learned how to introspect Clojure functions with <code>doc</code> and <code>source</code>, and saw the definition of some basic Clojure functions. The <a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a> gives a comprehensive list of the core functions in the language, and is a great starting point when you have to solve a problem but don&rsquo;t know what functions to use.</p>

<p>We&rsquo;ll see a broad swath of those functions in <a href="http://aphyr.com/posts/304-clojure-from-the-ground-up-sequences">Chapter 4: Sequences</a>.</p>

<p><em>My thanks to Zach Tellman, Kelly Sommers, and Michael R Bernstein for reviewing drafts of this chapter.</em></p>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/302-clojure-from-the-ground-up-basic-types">Clojure from the ground up: basic types</a></h1>
    </div>
    <div class="body">
      <p>We&rsquo;ve learned <a href="http://aphyr.com/posts/301-clojure-from-the-ground-up-first-principles">the basics of Clojure&rsquo;s syntax and evaluation model</a>. Now we&rsquo;ll take a tour of the basic nouns in the language.</p>

<h2>Types</h2>

<p>We&rsquo;ve seen a few different values already&ndash;for instance, <code>nil</code>, <code>true</code>, <code>false</code>, <code>1</code>, <code>2.34</code>, and <code>&quot;meow&quot;</code>. Clearly all these things are <em>different</em> values, but some of them seem more alike than others.</p>

<p>For instance, <code>1</code> and <code>2</code> are <em>very</em> similar numbers; both can be added, divided, multiplied, and subtracted. <code>2.34</code> is also a number, and acts very much like 1 and 2, but it&rsquo;s not quite the same. It&rsquo;s got <em>decimal</em> points. It&rsquo;s not an <em>integer</em>. And clearly <code>true</code> is <em>not</em> very much like a number. What is true plus one? Or false divided by 5.3? These questions are poorly defined.</p>

<p>We say that a <em>type</em> is a group of values which work in the same way. It&rsquo;s a <em>property</em> that some values share, which allows us to organize the world into sets of similar things. 1 + 1 and 1 + 2 use <em>the same addition</em>, which adds together integers. Types also help us <em>verify</em> that a program makes sense: that you can only add together numbers, instead of adding numbers to porcupines.</p>

<p>Types can overlap and intersect each other. Cats are animals, and cats are fuzzy too. You could say that a cat is a <em>member</em> (or sometimes &ldquo;instance&rdquo;), of the fuzzy and animal types. But there are fuzzy things like moss which <em>aren&rsquo;t</em> animals, and animals like alligators that aren&rsquo;t fuzzy in the slightest.</p>

<p>Other types completely subsume one another. All tabbies are housecats, and all housecats are felidae, and all felidae are animals. Everything which is true of an animal is automatically true of a housecat. Hierarchical types make it easier to write programs which don&rsquo;t need to know all the specifics of every value; and conversely, to create new types in terms of others. But they can also get in the way of the programmer, because not every useful classification (like &ldquo;fuzziness&rdquo;) is purely hierarchical. Expressing overlapping types in a hierarchy can be tricky.</p>

<p>Every language has a <em>type system</em>; a particular way of organizing nouns into types, figuring out which verbs make sense on which types, and relating types to one another. Some languages are strict, and others more relaxed. Some emphasize hierarchy, and others a more ad-hoc view of the world. We call Clojure&rsquo;s type system <em>strong</em> in that operations on improper types are simply not allowed: the program will explode if asked to subtract a dandelion. We also say that Clojure&rsquo;s types are <em>dynamic</em> because they are enforced when the program is run, instead of when the program is first read by the computer.</p>

<p>We&rsquo;ll learn more about the formal relationships between types later, but for now, keep this in the back of your head. It&rsquo;ll start to hook in to other concepts later.</p>

<h2>Integers</h2>

<p>Let&rsquo;s find the type of the number 3:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">java.lang.Long</span>
</code>
<p>So 3 is a <code>java.lang.Long</code>, or a &ldquo;Long&rdquo;, for short. Because Clojure is built on top of Java, many of its types are plain old Java types.</p>

<p>Longs, internally, are represented as a group of sixty-four binary digits (ones and zeroes), written down in a particular pattern called <a href="http://en.wikipedia.org/wiki/Two&#x27;s_complement">signed two&rsquo;s complement representation</a>. You don&rsquo;t need to worry about the specifics&ndash;there are only two things to remember about longs. First, longs use one bit to store the sign: whether the number is positive or negative. Second, the other 63 bits represent the <em>size</em> of the number. That means the biggest number you can represent with a long is 2<sup>63</sup> - 1 (the minus one is because of the number 0), and the smallest long is -2<sup>63</sup>.</p>

<p>How big is 2<sup>63</sup> - 1?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">Long/MAX_VALUE</span>
<span class="mi">9223372036854775807</span>
</code>
<p>That&rsquo;s a reasonably big number. Most of the time, you won&rsquo;t need anything bigger, but&hellip; what if you did? What happens if you add one to the biggest Long?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">Long/MAX_VALUE</span><span class="p">)</span>

<span class="nv">ArithmeticException</span> <span class="nv">integer</span> <span class="nv">overflow</span>  <span class="nv">clojure.lang.Numbers.throwIntOverflow</span> <span class="p">(</span><span class="nf">Numbers.java</span><span class="ss">:1388</span><span class="p">)</span>
</code>
<p>An error occurs! This is Clojure telling us that something went wrong. The type of error was an <code>ArithmeticException</code>, and its message was &ldquo;integer overflow&rdquo;, meaning &ldquo;this type of number can&rsquo;t hold a number that big&rdquo;. The error came from a specific <em>place</em> in the source code of the program: <code>Numbers.java</code>, on line 1388. That&rsquo;s a part of the Clojure source code. Later, we&rsquo;ll learn more about how to unravel error messages and find out what went wrong.</p>

<p>The important thing is that Clojure&rsquo;s type system <em>protected</em> us from doing something dangerous; instead of returning a corrupt value, it aborted evaluation and returned an error.</p>

<p>If you <em>do</em> need to talk about really big numbers, you can use a BigInt: an arbitrary-precision integer. Let&rsquo;s convert the biggest Long into a BigInt, then increment it:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nf">bigint</span> <span class="nv">Long/MAX_VALUE</span><span class="p">))</span>
<span class="mi">9223372036854775808</span><span class="nv">N</span>
</code>
<p>Notice the N at the end? That&rsquo;s how Clojure writes arbitrary-precision integers.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">5</span><span class="nv">N</span><span class="p">)</span>
<span class="nv">clojure.lang.BigInt</span>
</code>
<p>There are also smaller numbers.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">int </span><span class="mi">0</span><span class="p">))</span>
<span class="nv">java.lang.Integer</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">short </span><span class="mi">0</span><span class="p">))</span>
<span class="nv">java.lang.Short</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">byte </span><span class="mi">0</span><span class="p">))</span>
<span class="nv">java.lang.Byte</span>
</code>
<p>Integers are half the size of Longs; they store values in 32 bits. Shorts are 16 bits, and Bytes are 8. That means their biggest values are 2<sup>31</sup>-1, 2<sup>15</sup>-1, and 2<sup>7</sup>-1, respectively.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">Integer/MAX_VALUE</span>
<span class="mi">2147483647</span>
<span class="nv">user=&gt;</span> <span class="nv">Short/MAX_VALUE</span>
<span class="mi">32767</span>
<span class="nv">user=&gt;</span> <span class="nv">Byte/MAX_VALUE</span>
<span class="mi">127</span>
</code>
<h2>Fractional numbers</h2>

<p>To represent numbers <em>between</em> integers, we often use floating-point numbers, which can represent small numbers with fine precision, and large numbers with coarse precision. Floats use 32 bits, and Doubles use 64. Doubles are the default in Clojure.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mf">1.23</span><span class="p">)</span>
<span class="nv">java.lang.Double</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nb">float </span><span class="mf">1.23</span><span class="p">))</span>
<span class="nv">java.lang.Float</span>
</code>
<p>Floating point math is <a href="http://en.wikipedia.org/wiki/Floating_point">complicated</a>, and we won&rsquo;t get bogged down in the details just yet. The important thing to know is floats and doubles are <em>approximations</em>. There are limits to their correctness:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="mf">0.99999999999999999</span>
<span class="mf">1.0</span>
</code>
<p>To represent fractions exactly, we can use the <em>ratio</em> type:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">1</span><span class="nv">/3</span><span class="p">)</span>
<span class="nv">clojure.lang.Ratio</span>
</code>
<h2>Mathematical operations</h2>

<p>The exact behavior of mathematical operations in Clojure depends on their types. In general, though, Clojure aims to <em>preserve</em> information. Adding two longs returns a long; adding a double and a long returns a double.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="mf">3.0</span>
</code>
<p><code>3</code> and <code>3.0</code> are <em>not</em> the same number; one is a long, and the other a double. But for most purposes, they&rsquo;re equivalent, and Clojure will tell you so: </p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="nv">false</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">== </span><span class="mi">3</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="nv">true</span>
</code>
<p><code>=</code> asks whether all the things that follow are equal. Since floats are approximations, <code>=</code> considers them different from integers. <code>==</code> also compares things, but a little more loosely: it considers integers equivalent to their floating-point representations.</p>

<p>We can also subtract with <code>-</code>, multiply with <code>*</code>, and divide with <code>/</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">* </span><span class="mf">1.5</span> <span class="mi">3</span><span class="p">)</span>
<span class="mf">4.5</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">1</span><span class="nv">/2</span>
</code>
<p>Putting the verb <em>first</em> in each list allows us to add or multiply more than one number in the same step:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">6</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">1</span><span class="nv">/5</span><span class="p">)</span>
<span class="mi">6</span><span class="nv">/5</span>
</code>
<p>Subtraction with more than 2 numbers subtracts all later numbers from the first. Division divides the first number by all the rest.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">24</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">4</span>
</code>
<p>By extension, we can define useful interpretations for numeric operations with just a <em>single</em> number:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">- </span><span class="mi">2</span><span class="p">)</span>
<span class="mi">-2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">* </span><span class="mi">4</span><span class="p">)</span>
<span class="mi">4</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">4</span><span class="p">)</span>
<span class="mi">1</span><span class="nv">/4</span>
</code>
<p>We can also add or multiply a list of no numbers at all, obtaining the additive and multiplicative identities, respectively. This might seem odd, especially coming from other languages, but we&rsquo;ll see later that these generalizations make it easier to reason about higher-level numeric operations.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">+</span><span class="p">)</span>
<span class="mi">0</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">*</span><span class="p">)</span>
<span class="mi">1</span>
</code>
<p>Often, we want to ask which number is bigger, or if one number falls between two others. <code>&lt;=</code> means &ldquo;less than or equal to&rdquo;, and asserts that all following values are in order from smallest to biggest.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p><code>&lt;</code> means &ldquo;strictly less than&rdquo;, and works just like <code>&lt;=</code>, except that no two values may be equal.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&lt;= </span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&lt; </span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p>Their friends <code>&gt;</code> and <code>&gt;=</code> mean &ldquo;greater than&rdquo; and &ldquo;greater than or equal to&rdquo;, respectively, and assert that numbers are in descending order.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">&gt; </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p>Also commonly used are <code>inc</code> and <code>dec</code>, which add and subtract one to a number, respectively:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="mi">5</span><span class="p">)</span>
<span class="mi">6</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dec </span><span class="mi">5</span><span class="p">)</span>
<span class="mi">4</span>
</code>
<p>One final note: equality tests can take more than 2 numbers as well.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<h2>Strings</h2>

<p>We saw that strings are text, surrounded by double quotes, like <code>&quot;foo&quot;</code>. Strings in Clojure are, like Longs, Doubles, and company, backed by a Java type:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="s">&quot;cat&quot;</span><span class="p">)</span>
<span class="nv">java.lang.String</span>
</code>
<p>We can make almost <em>anything</em> into a string with <code>str</code>. Strings, symbols, numbers, booleans; every value in Clojure has a string representation. Note that <code>nil</code>&rsquo;s string representation is <code>&quot;&quot;</code>; an empty string.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;cat&quot;</span><span class="p">)</span>
<span class="s">&quot;cat&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="ss">&#39;cat</span><span class="p">)</span>
<span class="s">&quot;cat&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="mi">1</span><span class="p">)</span>
<span class="s">&quot;1&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">true</span><span class="p">)</span>
<span class="s">&quot;true&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="s">&quot;(1 2 3)&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">nil</span><span class="p">)</span>
<span class="s">&quot;&quot;</span>
</code>
<p><code>str</code> can also <em>combine</em> things together into a single string, which we call &ldquo;concatenation&rdquo;.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;meow &quot;</span> <span class="mi">3</span> <span class="s">&quot; times&quot;</span><span class="p">)</span>
<span class="s">&quot;meow 3 times&quot;</span>
</code>
<p>To look for patterns in text, we can use a <a href="http://www.regular-expressions.info/tutorial.html">regular expression</a>, which is a tiny language for describing particular arrangements of text. <code>re-find</code> and <code>re-matches</code> look for occurrences of a regular expression in a string. To find a cat:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;cat&quot;</span> <span class="s">&quot;mystic cat mouse&quot;</span><span class="p">)</span>
<span class="s">&quot;cat&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">re-find </span><span class="o">#</span><span class="s">&quot;cat&quot;</span> <span class="s">&quot;only dogs here&quot;</span><span class="p">)</span>
<span class="nv">nil</span>
</code>
<p>That <code>#&quot;...&quot;</code> is Clojure&rsquo;s way of writing a regular expression.</p>

<p>With <code>re-matches</code>, you can extract particular parts of a string which match an expression. Here we find two strings, separated by a <code>:</code>. The parentheses mean that the regular expression should <em>capture</em> that part of the match. We get back a list containing the part of the string that matched the first parentheses, followed by the part that matched the second parentheses.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rest </span><span class="p">(</span><span class="nb">re-matches </span><span class="o">#</span><span class="s">&quot;(.+):(.+)&quot;</span> <span class="s">&quot;mouse:treat&quot;</span><span class="p">))</span>
<span class="p">(</span><span class="s">&quot;mouse&quot;</span> <span class="s">&quot;treat&quot;</span><span class="p">)</span>
</code>
<p>Regular expressions are a powerful tool for searching and matching text, especially when working with data files. Since regexes work the same in most languages, you can use any guide online to learn more. It&rsquo;s not something you have to master right away; just learn specific tricks as you find you need them. For a deeper guide, try Fitzgerald&rsquo;s <a href="http://shop.oreilly.com/product/0636920012337.do">Introducing Regular Expressions</a>.</p>

<h2>Booleans and logic</h2>

<p>Everything in Clojure has a sort of charge, a truth value, sometimes called &ldquo;truthiness&rdquo;. <code>true</code> is positive and <code>false</code> is negative. <code>nil</code> is negative, too.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="nv">true</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="nv">false</span><span class="p">)</span>
<span class="nv">false</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p>Every other value in Clojure is positive.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="mi">0</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="mi">1</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="s">&quot;hi there&quot;</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">boolean </span><span class="nv">str</span><span class="p">)</span>
<span class="nv">true</span>
</code>
<p>If you&rsquo;re coming from a C-inspired language, where 0 is considered false, this might be a bit surprising. Likewise, in much of POSIX, 0 is considered success and nonzero values are failures. Lisp allows no such confusion: the only negative values are <code>false</code> and <code>nil</code>.</p>

<p>We can reason about truth values using <code>and</code>, <code>or</code>, and <code>not</code>. <code>and</code> returns the first negative value, or the last value if all are truthy.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">true</span> <span class="nv">false</span> <span class="nv">true</span><span class="p">)</span>
<span class="nv">false</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">true</span> <span class="nv">true</span> <span class="nv">true</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p>Similarly, <code>or</code> returns the first positive value.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">false</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">2</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">false</span> <span class="nv">nil</span><span class="p">)</span>
<span class="nv">nil</span>
</code>
<p>And <code>not</code> inverts the logical sense of a value:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">not </span><span class="mi">2</span><span class="p">)</span>
<span class="nv">false</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">not </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">true</span>
</code>
<p>We&rsquo;ll learn more about Boolean logic when we start talking about <em>control flow</em>; the way we alter evaluation of a program and express ideas like &ldquo;if I&rsquo;m a cat, then meow incessantly&rdquo;.</p>

<h2>Symbols</h2>

<p>We saw symbols in the previous chapter; they&rsquo;re bare strings of characters, like <code>foo</code> or <code>+</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="ss">&#39;str</span><span class="p">)</span>
<span class="nv">clojure.lang.Symbol</span>
</code>
<p>Symbols can have either short or full names. The short name is used to refer to things locally. The <em>fully qualified</em> name is used to refer unambiguously to a symbol from anywhere. If I were a symbol, my name would be &ldquo;Kyle&rdquo;, and my full name &ldquo;Kyle Kingsbury.&rdquo; </p>

<p>Symbol names are separated with a <code>/</code>. For instance, the symbol <code>str</code> is also present in a family called <code>clojure.core</code>; the corresponding full name is <code>clojure.core/str</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= str </span><span class="nv">clojure.core/str</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">name </span><span class="ss">&#39;clojure.core/str</span><span class="p">)</span>
<span class="s">&quot;str&quot;</span>
</code>
<p>When we talked about the maximum size of an integer, that was a fully-qualified symbol, too.</p>
<code class="block"><span class="p">(</span><span class="nf">type</span> <span class="ss">&#39;Integer/MAX_VALUE</span><span class="p">)</span>
<span class="nv">clojure.lang.Symbol</span>
</code>
<p>The job of symbols is to <em>refer</em> to things, to <em>point</em> to other values. When evaluating a program, symbols are looked up and replaced by their corresponding values. That&rsquo;s not the only use of symbols, but it&rsquo;s the most common.</p>

<h2>Keywords</h2>

<p>Closely related to symbols and strings are <em>keywords</em>, which begin with a <code>:</code>. Keywords are like strings in that they&rsquo;re made up of text, but are specifically intended for use as <em>labels</em> or <em>identifiers</em>. These <em>aren&rsquo;t</em> labels in the sense of symbols: keywords aren&rsquo;t replaced by any other value. They&rsquo;re just names, by themselves.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="ss">:cat</span><span class="p">)</span>
<span class="nv">clojure.lang.Keyword</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="ss">:cat</span><span class="p">)</span>
<span class="s">&quot;:cat&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">name </span><span class="ss">:cat</span><span class="p">)</span>
<span class="s">&quot;cat&quot;</span>
</code>
<p>As labels, keywords are most useful when paired with other values in a collection, like a <em>map</em>. Keywords can also be used as verbs to <em>look up specific values</em> in other data types. We&rsquo;ll learn more about keywords shortly.</p>

<h2>Lists</h2>

<p>A collection is a group of values. It&rsquo;s a <em>container</em> which provides some structure, some framework, for the things that it holds. We say that a collection contains <em>elements</em>, or <em>members</em>. We saw one kind of collection&ndash;a list&ndash;in the previous chapter.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">clojure.lang.PersistentList</span>
</code>
<p>Remember, we <em>quote</em> lists with a <code>&#39;</code> to prevent them from being evaluated. You can also construct a list using <code>list</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>Lists are comparable just like every other value:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">true</span>
</code>
<p>You can modify a list by <code>conj</code>oining an element onto it:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>We added 4 to the list&ndash;but it appeared at the <em>front</em>. Why? Internally, lists are stored as a <em>chain</em> of values: each link in the chain is a tiny box which holds the value and a connection to the next link. This 
data structure, called a linked list, offers immediate access to the first element.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">1</span>
</code>
<p>But getting to the second element requires an extra hop down the chain</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">second </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">2</span>
</code>
<p>and the third element a hop after that, and so on. </p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</code>
<p><code>nth</code> gets the element of an ordered collection at a particular <em>index</em>. The first element is index 0, the second is index 1, and so on.</p>

<p>This means that lists are well-suited for small collections, or collections which are read in linear order, but are slow when you want to get arbitrary elements from later in the list. For fast access to every element, we use a <em>vector</em>.</p>

<h2>Vectors</h2>

<p>Vectors are surrounded by square brackets, just like lists are surrounded by parentheses. Because vectors <em>aren&rsquo;t</em> evaluated like lists are, there&rsquo;s no need to quote them:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">clojure.lang.PersistentVector</span>
</code>
<p>You can also create vectors with <code>vector</code>, or change other structures into vectors with <code>vec</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">vector </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
</code>
<p><code>conj</code> on a vector adds to the <em>end</em>, not the <em>start</em>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</code>
<p>Our friends <code>first</code>, <code>second</code>, and <code>nth</code> work here too; but unlike lists, <code>nth</code> is <em>fast</em> on vectors. That&rsquo;s because internally, vectors are represented as a very broad tree of elements, where each part of the tree branches into 32 smaller trees. Even very large vectors are only a few layers deep, which means getting to elements only takes a few hops.</p>

<p>In addition to <code>first</code>, you&rsquo;ll often want to get the <em>remaining</em> elements in a collection. There are two ways to do this:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rest </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p><code>rest</code> and <code>next</code> both return &ldquo;everything but the first element&rdquo;. They differ only by what happens when there are no remaining elements:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rest </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">()</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nv">nil</span>
</code>
<p><code>rest</code> returns logical true, <code>next</code> returns logical false. Each has their uses, but in almost every case they&rsquo;re equivalent&ndash;I interchange them freely.</p>

<p>We can get the final element of any collection with <code>last</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">last </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="mi">3</span>
</code>
<p>And figure out how big the vector is with <code>count</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="mi">3</span>
</code>
<p>Because vectors are intended for looking up elements by index, we can also use them directly as <em>verbs</em>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">([</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">]</span> <span class="mi">1</span><span class="p">)</span>
<span class="ss">:b</span>
</code>
<p>So we took the vector containing three keywords, and asked &ldquo;What&rsquo;s the element at index 1?&rdquo; Lisp, like most (but not all!) modern languages, counts up from <em>zero</em>, not one. Index 0 is the first element, index 1 is the second element, and so on. In this vector, finding the element at index 1 evaluates to <code>:b</code>.</p>

<p>Finally, note that vectors and lists containing the same elements are considered equal in Clojure:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">true</span>
</code>
<p>In almost all contexts, you can consider vectors, lists, and other sequences as interchangeable. They only differ in their performance characteristics, and in a few data-structure-specific operations.</p>

<h2>Sets</h2>

<p>Sometimes you want an unordered collection of values; especially when you plan to ask questions like &ldquo;does the collection have the number 3 in it?&rdquo; Clojure, like most languages, calls these collections <em>sets</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>
</code>
<p>Sets are surrounded by <code>#{...}</code>. Notice that though we gave the elements <code>:a</code>, <code>:b</code>, and <code>:c</code>, they came out in a different order. In general, the order of sets can shift at any time. If you want a particular order, you can ask for it as a list or vector:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vec</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="p">[</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">]</span>
</code>
<p>Or ask for the elements in sorted order:</p>
<code class="block"><span class="p">(</span><span class="nb">sort </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="p">(</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">)</span>
</code>
<p><code>conj</code> on a set adds an element:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="ss">:d</span><span class="p">)</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span> <span class="ss">:d</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="ss">:a</span><span class="p">)</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>
</code>
<p>Sets never contain an element more than once, so <code>conj</code>ing an element which is already present does nothing. Conversely, one removes elements with <code>disj</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">disj </span><span class="o">#</span><span class="p">{</span><span class="s">&quot;hornet&quot;</span> <span class="s">&quot;hummingbird&quot;</span><span class="p">}</span> <span class="s">&quot;hummingbird&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="p">{</span><span class="s">&quot;hornet&quot;</span><span class="p">}</span>
</code>
<p>The most common operation with a set is to check whether something is inside it. For this we use <code>contains?</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">5</span><span class="p">)</span>
<span class="nv">false</span>
</code>
<p>Like vectors, you can use the set <em>itself</em> as a verb. Unlike <code>contains?</code>, this expression returns the element itself (if it was present), or <code>nil</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">nil</span>
</code>
<p>You can make a set out of any other collection with <code>set</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">])</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>
</code>
<h2>Maps</h2>

<p>The last collection on our tour is the <em>map</em>: a data structure which associates <em>keys</em> with <em>values</em>. In a dictionary, the keys are words and the definitions are the values. In a library, keys are call signs, and the books are values. Maps are indexes for looking things up, and for representing different pieces of named information together. Here&rsquo;s a cat:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;mittens&quot;</span> <span class="ss">:weight</span> <span class="mi">9</span> <span class="ss">:color</span> <span class="s">&quot;black&quot;</span><span class="p">}</span>
<span class="p">{</span><span class="ss">:weight</span> <span class="mi">9</span>, <span class="ss">:name</span> <span class="s">&quot;mittens&quot;</span>, <span class="ss">:color</span> <span class="s">&quot;black&quot;</span><span class="p">}</span>
</code>
<p>Maps are surrounded by braces <code>{...}</code>, filled by alternating keys and values. In this map, the three keys are <code>:name</code>, <code>:color</code>, and <code>:weight</code>, and their values are <code>&quot;mittens&quot;</code>, <code>&quot;black&quot;</code>, and 9, respectively. We can look up the corresponding value for a key with <code>get</code>:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="s">&quot;cat&quot;</span> <span class="s">&quot;meow&quot;</span> <span class="s">&quot;dog&quot;</span> <span class="s">&quot;woof&quot;</span><span class="p">}</span> <span class="s">&quot;cat&quot;</span><span class="p">)</span>
<span class="s">&quot;meow&quot;</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="ss">:c</span><span class="p">)</span>
<span class="nv">nil</span>
</code>
<p><code>get</code> can also take a <em>default</em> value to return instead of nil, if the key doesn&rsquo;t exist in that map.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="p">{</span><span class="ss">:glinda</span> <span class="ss">:good</span><span class="p">}</span> <span class="ss">:wicked</span> <span class="ss">:not-here</span><span class="p">)</span>
<span class="ss">:not-here</span>
</code>
<p>Since lookups are so important for maps, we can use a map as a verb directly:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">({</span><span class="s">&quot;amlodipine&quot;</span> <span class="mi">12</span> <span class="s">&quot;ibuprofen&quot;</span> <span class="mi">50</span><span class="p">}</span> <span class="s">&quot;ibuprofen&quot;</span><span class="p">)</span>
<span class="mi">50</span>
</code>
<p>And conversely, keywords can <em>also</em> be used as verbs, which look themselves up in maps:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="ss">:raccoon</span> <span class="p">{</span><span class="ss">:weasel</span> <span class="s">&quot;queen&quot;</span> <span class="ss">:raccoon</span> <span class="s">&quot;king&quot;</span><span class="p">})</span>
<span class="s">&quot;king&quot;</span>
</code>
<p>You can add a value for a given key to a map with <code>assoc</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:bolts</span> <span class="mi">1088</span><span class="p">}</span> <span class="ss">:camshafts</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:camshafts</span> <span class="mi">3</span> <span class="ss">:bolts</span> <span class="mi">1088</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:camshafts</span> <span class="mi">3</span><span class="p">}</span> <span class="ss">:camshafts</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:camshafts</span> <span class="mi">2</span><span class="p">}</span>
</code>
<p>Assoc adds keys if they aren&rsquo;t present, and <em>replaces</em> values if they&rsquo;re already there. If you associate a value onto <code>nil</code>, it creates a new map.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">nil</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">{</span><span class="mi">5</span> <span class="mi">2</span><span class="p">}</span>
</code>
<p>You can combine maps together using <code>merge</code>, which yields a map containing all the elements of <em>all</em> given maps, preferring the values from later ones.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">merge </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:b</span> <span class="mi">3</span> <span class="ss">:c</span> <span class="mi">4</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:c</span> <span class="mi">4</span>, <span class="ss">:a</span> <span class="mi">1</span>, <span class="ss">:b</span> <span class="mi">3</span><span class="p">}</span>
</code>
<p>Finally, to remove a value, use <code>dissoc</code>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:potatoes</span> <span class="mi">5</span> <span class="ss">:mushrooms</span> <span class="mi">2</span><span class="p">}</span> <span class="ss">:mushrooms</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:potatoes</span> <span class="mi">5</span><span class="p">}</span>
</code>
<h2>Putting it all together</h2>

<p>All these collections and types can be combined freely. As software engineers, we model the world by creating a particular <em>representation</em> of the problem in the program. Having a rich set of values at our disposal allows us to talk about complex problems. We might describe a person:</p>
<code class="block"><span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Amelia Earhart&quot;</span>
 <span class="ss">:birth</span> <span class="mi">1897</span>
 <span class="ss">:death</span> <span class="mi">1939</span>
 <span class="ss">:awards</span> <span class="p">{</span><span class="s">&quot;US&quot;</span>    <span class="o">#</span><span class="p">{</span><span class="s">&quot;Distinguished Flying Cross&quot;</span> <span class="s">&quot;National Women&#39;s Hall of Fame&quot;</span><span class="p">}</span>
          <span class="s">&quot;World&quot;</span> <span class="o">#</span><span class="p">{</span><span class="s">&quot;Altitude record for Autogyro&quot;</span> <span class="s">&quot;First to cross Atlantic twice&quot;</span><span class="p">}}}</span>
</code>
<p>Or a recipe:</p>
<code class="block"><span class="p">{</span><span class="ss">:title</span> <span class="s">&quot;Chocolate chip cookies&quot;</span>
 <span class="ss">:ingredients</span> <span class="p">{</span><span class="s">&quot;flour&quot;</span>           <span class="p">[(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">1</span><span class="nv">/4</span><span class="p">)</span> <span class="ss">:cup</span><span class="p">]</span>
               <span class="s">&quot;baking soda&quot;</span>     <span class="p">[</span><span class="mi">1</span>   <span class="ss">:teaspoon</span><span class="p">]</span>
               <span class="s">&quot;salt&quot;</span>            <span class="p">[</span><span class="mi">1</span>   <span class="ss">:teaspoon</span><span class="p">]</span>
               <span class="s">&quot;butter&quot;</span>          <span class="p">[</span><span class="mi">1</span>   <span class="ss">:cup</span><span class="p">]</span>
               <span class="s">&quot;sugar&quot;</span>           <span class="p">[</span><span class="mi">3</span><span class="nv">/4</span> <span class="ss">:cup</span><span class="p">]</span>
               <span class="s">&quot;brown sugar&quot;</span>     <span class="p">[</span><span class="mi">3</span><span class="nv">/4</span> <span class="ss">:cup</span><span class="p">]</span>
               <span class="s">&quot;vanilla&quot;</span>         <span class="p">[</span><span class="mi">1</span>   <span class="ss">:teaspoon</span><span class="p">]</span>
               <span class="s">&quot;eggs&quot;</span>            <span class="mi">2</span>
               <span class="s">&quot;chocolate chips&quot;</span> <span class="p">[</span><span class="mi">12</span>  <span class="ss">:ounce</span><span class="p">]}}</span>
</code>
<p>Or the Gini coefficients of nations, as measured over time:</p>
<code class="block"><span class="p">{</span><span class="s">&quot;Afghanistan&quot;</span> <span class="p">{</span><span class="mi">2008</span> <span class="mf">27.8</span><span class="p">}</span>
 <span class="s">&quot;Indonesia&quot;</span>   <span class="p">{</span><span class="mi">2008</span> <span class="mf">34.1</span> <span class="mi">2010</span> <span class="mf">35.6</span> <span class="mi">2011</span> <span class="mf">38.1</span><span class="p">}</span>
 <span class="s">&quot;Uruguay&quot;</span>     <span class="p">{</span><span class="mi">2008</span> <span class="mf">46.3</span> <span class="mi">2009</span> <span class="mf">46.3</span> <span class="mi">2010</span> <span class="mf">45.3</span><span class="p">}}</span>
</code>
<p>In Clojure, we <em>compose</em> data structures to form more complex values; to talk about bigger ideas. We use operations like <code>first</code>, <code>nth</code>, <code>get</code>, and <code>contains?</code> to extract specific information from these structures, and modify them using <code>conj</code>, <code>disj</code>, <code>assoc</code>, <code>dissoc</code>, and so on.</p>

<p>We started this chapter with a discussion of <em>types</em>: groups of similar objects which obey the same rules. We learned that bigints, longs, ints, shorts, and bytes are all integers, that doubles and floats are approximations to decimal numbers, and that ratios represent fractions exactly. We learned the differences between strings for text, symbols as references, and keywords as short labels. Finally, we learned how to compose, alter, and inspect collections of elements. Armed with the basic nouns of Clojure, we&rsquo;re ready to write a broad array of programs.</p>

<p>I&rsquo;d like to conclude this tour with one last type of value. We&rsquo;ve inspected dozens of types so far&ndash;but what what happens when you turn the camera on itself?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type</span> <span class="nv">type</span><span class="p">)</span>
<span class="nv">clojure.core$type</span>
</code>
<p>What <em>is</em> this <code>type</code> thing, exactly? What <em>are</em> these verbs we&rsquo;ve been learning, and where do they come from? This is the central question of <a href="http://aphyr.com/posts/303-clojure-from-the-ground-up-functions">chapter three: functions</a>.</p>

    </div>
  </div>
</article>

      <article class="short post">
  <div class="backdrop">
    <div class="bar">
      <h1><a href="/posts/301-clojure-from-the-ground-up-welcome">Clojure from the ground up: welcome</a></h1>
    </div>
    <div class="body">
      <p>This guide aims to introduce newcomers and experienced programmers alike to the
beauty of functional programming, starting with the simplest building blocks of
software. You&rsquo;ll need a computer, basic proficiency in the command line, a text editor, and an internet connection. By the end of this series, you&rsquo;ll have a thorough command of the Clojure programming language.</p>

<h2>Who is this guide for?</h2>

<p>Science, technology, engineering, and mathematics are deeply rewarding fields, yet few women enter STEM as a career path. Still more are discouraged by a culture which repeatedly asserts that women lack the analytic aptitude for writing software, that they are not driven enough to be successful scientists, that it&rsquo;s not cool to pursue a passion for structural engineering. Those few with the talent, encouragement, and persistence to break in to science and tech are discouraged by persistent sexism in practice: the old boy&rsquo;s club of tenure, being passed over for promotions, isolation from peers, and flat-out assault. This landscape sucks. I want to help change it.</p>

<p><a href="https://twitter.com/WomenWhoCode">Women Who Code</a>, <a href="http://www.pyladies.com/">PyLadies</a>, <a href="http://www.blackgirlscode.com/">Black Girls Code</a>, <a href="http://railsbridge.org/">RailsBridge</a>, <a href="http://www.girlswhocode.com/about-us/">Girls Who Code</a>, <a href="http://www.girldevelopit.com/">Girl Develop It</a>, and <a href="http://www.lambdaladies.com/">Lambda Ladies</a> are just a few of the fantastic groups helping women enter and thrive in software. I wholeheartedly support these efforts.</p>

<p>In addition, I want to help in my little corner of the technical community&ndash;functional programming and distributed systems&ndash;by making high-quality educational resources available for free. The <a href="/tags/jepsen">Jepsen</a> series has been, in part, an effort to share my enthusiasm for distributed systems with beginners of all stripes&ndash;but especially for <a href="http://aphyr.com/posts/275-meritocracy-is-short-sighted">women, LGBT folks, and people of color</a>.</p>

<p>As technical authors, we often assume that our readers are white, that our readers are straight, that our readers are traditionally male. This is the invisible default in US culture, and it&rsquo;s especially true in tech. People continue to assume on the basis of my software and writing that I&rsquo;m straight, because well hey, it&rsquo;s a statistically reasonable assumption.</p>

<p>But I&rsquo;m <em>not</em> straight. I get called faggot, cocksucker, and sinner. People say they&rsquo;ll pray for me. When I walk hand-in-hand with my boyfriend, people roll down their car windows and stare. They threaten to beat me up or kill me. Every day I&rsquo;m aware that I&rsquo;m the only gay person some people know, and that I can show that not all gay people are effeminate, or hypermasculine, or ditzy, or obsessed with image. That you can be a manicurist or a mathematician or both. Being different, being a stranger in your culture, <a href="http://aphyr.com/posts/274-identity-and-state">comes with all kinds of challenges</a>. I can&rsquo;t speak to everyone&rsquo;s experience, but I can take a pretty good guess.</p>

<p>At the same time, in the technical community I&rsquo;ve found overwhelming warmth and support, from people of <em>all</em> stripes. My peers stand up for me every day, and I&rsquo;m so thankful&ndash;especially you straight dudes&ndash;for understanding a bit of what it&rsquo;s like to be different. I want to extend that same understanding, that same empathy, to people unlike myself. Moreover, I want to reassure everyone that though they may feel different, they <em>do</em> have a place in this community.</p>

<p>So before we begin, I want to reinforce that you <em>can</em> program, that you <em>can</em> do math, that you <em>can</em> design car suspensions and fire suppression systems and spacecraft control software and distributed databases, regardless of what your classmates and media and even fellow engineers think. You don&rsquo;t have to be white, you don&rsquo;t have to be straight, you don&rsquo;t have to be a man. You can grow up never having touched a computer and still become a skilled programmer. Yeah, it&rsquo;s harder&ndash;and yeah, people will give you shit, but that&rsquo;s not your fault and has nothing to do with your <em>ability</em> or your <em>right</em> to do what you love. All it takes to be a good engineer, scientist, or mathematician is your curiosity, your passion, the right teaching material, and putting in the hours.</p>

<p>There&rsquo;s nothing in this guide that&rsquo;s just for lesbian grandmas or just for mixed-race kids; bros, you&rsquo;re welcome here too. There&rsquo;s nothing dumbed down. We&rsquo;re gonna go as deep into the ideas of programming as I know how to go, and we&rsquo;re gonna do it with everyone on board.</p>

<p>No matter who you are or who people <em>think</em> you are, this guide is for you.</p>

<h2>Why Clojure?</h2>

<p>This book is about how to program. We&rsquo;ll be learning in Clojure, which is a modern dialect of a very old family of computer languages, called Lisp. You&rsquo;ll find that many of this book&rsquo;s ideas will translate readily to other languages; though they may be <a href="http://aphyr.com/posts/266-core-language-concepts">expressed in different ways</a>.</p>

<p>We&rsquo;re going to explore the nature of syntax, metalanguages, values, references, mutation, control flow, and concurrency. Many languages leave these ideas implicit in the language construction, or don&rsquo;t have a concept of metalanguages or concurrency at all. Clojure makes these ideas explicit, first-class language constructs.</p>

<p>At the same time, we&rsquo;re going to defer or omit any serious discussion of static type analysis, hardware, and performance. This is not to say that these ideas aren&rsquo;t <em>important</em>; just that they don&rsquo;t fit well within this particular narrative arc. For a deep exploration of type theory I recommend a study in Haskell, and for a better understanding of underlying hardware, learning C and an assembly language will undoubtedly help.</p>

<p>In more general terms, Clojure is a well-rounded language. It offers broad library support and runs on multiple operating systems. Clojure performance is not terrific, but is orders of magnitude faster than Ruby, Python, or Javascript. Unlike some faster languages, Clojure emphasizes <em>safety</em> in its type system and approach to parallelism, making it easier to write correct multithreaded programs. Clojure is <em>concise</em>, requiring very little code to express complex operations. It offers a REPL and dynamic type system: ideal for beginners to experiment with, and well-suited for manipulating complex data structures. A consistently designed standard library and full-featured set of core datatypes rounds out the Clojure toolbox.</p>

<p>Finally, there are some drawbacks. As a compiled language, Clojure is much slower to start than a scripting language; this makes it unsuitable for writing small scripts for interactive use. Clojure is also <em>not</em> well-suited for high-performance numeric operations. Though it is possible, you have to jump through hoops to achieve performance comparable with Java. I&rsquo;ll do my best to call out these constraints and shortcomings as we proceed through the text.</p>

<p>With that context out of the way, let&rsquo;s get started by installing Clojure!</p>

<h2>Getting set up</h2>

<p>First, you&rsquo;ll need a Java Virtual Machine, or JVM, and its associated
development tools, called the JDK. This is the software which <em>runs</em> a Clojure
program. If you&rsquo;re on Windows, install <a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle
JDK 1.7</a>. If you&rsquo;re on OS X or Linux, you may already have a JDK installed.
In a terminal, try:</p>
<code class="block">which javac
</code>
<p>If you see something like</p>
<code class="block">/usr/bin/javac
</code>
<p>Then you&rsquo;re good to go. If you don&rsquo;t see any output from that command, install the appropriate
<a
href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle
JDK 1.7</a> for your operating system, or whatever JDK your package manager has available.</p>

<p>When you have a JDK, you&rsquo;ll need <a href="http://leiningen.org">Leiningen</a>,
the Clojure build tool. If you&rsquo;re on a Linux or OS X computer, the instructions below
should get you going right away. If you&rsquo;re on Windows, see the Leiningen page
for an installer. If you get stuck, you might want to start with a
<a href="http://blog.teamtreehouse.com/command-line-basics">primer on command line basics</a>.</p>
<code class="block">mkdir -p ~/bin
<span class="nb">cd</span> ~/bin
curl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
chmod a+x lein
</code>
<p>Leiningen automatically handles installing Clojure, finding libraries from the
internet, and building and running your programs. We&rsquo;ll create a new Leiningen
project to play around in:</p>
<code class="block"><span class="nb">cd</span>
lein new scratch
</code>
<p>This creates a new directory in your homedir, called <code>scratch</code>. If you see <code>command not found</code> instead, it means the directory <code>~/bin</code> isn&rsquo;t registered with your terminal as a place to search for programs. To fix this, add the line</p>
<code class="block"><span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;$PATH&quot;</span>:~/bin
</code>
<p>to the file <code>.bash_profile</code> in your home directory, then run <code>source ~/.bash_profile</code>. Re-running <code>lein new scratch</code> should work.</p>

<p>Let&rsquo;s enter that directory, and start using Clojure itself:</p>
<code class="block"><span class="nb">cd </span>scratch
lein repl
</code>
<h2>The structure of programs</h2>

<p>When you type <code>lein repl</code> at the terminal, you&rsquo;ll see something like this:</p>
<code class="block">aphyr@waterhouse:~&#x2F;scratch$ lein repl
nREPL server started on port 45413
REPL-y 0.2.0
Clojure 1.5.1
    Docs: (doc function-name-here)
          (find-doc &quot;part-of-name-here&quot;)
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)

user=&gt;</code>
<p>This is an interactive Clojure environment called a REPL, for &ldquo;Read, Evaluate,
Print Loop&rdquo;. It&rsquo;s going to <em>read</em> a program we enter, run that program, and
print the results. REPLs give you quick feedback, so they&rsquo;re a great way to
explore a program interactively, run tests, and prototype new ideas.</p>

<p>Let&rsquo;s write a simple program. The simplest, in fact. Type &ldquo;nil&rdquo;, and hit enter.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">nil</span>
<span class="nv">nil</span>
</code>
<p><code>nil</code> is the most basic value in Clojure. It represents emptiness,
nothing-doing, not-a-thing. The absence of information.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">true</span>
<span class="nv">true</span>
<span class="nv">user=&gt;</span> <span class="nv">false</span>
<span class="nv">false</span>
</code>
<p><code>true</code> and <code>false</code> are a pair of special values called <em>Booleans</em>. They mean
exactly what you think: whether a statement is true or false. <code>true</code>, <code>false</code>, and <code>nil</code> form the three poles of the Lisp logical system.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="mi">0</span>
<span class="mi">0</span>
</code>
<p>This is the number zero. Its numeric friends are <code>1</code>, <code>-47</code>, <code>1.2e-4</code>, <code>1/3</code>,
and so on. We might also talk about <em>strings</em>, which are chunks of text surrounded by double quotes:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="s">&quot;hi there!&quot;</span>
<span class="s">&quot;hi there!&quot;</span>
</code>
<p><code>nil</code>, <code>true</code>, <code>0</code>, and <code>&quot;hi there!&quot;</code> are all different types of <em>values</em>; the
nouns of programming. Just as one could say &ldquo;House.&rdquo; in English, we can write a
program like <code>&quot;hello, world&quot;</code> and it evaluates to itself: the string <code>&quot;hello
world&quot;</code>. But most sentences aren&rsquo;t just about stating the existence of a thing; they involve <em>action</em>. We need <em>verbs</em>.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="nv">inc</span>
<span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">6</span><span class="nv">f7ef41c&gt;</span>
</code>
<p>This is a verb called <code>inc</code>&ndash;short for &ldquo;increment&rdquo;. Specifically, <code>inc</code> is a
<em>symbol</em> which <em>points</em> to a verb: <code>#&lt;core$inc clojure.core$inc@6f7ef41c&gt;</code>&ndash;
just like the word &ldquo;run&rdquo; is a <em>name</em> for the <em>concept</em> of running.</p>

<p>There&rsquo;s a key distinction here&ndash;that a signifier, a reference, a label, is not
the same as the signified, the referent, the concept itself. If you write the
word &ldquo;run&rdquo; on paper, the ink means nothing by itself. It&rsquo;s just a symbol. But
in the mind of a reader, that symbol takes on <em>meaning</em>; the idea of running.</p>

<p>Unlike the number 0, or the string &ldquo;hi&rdquo;, symbols are references to other
values. when Clojure evaluates a symbol, it looks up that symbol&rsquo;s meaning.
Look up <code>inc</code>, and you get <code>#&lt;core$inc clojure.core$inc@6f7ef41c&gt;</code>.</p>

<p>Can we refer to the symbol itself, <em>without</em> looking up its meaning?</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="ss">&#39;inc</span>
<span class="nv">inc</span>
</code>
<p>Yes. The single quote <code>&#39;</code> <em>escapes</em> a sentence. In programming languages, we call sentences <code>expressions</code> or <code>statements</code>. A quote says &ldquo;Rather than <em>evaluating</em> this expression&rsquo;s text, simply return the text itself, unchanged.&rdquo; Quote a symbol, get a symbol. Quote a number, get a number. Quote anything, and get it back exactly as it came in.</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="ss">&#39;123</span>
<span class="mi">123</span>
<span class="nv">user=&gt;</span> <span class="o">&#39;</span><span class="s">&quot;foo&quot;</span>
<span class="s">&quot;foo&quot;</span>
<span class="nv">user=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</code>
<p>A new kind of value, surrounded by parentheses: the <em>list</em>. LISP originally stood for LISt Processing, and lists are still at the core of the language. In fact, they form the most basic way to compose expressions, or sentences. A list is a single expression which has <em>multiple parts</em>. For instance, this list contains three elements: the numbers 1, 2, and 3. Lists can contain anything: numbers, strings, even other lists:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">nil</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">nil</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
</code>
<p>A list containing two elements: the number 1, and a second list. That list
contains two elements: the number 2, and another list. <em>That</em> list contains two
elements: 3, and an empty list.</p>
<code class="block">user=&gt; &#x27;(1 (2 (3 ())))
(1 (2 (3 ())))</code>
<p>You could think of this structure as a tree&ndash;which is a provocative idea,
because <em>languages</em> are like trees too: sentences are comprised of clauses, which can be nested, and each clause may have subjects modified by adjectives, and verbs modified by adverbs, and so on. &ldquo;Lindsay, my best friend, took the dog which we found together at the pound on fourth street, for a walk with her mother Michelle.&rdquo;</p>
<code class="block">Took
  Lindsay
    my best friend
  the dog
    which we found together
      at the pound
        on fourth street
    for a walk
      with her mother
        Michelle</code>
<p>But let&rsquo;s try something simpler. Something we know how to talk about.
&ldquo;Increment the number zero.&rdquo; As a tree:</p>
<code class="block">Increment
  the number zero</code>
<p>We have a symbol for incrementing, and we know how to write the number zero.
Let&rsquo;s combine them in a list:</p>
<code class="block"><span class="nv">clj=&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">inc </span><span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="nb">inc </span><span class="mi">0</span><span class="p">)</span>
</code>
<p>A basic sentence. Remember, since it&rsquo;s quoted, we&rsquo;re talking about the tree,
the text, the expression, by itself. Absent interpretation. If we remove the
single-quote, Clojure will <em>interpret</em> the expression:</p>
<code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="mi">0</span><span class="p">)</span>
<span class="mi">1</span>
</code>
<p>Incrementing zero yields one. And if we wanted to increment <em>that</em> value?</p>
<code class="block">Increment
  increment
    the number zero</code><code class="block"><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
<span class="mi">2</span>
</code>
<p>A sentence in Lisp is a list. It starts with a verb, and is followed by zero or
more objects for that verb to act on. Each part of the list can <em>itself</em> be
another list, in which case that nested list is evaluated first, just like a
nested clause in a sentence. When we type</p>
<code class="block"><span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="nb">inc </span><span class="mi">0</span><span class="p">))</span>
</code>
<p>Clojure first looks up the meanings for the symbols in the code:</p>
<code class="block"><span class="p">(</span><span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">6</span><span class="nv">f7ef41c&gt;</span>
  <span class="p">(</span><span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">6</span><span class="nv">f7ef41c&gt;</span>
    <span class="mi">0</span><span class="p">))</span>
</code>
<p>Then evaluates the innermost list <code>(inc 0)</code>, which becomes the number 1:</p>
<code class="block"><span class="p">(</span><span class="o">#</span><span class="nv">&lt;core$inc</span> <span class="nv">clojure.core$inc</span><span class="o">@</span><span class="mi">6</span><span class="nv">f7ef41c&gt;</span>
 <span class="mi">1</span><span class="p">)</span>
</code>
<p>Finally, it evaluates the outer list, incrementing the number 1:</p>
<code class="block"><span class="mi">2</span>
</code>
<p>Every list starts with a verb. Parts of a list are evaluated from left to
right. Innermost lists are evaluated before outer lists.</p>
<code class="block"><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">3</span>       <span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">3</span>       <span class="mi">7</span><span class="p">)</span>
<span class="mi">11</span>
</code>
<p>That&rsquo;s it.</p>

<p>The entire grammar of Lisp: the structure for every expression in the language.
We transform expressions by <em>substituting</em> meanings for symbols, and obtain
some result. This is the core of the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">Lambda Calculus</a>, and it is the theoretical basis for almost all computer languages.
Ruby, Javascript, C, Haskell; all languages express the text of their programs in different ways, but internally all construct a <em>tree</em> of expressions. Lisp simply makes it explicit.</p>

<h2>Review</h2>

<p>We started by learning a few basic nouns: numbers like <code>5</code>, strings like
<code>&quot;cat&quot;</code>, and symbols like <code>inc</code> and <code>+</code>. We saw how quoting makes the
difference between an <em>expression</em> itself and the thing it <em>evaluates</em> to.  We
discovered symbols as <em>names</em> for other values, just like how words represent
concepts in any other language. Finally, we combined lists to make trees, and
used those trees to represent a program.</p>

<p>With these basic elements of syntax in place, it&rsquo;s time to expand our
vocabulary with new verbs and nouns; learning to <a href="http://aphyr.com/posts/302-clojure-from-the-ground-up-basic-types">represent more complex values and transform them in different ways</a>.</p>

    </div>
  </div>
</article>


  <div class="clear">
</div>

  </div>

  <div id="colophon">
    Copyright &copy; 2015 Kyle Kingsbury.<br /> 
    Non-commercial re-use with attribution encouraged; all other rights reserved.<br />
    Comments are the property of respective posters.
  </div>

  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9527251-1']);
  _gaq.push(['_trackPageview']);

  (function() {
   var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
   })();
  </script>
</body>
</html>
